<?php declare(strict_types=1); /** * Copyright (c) Be Delightful , Distributed under the MIT software license */ namespace Delightful\BeDelightful\Application\BeAgent\Crontab; use App\Infrastructure\Util\IdGenerator\IdGenerator; use App\Infrastructure\Util\Locker\LockerInterface; use BeDelightful\BeDelightful\Application\BeAgent\Service\TopicAppService; use BeDelightful\BeDelightful\Application\BeAgent\Service\TopicTaskAppService; use BeDelightful\BeDelightful\Domain\BeAgent\Entity\ValueObject\TaskStatus; use BeDelightful\BeDelightful\Infrastructure\ExternalAPI\Sandbox\SandboxInterface; use Hyperf\Crontab\Annotation\Crontab; use Hyperf\Logger\LoggerFactory; use Psr\Log\LoggerInterface; use Throwable; /** * ChecklongTimeInRunStatusTask*/ #[Crontab(rule: '12 * * * *', name: 'CheckTaskStatus', singleton: true, onOneServer: true, callback: 'execute', memo: 'everysmall time th12MinuteCheckexceed6small time  un CompleteTopicAndContainerStatus')] readonly class CheckTaskStatusTask { private const GLOBAL_LOCK_KEY = 'check_task_status_crontab_lock'; private const GLOBAL_LOCK_EXPIRE = 900; // Global lock timeout: 15 minutes protected LoggerInterface $logger; public function __construct( protected TopicAppService $topicAppService, protected TopicTaskAppService $taskAppService, protected SandboxInterface $sandboxService, private LockerInterface $locker, LoggerFactory $loggerFactory ) { $this->logger = $loggerFactory->get(self::class); } /** * ExecuteTask, Checkexceed3small time  un UpdateTaskAndBy/According toSandboxStatusUpdateTaskStatus*/ public function execute(): void { $enableCrontab = config('be-delightful.task.check_task_crontab.enabled', false); if ($enableCrontab === false) { return; } $startTime = microtime(true); $globalLockOwner = IdGenerator::getUniqueId32(); $this->logger->info('[CheckTaskStatusTask] StartChecklongTime un UpdateTask'); // Step 1: Acquire global lock to prevent multiple instances if (! $this->acquireGlobalLock($globalLockOwner)) { $this->logger->info('[CheckTaskStatusTask] Unable toGetGlobal lock，OtherInstancecorrectinExecuteTask，Skipthis times Execute'); return; } try { // CheckTaskStatusAndContainerStatus $this->checkTasksStatus(); $executionTime = round((microtime(true) - $startTime) * 1000, 2); $this->logger->info(sprintf( '[CheckTaskStatusTask] TaskExecuteComplete，consume time : %sms', $executionTime )); } catch (Throwable $e) { $this->logger->error(sprintf('[CheckTaskStatusTask] Execution failed: %s', $e->getMessage()), [ 'exception' => $e, ]); } finally { // Step 2: Always release global lock $this->releaseGlobalLock($globalLockOwner); } } /** * CheckTaskStatusAndContainerStatus*/ private function checkTasksStatus(): void { try { // get6small time beforeTime point  $timeThreshold = date('Y-m-d H:i:s', strtotime('-3 hours')); // getTimeoutTopiclist (Updated atexceed7small time Topic,  most multiple100condition) $staleRunningTopics = $this->topicAppService->getTopicsExceedingUpdateTime($timeThreshold, 100); if (empty($staleRunningTopics)) { $this->logger->info('[CheckTaskStatusTask] No/NoneNeedCheckTimeoutTopic'); return; } $this->logger->info(sprintf('[CheckTaskStatusTask] StartCheck %d  each TimeoutTopicContainerStatus', count($staleRunningTopics))); $updatedToRunningCount = 0; $updatedToErrorCount = 0; foreach ($staleRunningTopics as $topic) { // every times loop after Hibernate0.1 seconds , avoidRequestoverinfrequent usleep(100000); // 100000Microsecond = 0.1 seconds  $status = $this->taskAppService->updateTaskStatusFromSandbox($topic); if ($status === TaskStatus::RUNNING) { ++$updatedToRunningCount; continue; } ++$updatedToErrorCount; } $this->logger->info(sprintf( '[CheckTaskStatusTask] CheckComplete，totalUpdate %d  each TopicForRunStatus，%d  each TopicForErrorStatus', $updatedToRunningCount, $updatedToErrorCount )); } catch (Throwable $e) { $this->logger->error(sprintf('[CheckTaskStatusTask] CheckTaskStatusFailed: %s', $e->getMessage())); throw $e; } } /** * Acquire global lock. */ private function acquireGlobalLock(string $lockOwner): bool { return $this->locker->mutexLock(self::GLOBAL_LOCK_KEY, $lockOwner, self::GLOBAL_LOCK_EXPIRE); } /** * Release global lock. */ private function releaseGlobalLock(string $lockOwner): void { if ($this->locker->release(self::GLOBAL_LOCK_KEY, $lockOwner)) { $this->logger->info('[CheckTaskStatusTask] Global lock releaseSuccess'); } else { $this->logger->error('[CheckTaskStatusTask] Global lock releaseFailed，May/PossibleNeedManualCheck'); } } } 