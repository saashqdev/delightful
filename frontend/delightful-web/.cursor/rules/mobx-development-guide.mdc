---
description: 
globs: 
alwaysApply: false
---
@rule MobX Development Guide
@description MobX state management best practices and code examples
@priority medium
@category development

# MobX Development Guide

## Basic Concepts

MobX is a simple, scalable state management library that follows these core principles:

1. **Observable State**: Observable state, defines the data model in the application
2. **Computed Values**: Computed values, values derived from state
3. **Reactions**: Reactions, side effects that execute automatically when state changes
4. **Actions**: Actions, methods to modify state

## Store Design Pattern

In this project, we adopt a class-based MobX Store pattern:

```typescript
// src/stores/todo-store.ts
import { makeAutoObservable, runInAction } from 'mobx';

export interface Todo {
  id: string;
  content: string;
  completed: boolean;
}

export class TodoStore {
  todos: Todo[] = [];
  filter: 'all' | 'active' | 'completed' = 'all';
  loading = false;
  error: string | null = null;

  constructor() {
    // Automatically convert all properties and methods to observable/action
    makeAutoObservable(this);
  }

  // Computed properties
  get filteredTodos() {
    switch (this.filter) {
      case 'active':
        return this.todos.filter(todo => !todo.completed);
      case 'completed':
        return this.todos.filter(todo => todo.completed);
      default:
        return this.todos;
    }
  }

  get completedCount() {
    return this.todos.filter(todo => todo.completed).length;
  }

  get activeCount() {
    return this.todos.length - this.completedCount;
  }

  // Action methods
  addTodo = (content: string) => {
    this.todos.push({
      id: Date.now().toString(),
      content,
      completed: false
    });
  };

  toggleTodo = (id: string) => {
    const todo = this.todos.find(todo => todo.id === id);
    if (todo) {
      todo.completed = !todo.completed;
    }
  };

  removeTodo = (id: string) => {
    this.todos = this.todos.filter(todo => todo.id !== id);
  };

  setFilter = (filter: 'all' | 'active' | 'completed') => {
    this.filter = filter;
  };

  clearCompleted = () => {
    this.todos = this.todos.filter(todo => !todo.completed);
  };

  // Async action example
  fetchTodos = async () => {
    this.loading = true;
    this.error = null;
    
    try {
      const response = await fetch('/api/todos');
      const data = await response.json();
      
      // Use runInAction to wrap state updates after async operations
      runInAction(() => {
        this.todos = data;
        this.loading = false;
      });
    } catch (error) {
      runInAction(() => {
        this.error = error instanceof Error ? error.message : 'Loading failed';
        this.loading = false;
      });
    }
  };
}
```

## Store Instantiation and Usage

Create a root Store to manage all child Stores:

```typescript
// src/stores/root-store.ts
import { TodoStore } from './todo-store';
import { UserStore } from './user-store';

export class RootStore {
  todoStore: TodoStore;
  userStore: UserStore;

  constructor() {
    this.todoStore = new TodoStore();
    this.userStore = new UserStore();
  }
}

// Create singleton instance
export const rootStore = new RootStore();
```

## React Integration

Using MobX React integration:

```typescript
// src/components/TodoList.tsx
import { observer } from 'mobx-react-lite';
import { useStore } from '../hooks/use-store';
import { createStyle } from 'antd-style';

const useStyles = createStyle(({ token }) => ({
  container: {
    padding: token.padding,
    backgroundColor: token.colorBgContainer,
    borderRadius: token.borderRadius,
  },
  item: {
    padding: token.paddingSM,
    borderBottom: `1px solid ${token.colorBorderSecondary}`,
    display: 'flex',
    alignItems: 'center',
  },
  completed: {
    textDecoration: 'line-through',
    color: token.colorTextDisabled,
  },
}));

export const TodoList = observer(() => {
  const { todoStore } = useStore();
  const styles = useStyles();

  if (todoStore.loading) {
    return <div>Loading...</div>;
  }

  if (todoStore.error) {
    return <div>Error: {todoStore.error}</div>;
  }

  return (
    <div className={styles.container}>
      <div>
        <span>Remaining: {todoStore.activeCount}</span>
        <button onClick={() => todoStore.setFilter('all')}>All</button>
        <button onClick={() => todoStore.setFilter('active')}>Active</button>
        <button onClick={() => todoStore.setFilter('completed')}>Completed</button>
        <button onClick={todoStore.clearCompleted}>Clear Completed</button>
      </div>
      
      <ul>
        {todoStore.filteredTodos.map(todo => (
          <li 
            key={todo.id} 
            className={`${styles.item} ${todo.completed ? styles.completed : ''}`}
          >
            <input
              type="checkbox"
              checked={todo.completed}
              onChange={() => todoStore.toggleTodo(todo.id)}
            />
            <span>{todo.content}</span>
            <button onClick={() => todoStore.removeTodo(todo.id)}>Delete</button>
          </li>
        ))}
      </ul>
      
      <form onSubmit={(e) => {
        e.preventDefault();
        const input = e.currentTarget.elements.namedItem('content') as HTMLInputElement;
        todoStore.addTodo(input.value);
        input.value = '';
      }}>
        <input name="content" placeholder="Add new task..." />
        <button type="submit">Add</button>
      </form>
    </div>
  );
});
```

## Store Injection

Using React Context to provide Store:

```typescript
// src/hooks/use-store.tsx
import { createContext, useContext, ReactNode } from 'react';
import { rootStore, RootStore } from '../stores/root-store';

const StoreContext = createContext<RootStore | undefined>(undefined);

export const StoreProvider = ({ children }: { children: ReactNode }) => {
  return (
    <StoreContext.Provider value={rootStore}>
      {children}
    </StoreContext.Provider>
  );
};

export const useStore = () => {
  const store = useContext(StoreContext);
  if (!store) {
    throw new Error('useStore must be used within StoreProvider');
  }
  return store;
};
```

## Best Practices

1. **Use `makeAutoObservable`** to simplify observable/action definitions

2. **Wrap components with `observer`**
   ```tsx
   import { observer } from 'mobx-react-lite';
   
   export const MyComponent = observer(() => {
     // Component implementation...
   });
   ```

3. **Use `runInAction` for async operations**
   ```typescript
   fetchData = async () => {
     this.loading = true;
     try {
       const data = await api.getData();
       runInAction(() => {
         this.data = data;
         this.loading = false;
       });
     } catch (error) {
       runInAction(() => {
         this.error = error;
         this.loading = false;
       });
     }
   };
   ```

4. **Modular Store Design**
   - Divide Stores by functionality
   - Use root Store to compose child Stores
   - Avoid direct dependencies between Stores, use Store references for cross-Store communication

5. **Performance Optimization**
   - Avoid overly large observable objects
   - Use computed values to cache derived state
   - Keep component granularity reasonable, avoid large observer components

6. **Debug Tools Integration**
   ```typescript
   import { configure } from 'mobx';
   
   // Enable strict mode in development environment
   if (process.env.NODE_ENV === 'development') {
     configure({
       enforceActions: 'always',  // Force use of action to update state
       computedRequiresReaction: true,  // Optimize computed values
       reactionRequiresObservable: true,  // Optimize reactions
       observableRequiresReaction: true,  // Optimize observables
     });
   }
   ```
