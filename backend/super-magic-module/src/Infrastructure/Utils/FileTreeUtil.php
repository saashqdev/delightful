<?php declare(strict_types=1); /** * Copyright (c) Be Delightful , Distributed under the MIT software license */ namespace Dtyq\SuperMagic\Infrastructure\Utils; /** * FiletreeBuildToolClass.*/ class FileTreeUtil { /** * ConvertFilelistassemblesuccesstree state structure, Supportnolimitextremely nested. * *  new VersiondirectlyUse relative_file_path Buildtreestructure, Support is_directory field * * @param array $files FilelistData * @return array tree state structureArray*/ public static function assembleFilesTree(array $files): array { if (empty($files)) { return []; } // preProcess/Handle:  by SortValuePairFile enter RowSort usort($files, function ($a, $b) { // first first By parentDirectoryGroup $aParentId = $a['parent_id'] ?? 0; $bParentId = $b['parent_id'] ?? 0; if ($aParentId !== $bParentId) { return $aParentId <=> $bParentId; } // Same parentDirectoryBelow bySortValueSort $aSortValue = $a['sort'] ?? 0; $bSortValue = $b['sort'] ?? 0; if ($aSortValue === $bSortValue) { // SortValueSame time  by file_idSort $aFileId = $a['file_id'] ?? 0; $bFileId = $b['file_id'] ?? 0; return $aFileId <=> $bFileId; } return $aSortValue <=> $bSortValue; }); // preProcess/Handle: For eachFileconfirmTypeAnd normalizationPath $processedFiles = []; foreach ($files as $file) { $relativePath = $file['relative_file_path'] ?? ''; if (empty($relativePath)) { continue; // SkipNo/Noneeach otherPairPath's File } // standardizePath: removestartslash, EnsureEnding with slash is Directory $normalizedPath = ltrim($relativePath, '/'); // detectwhetherForDirectory $isDirectory = self::detectIsDirectory($file); $processedFiles[] = [ 'original_data' => $file, 'normalized_path' => $normalizedPath, 'is_directory' => $isDirectory, 'path_parts' => $normalizedPath ? explode('/', rtrim($normalizedPath, '/')) : [], ]; } // BuildFiletree $root = [ 'type' => 'root', 'is_directory' => true, 'is_hidden' => false, 'children' => [], ]; // DirectoryMapping, Used forfastFindDirectoryNode $directoryMap = ['' => &$root]; // thonestep: CreateAllDirectoryNode foreach ($processedFiles as $processedFile) { if (! $processedFile['is_directory']) { continue; } $pathParts = $processedFile['path_parts']; if (empty($pathParts)) { continue; } self::ensureDirectoryPath($directoryMap, $pathParts, $processedFile['original_data']); } // thtwostep: PlaceAllFile to Pair should Directory foreach ($processedFiles as $processedFile) { if ($processedFile['is_directory']) { continue; } $pathParts = $processedFile['path_parts']; if (empty($pathParts)) { continue; } // Filename is Path most  after onePart $fileName = array_pop($pathParts); // EnsureparentDirectory store in if (! empty($pathParts)) { self::ensureDirectoryPath($directoryMap, $pathParts); } // CreateFileNode $fileNode = $processedFile['original_data']; $fileNode['type'] = 'file'; $fileNode['is_directory'] = false; $fileNode['children'] = []; $fileNode['name'] = $fileName; // detectwhetherFor hidingFile if (! isset($fileNode['is_hidden'])) { $fileNode['is_hidden'] = str_starts_with($fileName, '.'); } // getparentDirectoryPath $parentPath = empty($pathParts) ? '' : implode('/', $pathParts); // ConvertFileaddTo parentDirectory if (isset($directoryMap[$parentPath])) { $directoryMap[$parentPath]['children'][] = $fileNode; } } // ththreestep: PairAllDirectorysubNode enter RowSort self::sortAllDirectoryChildren($root); return $root['children']; } /** * getFiletreeStatisticsinformation. * * @param array $tree Filetree * @return array Statisticsinformation ['directories' => int, 'files' => int, 'total_size' => int]*/ public static function getTreeStats(array $tree): array { $stats = [ 'directories' => 0, 'files' => 0, 'total_size' => 0, ]; self::walkTree($tree, function ($node) use (&$stats) { if ($node['is_directory']) { ++$stats['directories']; } else { ++$stats['files']; $stats['total_size'] += $node['file_size'] ?? 0; } }); return $stats; } /** * FlattenFiletree, ReturnAllFile pathlist. * * @param array $tree Filetree * @param string $basePath BasePath * @return array File pathlist*/ public static function flattenTree(array $tree, string $basePath = ''): array { $paths = []; foreach ($tree as $node) { $currentPath = empty($basePath) ? ($node['name'] ?? '') : $basePath . '/' . ($node['name'] ?? ''); if (! $node['is_directory']) { $paths[] = $currentPath; } else { if (! empty($node['children'])) { $childPaths = self::flattenTree($node['children'], $currentPath); $paths = array_merge($paths, $childPaths); } } } return $paths; } /** * By/According toPathFindFiletree in Node. * * @param array $tree Filetree * @param string $path wantFindPath * @return Null|array FoundNode, IfNot foundReturnNull*/ public static function findNodeByPath(array $tree, string $path): ?array { $pathParts = explode('/', trim($path, '/')); $current = ['children' => $tree]; foreach ($pathParts as $part) { if (empty($part)) { continue; } $found = false; foreach ($current['children'] as $child) { if (($child['name'] ?? '') === $part) { $current = $child; $found = true; break; } } if (! $found) { return Null; } } return $current; } /** * Based on parent_id BuildFiletree, SupportMultiple rootsNodeScenario. * * whenselect in Fileall is flatlevel time  (Same parent_id), But parentDirectory un  be select in  time , * thismethodcanAutoidentify other  this  some FileFor root node, solvetreeBuildissue. * * @param array $files Filelist, mustcontaining file_id And parent_id field * @return array and assembleFilesTree Sameformattreestructure*/ public static function assembleFilesTreeByParentId(array $files): array { if (empty($files)) { return []; } // 1. receiveSetAll store in file_id AndBuildFileMapping $existingFileIds = []; $fileMap = []; foreach ($files as $file) { $fileId = $file['file_id'] ?? 0; if ($fileId > 0) { $existingFileIds[] = $fileId; $fileMap[$fileId] = $file; } } // 2.  by  parent_id Group, identify other rootNodeAnd childNode $parentChildMap = []; // parent_id => [child_files] $rootNodes = []; // rootNode（parent_id  not inExistingFile in ） foreach ($files as $file) { $fileId = $file['file_id'] ?? 0; $parentId = $file['parent_id'] ?? 0; if ($parentId <= 0 || ! in_array($parentId, $existingFileIds)) { // parentNodeDoes not existininCurrentFilelist in , viewFor root node $rootNodes[] = $file; } else { // parentNode store in, JoinparentsubMapping if (! isset($parentChildMap[$parentId])) { $parentChildMap[$parentId] = []; } $parentChildMap[$parentId][] = $file; } } // 3. RecursiveBuildtreestructure $result = []; // Process/HandlerootNode foreach ($rootNodes as $rootFile) { $result[] = self::buildNodeWithChildren($rootFile, $parentChildMap); } // 4. PairrootNode enter RowSort self::sortNodeChildrenArray($result); return $result; } /** * JudgeDirectorynamewhetherFor hidingDirectory * hideDirectoryJudgeRule: DirectoryName with. start. * * @param string $dirName Directoryname * @return bool true-hideDirectory, false-commonGeneralDirectory*/ private static function isHiddenDirectory(string $dirName): bool { return str_starts_with($dirName, '.'); } /** * TraverseFiletree, Pairevery each NodeExecuteCallbackFunction. * * @param array $tree Filetree * @param callable $callback CallbackFunction*/ private static function walkTree(array $tree, callable $callback): void { foreach ($tree as $node) { $callback($node); if (! empty($node['children'])) { self::walkTree($node['children'], $callback); } } } /** * detectFileitemwhetherForDirectory * Use preferentially is_directory field, Revert toPathAnalysis. * * @param array $file FileData * @return bool true-Directory, false-File*/ private static function detectIsDirectory(array $file): bool { // Use preferentially is_directory field ( new Data) if (isset($file['is_directory'])) { return (bool) $file['is_directory']; } // Revert toPathAnalysis (historyDataCompatible) $relativePath = $file['relative_file_path'] ?? ''; // PathEnding with slashGeneralconstantTableshowDirectory if (str_ends_with($relativePath, '/')) { return true; } // No/NoneFileExtensionName and file_size For 0 May beDirectory $fileExtension = $file['file_extension'] ?? ''; $fileSize = $file['file_size'] ?? 0; if (empty($fileExtension) && $fileSize === 0) { return true; } return false; } /** * EnsureDirectoryPath store in, IfDoes not existin then Create. * * @param array &$directoryMap DirectoryMappingTableReference * @param array $pathParts PathPartArray * @param Null|array $directoryData DirectoryOriginalData (Optional)*/ private static function ensureDirectoryPath(array &$directoryMap, array $pathParts, ?array $directoryData = Null): void { $currentPath = ''; $parentIsHidden = false; foreach ($pathParts as $index => $dirName) { if (empty($dirName)) { continue; } // BuildCurrentPath $currentPath = empty($currentPath) ? $dirName : "{$currentPath}/{$dirName}"; // IfDirectoryDoes not existin, Create it if (! isset($directoryMap[$currentPath])) { // JudgewhetherFor hidingDirectory $isHiddenDir = self::isHiddenDirectory($dirName) || $parentIsHidden; // CreateDirectoryNode $newDir = [ 'name' => $dirName, 'path' => $currentPath, 'type' => 'directory', 'is_directory' => true, 'is_hidden' => $isHiddenDir, 'children' => [], ]; // If is  most  after onePathPartandProvidedDirectoryData, MergeOriginalData if ($index === count($pathParts) - 1 && $directoryData) { $newDir = array_merge($directoryData, $newDir); } // getparentDirectoryPath $parentPath = ''; if ($index > 0) { $parentParts = array_slice($pathParts, 0, $index); $parentPath = implode('/', $parentParts); } // Convert new DirectoryaddTo parentDirectory if (isset($directoryMap[$parentPath])) { $directoryMap[$parentPath]['children'][] = $newDir; // getjustaddDirectoryReference $directoryMap[$currentPath] = &$directoryMap[$parentPath]['children'][count($directoryMap[$parentPath]['children']) - 1]; } } // UpdateParenthideStatus $parentIsHidden = $directoryMap[$currentPath]['is_hidden'] ?? false; } } /** * RecursiveSortAllDirectorysubNode.*/ private static function sortAllDirectoryChildren(array &$directory): void { if (empty($directory['children'])) { return; } // PairCurrentDirectorysubNode enter RowSort usort($directory['children'], function ($a, $b) { // DirectoryPriorityinFile $aIsDir = $a['is_directory'] ?? false; $bIsDir = $b['is_directory'] ?? false; if ($aIsDir !== $bIsDir) { return $bIsDir <=> $aIsDir; // Directoryinbefore } //  by SortValueSort $aSort = $a['sort'] ?? $a['original_data']['sort'] ?? 0; $bSort = $b['sort'] ?? $b['original_data']['sort'] ?? 0; if ($aSort === $bSort) { $aFileId = $a['file_id'] ?? $a['original_data']['file_id'] ?? 0; $bFileId = $b['file_id'] ?? $b['original_data']['file_id'] ?? 0; return $aFileId <=> $bFileId; } return $aSort <=> $bSort; }); // RecursiveSortsubDirectory foreach ($directory['children'] as &$child) { if ($child['is_directory'] ?? false) { self::sortAllDirectoryChildren($child); } } } /** * RecursiveBuildNodeanditssubNode. * * @param array $file FileData * @param array $parentChildMap parentsubRelationshipMapping [parent_id => [children]] * @return array standardizeNodeData*/ private static function buildNodeWithChildren(array $file, array $parentChildMap): array { // standardizeNodeformat, and assembleFilesTree KeepConsistent $node = $file; $node['type'] = ($file['is_directory'] ?? false) ? 'directory' : 'file'; $node['children'] = []; // Ensuremustwantfield store in if (! isset($node['name'])) { $node['name'] = $node['file_name'] ?? ''; } // If have subNode, RecursiveBuild $fileId = $file['file_id'] ?? 0; if (isset($parentChildMap[$fileId]) && ! empty($parentChildMap[$fileId])) { foreach ($parentChildMap[$fileId] as $childFile) { $node['children'][] = self::buildNodeWithChildren($childFile, $parentChildMap); } // PairsubNodeSort self::sortNodeChildrenArray($node['children']); } return $node; } /** * PairNodeArray enter RowSort. * * SortRuleand sortAllDirectoryChildren KeepConsistent: * 1. DirectoryPriorityinFile * 2.  by  sort fieldSort * 3. sort Same time  by  file_id Sort * * @param array &$nodes NodeArrayReference*/ private static function sortNodeChildrenArray(array &$nodes): void { if (empty($nodes)) { return; } usort($nodes, function ($a, $b) { // DirectoryPriorityinFile $aIsDir = $a['is_directory'] ?? false; $bIsDir = $b['is_directory'] ?? false; if ($aIsDir !== $bIsDir) { return $bIsDir <=> $aIsDir; // Directoryinbefore } //  by SortValueSort $aSort = $a['sort'] ?? 0; $bSort = $b['sort'] ?? 0; if ($aSort === $bSort) { // SortValueSame time  by  file_id Sort $aFileId = $a['file_id'] ?? 0; $bFileId = $b['file_id'] ?? 0; return $aFileId <=> $bFileId; } return $aSort <=> $bSort; }); } } 