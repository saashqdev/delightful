<?php declare(strict_types=1); /** * Copyright (c) Be Delightful , Distributed under the MIT software license */ namespace Delightful\SuperMagic\Application\SuperAgent\Service; use App\Domain\Contact\Entity\ValueObject\DataIsolation; use App\Infrastructure\Core\Exception\BusinessException; use Dtyq\SuperMagic\Domain\SuperAgent\Entity\TaskEntity; use Dtyq\SuperMagic\Domain\SuperAgent\Entity\TopicEntity; use Dtyq\SuperMagic\Domain\SuperAgent\Entity\ValueObject\ChatInstruction; use Dtyq\SuperMagic\Domain\SuperAgent\Entity\ValueObject\TaskContext; use Dtyq\SuperMagic\Domain\SuperAgent\Service\AgentDomainService; use Dtyq\SuperMagic\Domain\SuperAgent\Service\ProjectDomainService; use Dtyq\SuperMagic\Domain\SuperAgent\Service\TaskFileDomainService; use Dtyq\SuperMagic\Domain\SuperAgent\Service\TopicDomainService; use Dtyq\SuperMagic\Infrastructure\ExternalAPI\SandboxOS\Agent\Constant\WorkspaceStatus; use Dtyq\SuperMagic\Infrastructure\ExternalAPI\SandboxOS\Agent\Response\AgentResponse; use Dtyq\SuperMagic\Infrastructure\ExternalAPI\SandboxOS\Exception\SandboxOperationException; use Dtyq\SuperMagic\Infrastructure\ExternalAPI\SandboxOS\Gateway\Result\BatchStatusResult; use Dtyq\SuperMagic\Infrastructure\ExternalAPI\SandboxOS\Gateway\Result\SandboxStatusResult; use Dtyq\SuperMagic\Infrastructure\Utils\WorkDirectoryUtil; use Hyperf\Logger\LoggerFactory; use Psr\Log\LoggerInterface; use Throwable; /** * AgentApplicationService * ResponsiblecoordinateAgentDomainServicecall, followDDDoriginal then .*/ readonly class AgentAppService { private LoggerInterface $logger; public function __construct( private LoggerFactory $loggerFactory, private readonly AgentDomainService $agentDomainService, private readonly TopicDomainService $topicDomainService, private readonly TaskFileDomainService $taskFileDomainService, private readonly ProjectDomainService $projectDomainService, ) { $this->logger = $this->loggerFactory->get('sandbox'); } /** * getSandboxStatus * * @param string $sandboxId SandboxID * @return SandboxStatusResult SandboxStatusResult*/ public function getSandboxStatus(string $sandboxId): SandboxStatusResult { return $this->agentDomainService->getSandboxStatus($sandboxId); } /** * BatchgetSandboxStatus * * @param array $sandboxIds SandboxIDArray * @return BatchStatusResult BatchSandboxStatusResult*/ public function getBatchSandboxStatus(array $sandboxIds): BatchStatusResult { return $this->agentDomainService->getBatchSandboxStatus($sandboxIds); } /** * SendMessage give  agent.*/ public function sendChatMessage(DataIsolation $dataIsolation, TaskContext $taskContext): void { $this->agentDomainService->sendChatMessage($dataIsolation, $taskContext); } /** * Send interruptMessage give Agent. * * @param DataIsolation $dataIsolation DataIsolationcontext * @param string $sandboxId SandboxID * @param string $taskId TaskID * @param string $reason Interruption reason * @return AgentResponse InterruptResponse*/ public function sendInterruptMessage( DataIsolation $dataIsolation, string $sandboxId, string $taskId, string $reason, ): AgentResponse { return $this->agentDomainService->sendInterruptMessage($dataIsolation, $sandboxId, $taskId, $reason); } /** * getWorkspaceStatus. * * @param string $sandboxId SandboxID * @return AgentResponse WorkspaceStatusResponse*/ public function getWorkspaceStatus(string $sandboxId): AgentResponse { return $this->agentDomainService->getWorkspaceStatus($sandboxId); } /** * WaitWorkspaceReady. * pollingWorkspaceStatus, direct to InitializeCompleteã€Failed or Timeout. * * @param string $sandboxId SandboxID * @param int $timeoutSeconds TimeoutTime ( seconds ), default10Minute * @param int $intervalSeconds pollingInterval ( seconds ), default2 seconds */ public function waitForWorkspaceReady(string $sandboxId, int $timeoutSeconds = 600, int $intervalSeconds = 2): void { $this->logger->info('[Sandbox][App] Waiting for workspace to be ready', [ 'sandbox_id' => $sandboxId, 'timeout_seconds' => $timeoutSeconds, 'interval_seconds' => $intervalSeconds, ]); $startTime = time(); $endTime = $startTime + $timeoutSeconds; while (time() < $endTime) { try { $response = $this->getWorkspaceStatus($sandboxId); $status = $response->getDataValue('status'); $this->logger->debug('[Sandbox][App] Workspace status check', [ 'sandbox_id' => $sandboxId, 'status' => $status, 'status_description' => WorkspaceStatus::getDescription($status), 'elapsed_seconds' => time() - $startTime, ]); // StatusExit when ready if (WorkspaceStatus::isReady($status)) { $this->logger->info('[Sandbox][App] Workspace is ready', [ 'sandbox_id' => $sandboxId, 'elapsed_seconds' => time() - $startTime, ]); return; } // StatusForErrorThrow whenAbnormal if (WorkspaceStatus::isError($status)) { $this->logger->error('[Sandbox][App] Workspace initialization failed', [ 'sandbox_id' => $sandboxId, 'status' => $status, 'status_description' => WorkspaceStatus::getDescription($status), 'elapsed_seconds' => time() - $startTime, ]); throw new SandboxOperationException('Wait for workspace ready', 'Workspace initialization failed with status: ' . WorkspaceStatus::getDescription($status), 3001); } // WaitNext polling sleep($intervalSeconds); } catch (SandboxOperationException $e) { //  re ThrowSandboxOperationAbnormal throw $e; } catch (Throwable $e) { $this->logger->error('[Sandbox][App] Error while checking workspace status', [ 'sandbox_id' => $sandboxId, 'error' => $e->getMessage(), 'elapsed_seconds' => time() - $startTime, ]); throw new SandboxOperationException('Wait for workspace ready', 'Error checking workspace status: ' . $e->getMessage(), 3002); } } // Timeout $this->logger->error('[Sandbox][App] Workspace ready timeout', [ 'sandbox_id' => $sandboxId, 'timeout_seconds' => $timeoutSeconds, ]); throw new SandboxOperationException('Wait for workspace ready', 'Workspace ready timeout after ' . $timeoutSeconds . ' seconds', 3003); } /** * EnsureSandbox already InitializeandWorkspaceInreadyStatus. * * @param DataIsolation $dataIsolation DataIsolationcontext * @param int $topicId TopicID * @return string SandboxID * @throws BusinessException whenInitializeFailed time */ public function ensureSandboxInitialized(DataIsolation $dataIsolation, int $topicId): string { $this->logger->info('[Sandbox][App] Ensuring sandbox is initialized', [ 'topic_id' => $topicId, ]); // getTopicinformation $topicEntity = $this->topicDomainService->getTopicById($topicId); if (is_Null($topicEntity)) { throw new BusinessException('Topic not found for ID: ' . $topicId); } $sandboxId = $topicEntity->getSandboxId(); // CheckWorkspaceStatus try { $response = $this->getWorkspaceStatus($sandboxId); $status = $response->getDataValue('status'); // IfWorkspace already throughReady, directlyReturn if (WorkspaceStatus::isReady($status)) { $this->logger->info('[Sandbox][App] Workspace already ready', [ 'sandbox_id' => $sandboxId, 'workspace_status' => $status, ]); return $sandboxId; } // Workspace un Ready, Need re Initialize $this->logger->info('[Sandbox][App] Workspace not ready, will reinitialize', [ 'sandbox_id' => $sandboxId, 'workspace_status' => $status, ]); } catch (SandboxOperationException $e) { // WorkspaceStatusCheckFailed, Need re Initialize $this->logger->warning('[Sandbox][App] Failed to check workspace status, will reinitialize', [ 'sandbox_id' => $sandboxId, 'error' => $e->getMessage(), ]); } // Create or re InitializeSandbox $sandboxId = $this->createAndInitializeSandbox($dataIsolation, $topicEntity); $this->logger->info('[Sandbox][App] Sandbox initialized successfully', [ 'sandbox_id' => $sandboxId, 'topic_id' => $topicId, ]); return $sandboxId; } /** * Rollback tospecifiedcheckpoint. * * @param string $sandboxId SandboxID * @param string $targetMessageId TargetMessageID * @return AgentResponse RollbackResponse*/ public function rollbackCheckpoint(string $sandboxId, string $targetMessageId): AgentResponse { $this->logger->info('[Sandbox][App] Rollback checkpoint requested', [ 'sandbox_id' => $sandboxId, 'target_message_id' => $targetMessageId, ]); // ExecuteSandboxRollback $response = $this->agentDomainService->rollbackCheckpoint($sandboxId, $targetMessageId); // SandboxRollbackFailed, RecordLogAndAdvanceReturn if (! $response->isSuccess()) { $this->logger->error('[Sandbox][App] Checkpoint rollback failed', [ 'sandbox_id' => $sandboxId, 'target_message_id' => $targetMessageId, 'code' => $response->getCode(), 'message' => $response->getMessage(), ]); // SandboxRollbackFailed,  not ExecuteMessageRollback $this->logger->info('[Sandbox][App] Skipping message rollback due to sandbox rollback failure', [ 'sandbox_id' => $sandboxId, 'target_message_id' => $targetMessageId, ]); return $response; } // SandboxRollbackSuccess, RecordLogAndExecuteMessageRollback $this->logger->info('[Sandbox][App] Checkpoint rollback successful', [ 'sandbox_id' => $sandboxId, 'target_message_id' => $targetMessageId, 'sandbox_response' => $response->getMessage(), ]); // ExecuteMessageRollback $this->topicDomainService->rollbackMessages($targetMessageId); $this->logger->info('[Sandbox][App] Message rollback completed successfully', [ 'sandbox_id' => $sandboxId, 'target_message_id' => $targetMessageId, ]); return $response; } /** * StartRollback tospecifiedcheckpoint (callSandboxgatewayAndMarkMessageStatus). * * @param DataIsolation $dataIsolation DataIsolationcontext * @param int $topicId TopicID * @param string $targetMessageId TargetMessageID * @return string OperationResultMessage*/ public function rollbackCheckpointStart(DataIsolation $dataIsolation, int $topicId, string $targetMessageId): string { $this->logger->info('[Sandbox][App] Rollback checkpoint start requested', [ 'topic_id' => $topicId, 'target_message_id' => $targetMessageId, ]); // ValidateTopic store inAnd belong toCurrentuser $topicEntity = $this->topicDomainService->getTopicById($topicId); if (is_Null($topicEntity)) { throw new BusinessException('Topic not found for ID: ' . $topicId); } if ($topicEntity->getUserId() !== $dataIsolation->getCurrentUserId()) { throw new BusinessException('Access denied for topic ID: ' . $topicId); } // EnsureSandbox already InitializeAndgetSandboxID $sandboxId = $this->ensureSandboxInitialized($dataIsolation, $topicId); // callSandboxgatewayStartRollback $sandboxResponse = $this->agentDomainService->rollbackCheckpointStart($sandboxId, $targetMessageId); if (! $sandboxResponse->isSuccess()) { $this->logger->error('[Sandbox][App] Sandbox rollback start failed', [ 'sandbox_id' => $sandboxId, 'target_message_id' => $targetMessageId, 'error' => $sandboxResponse->getMessage(), ]); throw new BusinessException('Sandbox rollback start failed: ' . $sandboxResponse->getMessage()); } // SandboxOperation successful after , ExecuteMessageStatusMark $this->topicDomainService->rollbackMessagesStart($targetMessageId); $this->logger->info('[Sandbox][App] Message rollback start completed successfully', [ 'topic_id' => $topicId, 'target_message_id' => $targetMessageId, 'sandbox_response' => $sandboxResponse->getMessage(), ]); return 'Sandbox and messages rollback started successfully'; } /** * SubmitRollback tospecifiedcheckpoint (callSandboxgatewayAndPhysicalDeleteWithdrawStatusMessage). * * @param DataIsolation $dataIsolation DataIsolationcontext * @param int $topicId TopicID * @return string OperationResultMessage*/ public function rollbackCheckpointCommit(DataIsolation $dataIsolation, int $topicId): string { $this->logger->info('[Sandbox][App] Rollback checkpoint commit requested', [ 'topic_id' => $topicId, ]); // ValidateTopic store inAnd belong toCurrentuser $topicEntity = $this->topicDomainService->getTopicById($topicId); if (is_Null($topicEntity)) { throw new BusinessException('Topic not found for ID: ' . $topicId); } if ($topicEntity->getUserId() !== $dataIsolation->getCurrentUserId()) { throw new BusinessException('Access denied for topic ID: ' . $topicId); } // EnsureSandbox already InitializeAndgetSandboxID $sandboxId = $this->ensureSandboxInitialized($dataIsolation, $topicId); // callSandboxgatewaySubmitRollback $sandboxResponse = $this->agentDomainService->rollbackCheckpointCommit($sandboxId); if (! $sandboxResponse->isSuccess()) { $this->logger->error('[Sandbox][App] Sandbox rollback commit failed', [ 'sandbox_id' => $sandboxId, 'error' => $sandboxResponse->getMessage(), ]); throw new BusinessException('Sandbox rollback commit failed: ' . $sandboxResponse->getMessage()); } // SandboxOperation successful after , ExecutePhysicalDeleteWithdrawStatusMessage $this->topicDomainService->rollbackMessagesCommit($topicId, $dataIsolation->getCurrentUserId()); $this->logger->info('[Sandbox][App] Message rollback commit completed successfully', [ 'topic_id' => $topicId, 'sandbox_response' => $sandboxResponse->getMessage(), ]); return 'Sandbox and messages rollback committed successfully'; } /** * RevokeRollbackOperation (callSandboxgatewayAndConvertWithdrawStatusMessageRestore toNormalStatus). * * @param DataIsolation $dataIsolation DataIsolationcontext * @param int $topicId TopicID * @return string OperationResultMessage*/ public function rollbackCheckpointUndo(DataIsolation $dataIsolation, int $topicId): string { $this->logger->info('[Sandbox][App] Rollback checkpoint undo requested', [ 'topic_id' => $topicId, 'user_id' => $dataIsolation->getCurrentUserId(), ]); // ValidateTopic store inAnd belong toCurrentuser $topicEntity = $this->topicDomainService->getTopicById($topicId); if (is_Null($topicEntity)) { $this->logger->error('[Sandbox][App] Topic not found for undo', [ 'topic_id' => $topicId, 'user_id' => $dataIsolation->getCurrentUserId(), ]); throw new BusinessException('Topic not found for ID: ' . $topicId); } if ($topicEntity->getUserId() !== $dataIsolation->getCurrentUserId()) { $this->logger->error('[Sandbox][App] Access denied for topic undo', [ 'topic_id' => $topicId, 'topic_user_id' => $topicEntity->getUserId(), 'current_user_id' => $dataIsolation->getCurrentUserId(), ]); throw new BusinessException('Access denied for topic ID: ' . $topicId); } // EnsureSandbox already InitializeAndgetSandboxID $sandboxId = $this->ensureSandboxInitialized($dataIsolation, $topicId); // callSandboxgatewayRevokeRollback $sandboxResponse = $this->agentDomainService->rollbackCheckpointUndo($sandboxId); if (! $sandboxResponse->isSuccess()) { $this->logger->error('[Sandbox][App] Sandbox rollback undo failed', [ 'sandbox_id' => $sandboxId, 'error' => $sandboxResponse->getMessage(), ]); throw new BusinessException('Sandbox rollback undo failed: ' . $sandboxResponse->getMessage()); } // SandboxOperation successful after , ExecuteMessageWithdrawRevokeOperation (Restore toNormalStatus) $this->topicDomainService->rollbackMessagesUndo($topicId, $dataIsolation->getCurrentUserId()); $this->logger->info('[Sandbox][App] Message rollback undo completed successfully', [ 'topic_id' => $topicId, 'user_id' => $dataIsolation->getCurrentUserId(), 'sandbox_response' => $sandboxResponse->getMessage(), ]); return 'Sandbox and messages rollback undone successfully'; } /** * CheckRollback tospecifiedcheckpointcanRowproperty. * * @param DataIsolation $dataIsolation DataIsolationcontext * @param int $topicId TopicID * @param string $targetMessageId TargetMessageID * @return AgentResponse CheckResultResponse*/ public function rollbackCheckpointCheck(DataIsolation $dataIsolation, int $topicId, string $targetMessageId): AgentResponse { $this->logger->info('[Sandbox][App] Rollback checkpoint check requested', [ 'topic_id' => $topicId, 'target_message_id' => $targetMessageId, ]); // ValidateTopic store inAnd belong toCurrentuser $topicEntity = $this->topicDomainService->getTopicById($topicId); if (is_Null($topicEntity)) { $this->logger->error('[Sandbox][App] Topic not found for rollback check', [ 'topic_id' => $topicId, 'user_id' => $dataIsolation->getCurrentUserId(), ]); throw new BusinessException('Topic not found for ID: ' . $topicId); } if ($topicEntity->getUserId() !== $dataIsolation->getCurrentUserId()) { $this->logger->error('[Sandbox][App] Access denied for topic rollback check', [ 'topic_id' => $topicId, 'topic_user_id' => $topicEntity->getUserId(), 'current_user_id' => $dataIsolation->getCurrentUserId(), ]); throw new BusinessException('Access denied for topic ID: ' . $topicId); } // EnsureSandbox already InitializeAndgetSandboxID $sandboxId = $this->ensureSandboxInitialized($dataIsolation, $topicId); // callDomainServiceCheckRollbackcanRowproperty $response = $this->agentDomainService->rollbackCheckpointCheck($sandboxId, $targetMessageId); // RecordCheckResult if ($response->isSuccess()) { $this->logger->info('[Sandbox][App] Checkpoint rollback check completed successfully', [ 'topic_id' => $topicId, 'target_message_id' => $targetMessageId, 'can_rollback' => $response->getDataValue('can_rollback'), ]); } else { $this->logger->warning('[Sandbox][App] Checkpoint rollback check failed', [ 'topic_id' => $topicId, 'target_message_id' => $targetMessageId, 'error' => $response->getMessage(), ]); } return $response; } /** * Upgrade sandbox image. * * @param DataIsolation $dataIsolation DataIsolationcontext * @param string $messageId MessageID * @param string $contextType contextType, defaultForcontinue * @return AgentResponse UpgradeResponseResult * @throws BusinessException whenUpgradeFailedThrow whenAbnormal*/ public function upgradeSandbox( DataIsolation $dataIsolation, string $messageId, string $contextType = 'continue' ): AgentResponse { $this->logger->info('[Sandbox][App] Upgrading sandbox image', [ 'message_id' => $messageId, 'context_type' => $contextType, 'user_id' => $dataIsolation->getCurrentUserId(), 'organization_code' => $dataIsolation->getCurrentOrganizationCode(), ]); try { // callDomainServiceExecuteUpgrade $response = $this->agentDomainService->upgradeSandbox($messageId, $contextType); $this->logger->info('[Sandbox][App] Sandbox upgrade completed successfully', [ 'message_id' => $messageId, 'context_type' => $contextType, 'user_id' => $dataIsolation->getCurrentUserId(), ]); return $response; } catch (SandboxOperationException $e) { $this->logger->error('[Sandbox][App] Sandbox upgrade failed', [ 'message_id' => $messageId, 'context_type' => $contextType, 'user_id' => $dataIsolation->getCurrentUserId(), 'error' => $e->getMessage(), 'code' => $e->getCode(), ]); throw new BusinessException('Sandbox upgrade failed: ' . $e->getMessage()); } catch (Throwable $e) { $this->logger->error('[Sandbox][App] Unexpected error during sandbox upgrade', [ 'message_id' => $messageId, 'context_type' => $contextType, 'user_id' => $dataIsolation->getCurrentUserId(), 'error' => $e->getMessage(), ]); throw new BusinessException('Unexpected error during sandbox upgrade: ' . $e->getMessage()); } } /** * CreateAndInitializeSandbox. * * @param DataIsolation $dataIsolation DataIsolationcontext * @param TopicEntity $topicEntity TopicEntity * @return string SandboxID*/ private function createAndInitializeSandbox(DataIsolation $dataIsolation, TopicEntity $topicEntity): string { // getCompleteworkDirectoryPath $fullPrefix = $this->taskFileDomainService->getFullPrefix($dataIsolation->getCurrentOrganizationCode()); $fullWorkdir = WorkDirectoryUtil::getFullWorkdir($fullPrefix, $topicEntity->getWorkDir() ?? ''); $sandboxId = $topicEntity->getSandboxId(); // CreateSandboxContainer $sandboxId = $this->agentDomainService->createSandbox( $dataIsolation, (string) $topicEntity->getProjectId(), $sandboxId, $fullWorkdir ); // CreateTaskEntity, Make full useTopicEntityData $taskEntity = new TaskEntity(); $taskEntity->setTopicId($topicEntity->getId()); $taskEntity->setProjectId($topicEntity->getProjectId()); $taskEntity->setWorkspaceId($topicEntity->getWorkspaceId()); $taskEntity->setSandboxId($sandboxId); $taskEntity->setWorkDir($topicEntity->getWorkDir() ?? ''); $taskEntity->setUserId($topicEntity->getUserId()); $taskEntity->setTaskMode($topicEntity->getTaskMode()); // IfTopicEntity have CurrentTaskID, alsoset to TaskEntity if ($topicEntity->getCurrentTaskId()) { $taskEntity->setId($topicEntity->getCurrentTaskId()); $taskEntity->setTaskId((string) $topicEntity->getCurrentTaskId()); } // CreateTaskContext, Make full useTopicEntityAllRelatedData $taskContext = new TaskContext( task: $taskEntity, dataIsolation: $dataIsolation, chatConversationId: $topicEntity->getChatConversationId(), chatTopicId: $topicEntity->getChatTopicId(), agentUserId: $topicEntity->getCreatedUid() ?: $topicEntity->getUserId(), // UseCreatorID or UserID sandboxId: $sandboxId, taskId: $topicEntity->getCurrentTaskId() ? (string) $topicEntity->getCurrentTaskId() : '', instruction: ChatInstruction::Normal, agentMode: $topicEntity->getTopicMode() ?: 'general', workspaceId: (string) $topicEntity->getWorkspaceId(), ); $projectEntity = $this->projectDomainService->getProjectNotUserId($topicEntity->getProjectId()); // InitializeAgent $this->agentDomainService->initializeAgent($dataIsolation, $taskContext, projectOrganizationCode: $projectEntity->getUserOrganizationCode()); // WaitWorkspaceReady $this->waitForWorkspaceReady($sandboxId, 60, 2); return $sandboxId; } } 