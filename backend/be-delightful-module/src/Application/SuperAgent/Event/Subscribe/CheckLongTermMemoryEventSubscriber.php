<?php declare(strict_types=1); /** * Copyright (c) Be Delightful , Distributed under the MIT software license */ namespace Delightful\SuperMagic\Application\SuperAgent\Event\Subscribe; use App\Application\Chat\Service\MagicChatMessageAppService; use App\Application\LongTermMemory\DTO\EvaluateConversationRequestDTO; use App\Application\LongTermMemory\Enum\AppCodeEnum; use App\Application\LongTermMemory\Service\LongTermMemoryAppService as MagicServiceLongTermMemoryAppService; use App\Application\ModelGateway\Service\ModelConfigAppService; use App\Domain\Chat\Entity\ValueObject\LLMModelEnum; use App\Interfaces\Authorization\Web\MagicUserAuthorization; use Delightful\SuperMagic\Domain\SuperAgent\Event\CheckLongTermMemoryEvent; use Hyperf\Event\Contract\ListenerInterface; use Hyperf\Logger\LoggerFactory; use Psr\Log\LoggerInterface; use Throwable; /** * Long-term memoryCheckEventListendevice * ResponsibleProcess/HandleLong-term memoryCheckEventSpecificLogic.*/ class CheckLongTermMemoryEventSubscriber implements ListenerInterface { /** * Listen to events. * * @return array Array of event classes to listen to */ public function listen(): array { return [ CheckLongTermMemoryEvent::class, ]; } /** * Process the event. * * @param object $event Event object */ public function process(object $event): void { // Type check if (! $event instanceof CheckLongTermMemoryEvent) { return; } try { $this->getLogger()->info('StartProcess/HandleLong-term memoryCheckEvent', [ 'event_id' => $event->getEventId(), 'organization_code' => $event->getOrganizationCode(), 'user_id' => $event->getUserId(), 'conversation_id' => $event->getConversationId(), 'chat_topic_id' => $event->getChatTopicId(), 'prompt_length' => mb_strlen($event->getPrompt()), 'has_attachments' => ! empty($event->getAttachments()), 'instructions_count' => count($event->getInstructions()), ]); // directlyfromEventget from conversationId $conversationId = $event->getConversationId(); if (empty($conversationId)) { $this->getLogger()->warning('Event in  conversation_id ForEmpty', [ 'chat_topic_id' => $event->getChatTopicId(), 'event_id' => $event->getEventId(), ]); return; } // BuildauthorizationObject $authorization = $this->createUserAuthorization($event->getOrganizationCode(), $event->getUserId()); // gethistoryMessage $historyMessages = $this->getConversationHistory($authorization, $conversationId, $event->getChatTopicId()); // BuildCompletePairspeakContent $conversationContent = $this->buildConversationContentWithHistory($event, $historyMessages); // throughDowngradechaingetModelName $modelName = di(ModelConfigAppService::class)->getChatModelTypeByFallbackChain( $event->getOrganizationCode(), LLMModelEnum::DEEPSEEK_V3->value ); // CreateevaluateRequestDTO $dto = new EvaluateConversationRequestDTO([ 'modelName' => $modelName, 'conversationContent' => $conversationContent, 'appId' => AppCodeEnum::SUPER_DELIGHTFUL->value, ]); // call magic-service Long-term memoryevaluateService $this->getLongTermMemoryApp()->evaluateAndCreateMemory($dto, $authorization); } catch (Throwable $e) { $this->getLogger()->error('Process/HandleLong-term memoryCheckEvent time happenAbnormal', [ 'event_id' => $event->getEventId(), 'error' => $e->getMessage(), 'organization_code' => $event->getOrganizationCode(), 'user_id' => $event->getUserId(), 'conversation_id' => $event->getConversationId(), 'chat_topic_id' => $event->getChatTopicId(), 'trace' => $e->getTraceAsString(), ]); } } /** * getLong-term memoryApplicationService*/ private function getLongTermMemoryApp(): MagicServiceLongTermMemoryAppService { return \Hyperf\Support\make(MagicServiceLongTermMemoryAppService::class); } /** * getChatMessageApplicationService*/ private function getMagicChatMessageApp(): MagicChatMessageAppService { return \Hyperf\Support\make(MagicChatMessageAppService::class); } /** * getLogdevice.*/ private function getLogger(): LoggerInterface { return \Hyperf\Support\make(LoggerFactory::class)->get(static::class); } /** * CreateuserauthorizationObject*/ private function createUserAuthorization(string $organizationCode, string $userId): MagicUserAuthorization { $authorization = new MagicUserAuthorization(); $authorization->setId($userId); $authorization->setOrganizationCode($organizationCode); $authorization->setApplicationCode(AppCodeEnum::SUPER_DELIGHTFUL->value); return $authorization; } /** * getSessionhistoryMessage.*/ private function getConversationHistory(MagicUserAuthorization $authorization, string $conversationId, string $topicId): array { try { return $this->getMagicChatMessageApp()->getConversationChatCompletionsHistory( $authorization, $conversationId, 50, // GetRecent50conditionMessage $topicId, false // UseTraditional role Format（user/assistant）andNotUserNickname ); } catch (Throwable $e) { $this->getLogger()->error('GetSessionHistoryMessageFailed', [ 'conversation_id' => $conversationId, 'topic_id' => $topicId, 'error' => $e->getMessage(), ]); return []; } } /** * BuildcontaininghistoryMessagePairspeakContent.*/ private function buildConversationContentWithHistory(CheckLongTermMemoryEvent $event, array $historyMessages): string { $content = []; // addhistoryMessage if (! empty($historyMessages)) { $content[] = '=== HistoryConversation ==='; foreach ($historyMessages as $message) { if (is_array($message) && isset($message['role'], $message['content'])) { $content[] = $message['role'] . ': ' . $message['content']; } } $content[] = "=== HistoryConversationEnd ===\n"; } // addCurrentuserMessage $content[] = '=== CurrentMessage ==='; $content[] = "UserMessage: {$event->getPrompt()}"; // addMentioninformation (If have ) if (! empty($event->getMentions())) { $mentionsData = json_decode($event->getMentions(), true); if (is_array($mentionsData) && ! empty($mentionsData)) { $content[] = 'Mention: ' . json_encode($mentionsData, JSON_UNESCAPED_UNICODE); } } return implode("\n", $content); } } 