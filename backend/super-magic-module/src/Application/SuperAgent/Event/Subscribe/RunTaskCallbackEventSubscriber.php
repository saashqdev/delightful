<?php declare(strict_types=1); /** * Copyright (c) Be Delightful , Distributed under the MIT software license */ namespace Delightful\SuperMagic\Application\SuperAgent\Event\Subscribe; use App\Domain\Chat\Entity\ValueObject\SocketEventType; use App\Domain\Contact\Service\MagicUserDomainService; use App\Infrastructure\Util\SocketIO\SocketIOUtil; use Dtyq\AsyncEvent\Kernel\Annotation\AsyncListener; use Dtyq\SuperMagic\Domain\SuperAgent\Entity\ValueObject\ProjectMode; use Dtyq\SuperMagic\Domain\SuperAgent\Entity\ValueObject\TaskStatus; use Dtyq\SuperMagic\Domain\SuperAgent\Event\RunTaskCallbackEvent; use Dtyq\SuperMagic\Domain\SuperAgent\Repository\Facade\TaskMessageRepositoryInterface; use Dtyq\SuperMagic\Domain\SuperAgent\Service\ProjectDomainService; use Dtyq\SuperMagic\Domain\SuperAgent\Service\TopicDomainService; use Dtyq\SuperMagic\Domain\SuperAgent\Service\WorkspaceDomainService; use Hyperf\Codec\Json; use Hyperf\Event\Annotation\Listener; use Hyperf\Event\Contract\ListenerInterface; use Hyperf\Logger\LoggerFactory; use Psr\Log\LoggerInterface; use Throwable; /** * RunTaskCallbackEventEventListendevice - RecordingSummaryCompletedetect.*/ #[AsyncListener] #[Listener] class RunTaskCallbackEventSubscriber implements ListenerInterface { private LoggerInterface $logger; public function __construct( LoggerFactory $loggerFactory ) { $this->logger = $loggerFactory->get(static::class); } /** * Listen to events. * * @return array Array of event classes to listen to */ public function listen(): array { return [ RunTaskCallbackEvent::class, ]; } /** * Process the event. * * @param object $event Event object */ public function process(object $event): void { // Type check if (! $event instanceof RunTaskCallbackEvent) { return; } // Check recording summary completion $this->checkRecordingSummaryCompletion($event); } /** * Check recording summary completion and send notification. * detectRecordingSummarywhetherComplete, IfComplete then PushNotification.*/ private function checkRecordingSummaryCompletion(RunTaskCallbackEvent $event): void { try { // 1. CheckTaskStatus $status = $event->getTaskMessage()->getPayload()->getStatus(); $taskStatus = TaskStatus::tryFrom($status); if ($taskStatus === Null) { $this->logger->warning('checkRecordingSummary Task status not found for recording summary check', [ 'task_id' => $event->getTaskId(), 'topic_id' => $event->getTopicId(), 'status' => $status, ]); return; } // CheckTaskStatuswhetherFor ERROR  or  FINISHED if ($taskStatus !== TaskStatus::ERROR && $taskStatus !== TaskStatus::FINISHED) { return; } // 2. QuerythisTaskuserMessage, Checkwhether have  summary_task Mark // Use topicId + taskId + sender_type Query, UtilizeIndexAnd only ReturnuserMessage $taskMessageRepository = di(TaskMessageRepositoryInterface::class); $userMessages = $taskMessageRepository->findUserMessagesByTopicIdAndTaskId($event->getTopicId(), (string) $event->getTaskId()); $hasSummaryTask = false; foreach ($userMessages as $message) { $rawContent = $message->getRawContent(); if (! empty($rawContent)) { // raw_content directlystoredthen is  dynamic_params JSON $dynamicParams = Json::decode($rawContent); if (isset($dynamicParams['summary_task']) && $dynamicParams['summary_task'] === true) { $hasSummaryTask = true; $this->logger->info('checkRecordingSummary Found summary_task marker', [ 'task_id' => $event->getTaskId(), 'topic_id' => $event->getTopicId(), ]); break; } } } // 3. IfNo/None summary_task Mark, Then notPushNotification if (! $hasSummaryTask) { $this->logger->info('checkRecordingSummary No summary_task marker found, skipping notification', [ 'task_id' => $event->getTaskId(), 'topic_id' => $event->getTopicId(), ]); return; } // 4. getTopicinformationAndCheckMode (doubleweightguarantee) $topicDomainService = di(TopicDomainService::class); $topicEntity = $topicDomainService->getTopicById($event->getTopicId()); if ($topicEntity === Null) { $this->logger->warning('checkRecordingSummary Topic not found for recording summary check', [ 'topic_id' => $event->getTopicId(), 'task_id' => $event->getTaskId(), ]); return; } // CheckTopicModewhetherFor summary if ($topicEntity->getTopicMode() !== ProjectMode::SUMMARY->value) { return; } // 5. getuserinformationAndPushNotification $userId = $event->getUserId(); $magicUserDomainService = di(MagicUserDomainService::class); $userEntity = $magicUserDomainService->getUserById($userId); if ($userEntity === Null) { $this->logger->warning('checkRecordingSummary User not found for recording summary notification', [ 'user_id' => $userId, 'task_id' => $event->getTaskId(), 'topic_id' => $event->getTopicId(), ]); return; } // throughDomainServiceQueryProjectAndWorkspaceName (Can onlyDependency domain/app layer) $projectName = ''; $workspaceName = ''; try { $projectDomainService = di(ProjectDomainService::class); $projectEntity = $projectDomainService->getProjectNotUserId($topicEntity->getProjectId()); $projectName = $projectEntity?->getProjectName() ?? ''; $workspaceDomainService = di(WorkspaceDomainService::class); $workspace = $workspaceDomainService->getWorkspaceDetail($topicEntity->getWorkspaceId()); $workspaceName = $workspace?->getName() ?? ''; } catch (Throwable $e) { $this->logger->warning('checkRecordingSummary fetch project/workspace name failed', [ 'topic_id' => $event->getTopicId(), 'project_id' => $topicEntity->getProjectId(), 'workspace_id' => $topicEntity->getWorkspaceId(), 'error' => $e->getMessage(), ]); } // PreparePushData $pushData = [ 'type' => 'recording_summary_result', 'recording_summary_result' => [ 'workspace_id' => (string) $topicEntity->getWorkspaceId(), 'workspace_name' => $workspaceName, 'project_id' => (string) $topicEntity->getProjectId(), 'project_name' => $projectName, 'topic_id' => (string) $topicEntity->getId(), 'organization_code' => $event->getOrganizationCode(), 'success' => $taskStatus === TaskStatus::FINISHED, 'timestamp' => time(), ], ]; // PushMessage give Client SocketIOUtil::sendIntermediate( SocketEventType::Intermediate, $userEntity->getMagicId(), $pushData ); $this->logger->info('checkRecordingSummary RecordingSummaryCompleteNotificationAlreadyPush', [ 'user_id' => $userId, 'magic_id' => $userEntity->getMagicId(), 'topic_id' => $topicEntity->getId(), 'task_id' => $event->getTaskId(), 'status' => $taskStatus->value, 'success' => $taskStatus === TaskStatus::FINISHED, ]); } catch (Throwable $e) { $this->logger->error('checkRecordingSummary Failed to send recording summary completion notification', [ 'task_id' => $event->getTaskId(), 'topic_id' => $event->getTopicId(), 'user_id' => $event->getUserId(), 'error' => $e->getMessage(), 'trace' => $e->getTraceAsString(), ]); } } } 