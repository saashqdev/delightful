<?php declare(strict_types=1); /** * Copyright (c) Be Delightful , Distributed under the MIT software license */ namespace Delightful\BeDelightful\Infrastructure\Utils; use Delightful\BeDelightful\Domain\BeAgent\Entity\ValueObject\TaskStatus; /** * TaskStatusValidateToolClass. * * ProvideStatusConvertRuleValidate, preventMessageCaused by disorderStatuscompetitionissue * * StatusCategory: * - WaitStatus: WAITING - Can transition to anyStatus * - ActiveStatus: RUNNING - Can only transition to final or suspended state * - RecoverableStatus: Suspended - Can only transition to WAITING  or Final state * - Final stateStatus: FINISHED, ERROR, Stopped - Can transition to WAITING  or OtherFinal state*/ class TaskStatusValidator { /** * ValidateStatusConvertwhetherAllow. * * @param Null|TaskStatus $currentStatus CurrentStatus * @param TaskStatus $newStatus  new Status * @return bool whetherAllow conversion*/ public static function isTransitionAllowed(?TaskStatus $currentStatus, TaskStatus $newStatus): bool { // IfUnablegetCurrentStatus, Allow conversion if ($currentStatus === Null) { return true; } // SameStatus, Allow (powerwaitOperation) if ($currentStatus === $newStatus) { return true; } // ApplicationStatusConvertRule return self::applyTransitionRules($currentStatus, $newStatus); } /** * getStatusTypeDescription. * * @param TaskStatus $status Status * @return string StatusType*/ public static function getStatusType(TaskStatus $status): string { if (self::isWaitingStatus($status)) { return 'waiting'; } if (self::isActiveStatus($status)) { return 'active'; } if (self::isFinalStatus($status)) { return 'final'; } if ($status === TaskStatus::Suspended) { return 'suspended'; } return 'unknown'; } /** * getRejectedConvertoriginalbecause. * * @param TaskStatus $currentStatus CurrentStatus * @param TaskStatus $newStatus  new Status * @return string Rejectedoriginalbecause*/ public static function getRejectReason(TaskStatus $currentStatus, TaskStatus $newStatus): string { if ($currentStatus === TaskStatus::RUNNING && $newStatus === TaskStatus::WAITING) { return 'Run in TaskCannotReturn toWaitStatus'; } if ($currentStatus === TaskStatus::RUNNING && ! self::isFinalStatus($newStatus) && $newStatus !== TaskStatus::Suspended) { return 'Run in TaskCan only transition to final stateOrSuspendstate'; } if (self::isFinalStatus($currentStatus) && $newStatus === TaskStatus::RUNNING) { return 'Final stateTaskCannotdirectlyConvert toRunStatus'; } if (self::isFinalStatus($currentStatus) && $newStatus === TaskStatus::Suspended) { return 'Final stateTaskCannotConvert toSuspendStatus'; } if ($currentStatus === TaskStatus::Suspended && $newStatus === TaskStatus::RUNNING) { return 'SuspendTaskNeed first Convert toWaitStatusCan onlyExecute'; } if ($currentStatus === TaskStatus::Suspended && ! self::isFinalStatus($newStatus) && $newStatus !== TaskStatus::WAITING) { return 'SuspendTaskCan only convert toWaitStatusOrFinal state'; } return 'StatusConvertNot conform to businessRule'; } /** * getAllow next stepStatus * * @param TaskStatus $currentStatus CurrentStatus * @return TaskStatus[] Allow next stepStatuslist*/ public static function getAllowedNextStates(TaskStatus $currentStatus): array { $allowed = []; foreach (TaskStatus::cases() as $status) { if (self::isTransitionAllowed($currentStatus, $status)) { $allowed[] = $status; } } return $allowed; } /** * ValidateStatusConvertchainwhetherLegal. * * @param TaskStatus[] $statusChain StatusConvertchain * @return array ValidateResult ['valid' => bool, 'invalid_step' => int|Null, 'reason' => string]*/ public static function validateTransitionChain(array $statusChain): array { if (empty($statusChain)) { return ['valid' => true, 'invalid_step' => Null, 'reason' => '']; } $currentStatus = Null; foreach ($statusChain as $index => $status) { if (! $status instanceof TaskStatus) { return [ 'valid' => false, 'invalid_step' => $index, 'reason' => "Step {$index} containingInvalidStatusValue", ]; } if (! self::isTransitionAllowed($currentStatus, $status)) { $fromStatus = $currentStatus->value ?? 'Null'; return [ 'valid' => false, 'invalid_step' => $index, 'reason' => "Step {$index}: {$fromStatus} â†’ {$status->value} ConvertNot beAllow", ]; } $currentStatus = $status; } return ['valid' => true, 'invalid_step' => Null, 'reason' => '']; } /** * ApplicationStatusConvertRule. * * @param TaskStatus $currentStatus CurrentStatus * @param TaskStatus $newStatus  new Status * @return bool whetherAllow conversion*/ private static function applyTransitionRules(TaskStatus $currentStatus, TaskStatus $newStatus): bool { // Rule1: WaitstateCan transition to anyStatus if (self::isWaitingStatus($currentStatus)) { return true; } // Rule2: ActivestateCan only transition to final or suspended state if (self::isActiveStatus($currentStatus)) { return $newStatus === TaskStatus::Suspended || self::isFinalStatus($newStatus); } // Rule3: SuspendstateCan only transition to WAITING  or Final state if ($currentStatus === TaskStatus::Suspended) { return $newStatus === TaskStatus::WAITING || self::isFinalStatus($newStatus); } // Rule4: Final stateCan only transition to WAITING  or OtherFinal state if (self::isFinalStatus($currentStatus)) { return $newStatus === TaskStatus::WAITING || self::isFinalStatus($newStatus); } // defaultAllow (UnknownStatusCombine) return true; } /** * JudgewhetherForWaitStatus * * @param TaskStatus $status Status * @return bool whetherForWaitStatus*/ private static function isWaitingStatus(TaskStatus $status): bool { return $status === TaskStatus::WAITING; } /** * JudgewhetherFor activeStatus * * @param TaskStatus $status Status * @return bool whetherFor activeStatus*/ private static function isActiveStatus(TaskStatus $status): bool { return $status === TaskStatus::RUNNING; } /** * JudgewhetherFor final stateStatus * * @param TaskStatus $status Status * @return bool whetherFor final stateStatus*/ private static function isFinalStatus(TaskStatus $status): bool { return in_array($status, [ TaskStatus::FINISHED, TaskStatus::ERROR, TaskStatus::Stopped, ], true); } } 
