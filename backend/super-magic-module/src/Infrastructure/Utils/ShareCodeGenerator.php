<?php declare(strict_types=1); /** * Copyright (c) Be Delightful , Distributed under the software license */ namespace Dtyq\SuperMagic\Infrastructure\Utils; use InvalidArgumentException; /** * share codeGeneratedeviceToolClass.*/ class ShareCodeGenerator { /** * share codeLength.*/ protected int $codeLength = 18; /** * Allowed charactersSet.*/ protected string $charset = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789'; /** *  most  after GenerateTimetimestampMicrosecondValue.*/ protected int $lastMicrotime = 0; /** * SameMicrosecondinnerSequence number .*/ protected int $sequence = 0; /** * GenerateAUniqueshare code * * Based onTimeTimestamp andSequence number GenerateUniqueCode, GuaranteeinDistribute style Environment in Uniqueproperty *  most finalGenerateClasssimilar "AB12XY89" formatfriendlyshare code * * @param string $prefix Optionalbeforesuffix, Used forBusiness distinction, defaultForEmpty * @return string Generateshare code*/ public function generate(string $prefix = ''): string { // getCurrentMicrosecondTimetimestamp $currentMicro = $this->getCurrentMicroseconds(); // Process/HandleSameMicrosecondinnerMultiple timescall if ($currentMicro === $this->lastMicrotime) { ++$this->sequence; } else { $this->sequence = 0; $this->lastMicrotime = $currentMicro; } // CombineUniqueDatasource $uniqueData = $currentMicro . $this->sequence; // addoneRandom kind subAddRandomproperty $randomSeed = random_int(1000, 9999); $uniqueData .= $randomSeed; // calculateHashValue $hash = md5($uniqueData); // ConvertHashConvert toshare codefriendlyformat $code = $this->hashToReadableCode($hash); // EnsureCodeLengthmatchwantrequire $code = substr($code, 0, $this->codeLength); // If have beforesuffix,  then addbeforesuffix if (! empty($prefix)) { $code = $prefix . $code; // EnsuretotalLengthStill comply $code = substr($code, 0, $this->codeLength); } return $code; } /** * GenerateMultipleUniqueshare code * * @param int $count NeedGenerateCodeQuantity * @param string $prefix Optionalbeforesuffix, Used forBusiness distinction, defaultForEmpty * @return array Generateshare codeArray*/ public function generateMultiple(int $count, string $prefix = ''): array { $codes = []; for ($i = 0; $i < $count; ++$i) { $codes[] = $this->generate($prefix); // EnsureTimeInterval, AddUniqueproperty if ($i < $count - 1) { usleep(1); // Hibernate1Microsecond } } return $codes; } /** * setshare codeLength. * * @param int $length CodeLength*/ public function setCodeLength(int $length): self { if ($length < 4) { throw new InvalidArgumentException('shareCodeLengthCannotsmallin4'); } $this->codeLength = $length; return $this; } /** * setCharacterSet. * * @param string $charset CharacterSet*/ public function setCharset(string $charset): self { if (empty($charset)) { throw new InvalidArgumentException('CharacterSetCannot be empty'); } $this->charset = $charset; return $this; } /** * Validateshare codewhetherValid. * * @param string $code pendingValidateshare code * @return bool whetherValid*/ public function isValid(string $code): bool { if (empty($code) || strlen($code) !== $this->codeLength) { return false; } // CheckCodewhether only containingCharacterSetCharacters in for ($i = 0; $i < strlen($code); ++$i) { if (strpos($this->charset, $code[$i]) === false) { return false; } } return true; } /** * ConvertHashValueConvert toeasyreadshare code * * @param string $hash HashValue * @return string friendlyformatshare code*/ protected function hashToReadableCode(string $hash): string { $result = ''; $charsetLength = strlen($this->charset); // ConvertHashValueGroupProcess/Handle, everygroup4bit for ($i = 0; $i < strlen($hash); $i += 2) { // fromHashExtract from2Character, Convert to16 enter make count Value $hexVal = hexdec(substr($hash, $i, 2)); // MappingTo characterSetrange $index = $hexVal % $charsetLength; $result .= $this->charset[$index]; // reach to TargetLength then Stop if (strlen($result) >= $this->codeLength) { break; } } return $result; } /** * getCurrentMicrosecondTimetimestamp. * * @return int MicrosecondTimetimestamp*/ protected function getCurrentMicroseconds(): int { // getMicrosecondlevelTimetimestamp $microtime = microtime(true); // Convert toInteger, Multiply1000000To get microsecond precision return (int) ($microtime * 1000000); } } 