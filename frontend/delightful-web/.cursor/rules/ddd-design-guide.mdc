---
description: 
globs: 
alwaysApply: false
---
@rule DDD Domain-Driven Design Guide - Revised Edition
@description Project domain analysis and DDD development standards (adjusted based on actual project structure)
@priority high
@category architecture

# DDD Domain-Driven Design Guide (Revised Edition)

## Current Project Structure Analysis

By analyzing the current project structure, we found that the project uses the following organizational approach:

```
src/
├── apis/                  # API interface definitions
│   ├── modules/           # APIs organized by business modules
│   ├── clients/           # API client implementation
│   └── ...
├── components/            # Shared UI components
├── hooks/                 # Custom React Hooks
├── layouts/               # Page layout components
├── models/                # Data model definitions
│   └── user/              # User-related models
├── pages/                 # Page components
├── services/              # Service layer implementation
│   └── user/              # User-related services
├── stores/                # State management
│   ├── user/              # User state management
│   ├── approval/          # Approval workflow state management
│   ├── calendar/          # Calendar state management
│   └── ...
├── utils/                 # Utility functions
└── ...
```

## Domain Partitioning (Based on Current Structure)

Based on the existing project structure and business functionality, we can identify the following core domains:

1. **User Domain**
   - Existing implementation: `models/user`, `stores/user`, `services/user`
   - Responsibility: User account management, authentication and authorization, personal information maintenance

2. **Approval Domain**
   - Existing implementation: `stores/approval`
   - Responsibility: Approval workflow management, form processing, approval records

3. **Calendar Domain**
   - Existing implementation: `stores/calendar`
   - Responsibility: Schedule management, reminder settings, calendar view

4. **Drive Domain**
   - Existing implementation: `stores/drive`
   - Responsibility: File storage, file sharing, permission management

5. **Team Collaboration Domain**
   - Existing implementation: `stores/teamshare`
   - Responsibility: Team collaboration, resource sharing, member management

## Improvement Suggestions: DDD Architecture Adjustments

To better implement DDD, we recommend the following adjustments to the project structure:

### Adjusted Directory Structure

```
src/
├── domains/                 # Domain directory
│   ├── user/                # User domain
│   │   ├── models/          # Domain models (entities, value objects)
│   │   ├── repositories/    # Repository interfaces
│   │   ├── services/        # Domain services
│   │   └── events/          # Domain events
│   ├── approval/            # Approval domain
│   ├── calendar/            # Calendar domain
│   ├── drive/               # Drive domain
│   └── teamshare/           # Team collaboration domain
├── application/             # Application service layer
│   ├── user/                
│   ├── approval/
│   └── ...
├── infrastructure/          # Infrastructure layer
│   ├── api/                 # API implementation (moved from apis directory)
│   ├── storage/             # Storage implementation
│   └── persistence/         # Repository implementation
├── ui/                      # Presentation layer
│   ├── components/          # Shared components (moved from components directory)
│   ├── pages/               # Page components (moved from pages directory)
│   ├── hooks/               # Custom Hooks (moved from hooks directory)
│   └── stores/              # UI state management (refactored from stores directory)
```

## Current Structure vs DDD Mismatch Points

1. **Unclear Domain Models**
   - Current `models` directory has limited content and does not fully reflect domain entities and value objects
   - Recommendation: Enrich domain models and encapsulate business rules in models

2. **State Management Mixed with Domain Logic**
   - `stores` directly contain business logic, which does not comply with DDD separation of concerns principle
   - Recommendation: Move business logic to domain services, stores only responsible for UI state management

3. **Lack of Explicit Repository Layer**
   - No dedicated repository interfaces and implementations, data access logic scattered
   - Recommendation: Introduce repository pattern to separate domain models from data access

4. **Unclear Domain Boundaries**
   - Dependencies between domains are not clear
   - Recommendation: Clearly define domain boundaries and implement cross-domain communication through application services or domain events

## Migration Strategy

To smoothly transition to DDD architecture, we recommend adopting a gradual migration strategy:

1. **Preserve Existing Functionality**
   - First phase does not change existing functionality, focus on architecture adjustments
   - Write adapters to connect new and old code

2. **Gradual Domain Migration**
   - Start implementing DDD from a single domain (e.g., user domain)
   - Expand to other domains after success

3. **New Features Use DDD**
   - All new features adopt DDD architecture design
   - Ensure compatibility between new and old architecture

## Domain Object Design Example (Based on Current Project)

### User Domain Entity Example

```typescript
// domains/user/models/User.ts
export class User {
  private _id: string;
  private _nickname: string;
  private _avatar: string;
  private _phone: string;
  private _status: UserStatus;
  private _organizationCode: string;

  constructor(id: string, nickname: string, avatar: string, phone: string, status: UserStatus, organizationCode: string) {
    this._id = id;
    this._nickname = nickname;
    this._avatar = avatar;
    this._phone = phone;
    this._status = status;
    this._organizationCode = organizationCode;
  }

  // Property accessors
  get id(): string {
    return this._id;
  }

  get nickname(): string {
    return this._nickname;
  }

  // Domain behavior
  updateProfile(nickname: string, avatar: string): void {
    this._nickname = nickname;
    this._avatar = avatar;
  }

  deactivate(): void {
    this._status = UserStatus.INACTIVE;
  }

  activate(): void {
    this._status = UserStatus.ACTIVE;
  }

  // Business rules
  canAccessOrganization(orgCode: string): boolean {
    return this._organizationCode === orgCode;
  }
}
```

### Repository Interface Example

```typescript
// domains/user/repositories/UserRepository.ts
export interface UserRepository {
  findById(id: string): Promise<User | null>;
  findByPhone(phone: string): Promise<User | null>;
  save(user: User): Promise<void>;
  search(query: UserSearchCriteria): Promise<User[]>;
}
```

### Domain Service Example

```typescript
// domains/user/services/UserService.ts
export class UserService {
  constructor(
    private userRepository: UserRepository,
    private authService: AuthService
  ) {}

  async registerUser(dto: RegisterUserDto): Promise<Result<User>> {
    // Validate business rules
    if (await this.userRepository.findByPhone(dto.phone)) {
      return Result.fail('Phone number already registered');
    }

    // Create user entity
    const user = new User(
      generateId(),
      dto.nickname,
      dto.avatar,
      dto.phone,
      UserStatus.ACTIVE,
      dto.organizationCode
    );

    // Persist
    await this.userRepository.save(user);

    // Handle related behavior
    await this.authService.createUserCredentials(user.id, dto.password);

    return Result.ok(user);
  }
}
```

### Application Service Example

```typescript
// application/user/UserApplicationService.ts
export class UserApplicationService {
  constructor(
    private userService: UserService,
    private userRepository: UserRepository
  ) {}

  async registerUser(dto: RegisterUserDto): Promise<Result<UserDto>> {
    // Call domain service
    const result = await this.userService.registerUser(dto);
    
    if (result.isFailure) {
      return Result.fail(result.error);
    }
    
    // Convert to DTO for return
    const user = result.value;
    return Result.ok({
      id: user.id,
      nickname: user.nickname,
      avatar: user.avatar,
      phone: user.phone,
      // Other properties...
    });
  }
}
```

## Integration with Existing State Management

Integrate MobX state management with DDD:

```typescript
// ui/stores/user/userStore.ts
import { makeAutoObservable, runInAction } from 'mobx';
import { UserApplicationService } from '../../../application/user/UserApplicationService';
import { UserDto } from '../../../application/user/dtos/UserDto';

export class UserStore {
  currentUser: UserDto | null = null;
  loading = false;
  error: string | null = null;

  constructor(private userAppService: UserApplicationService) {
    makeAutoObservable(this);
  }

  async loadCurrentUser(): Promise<void> {
    this.loading = true;
    this.error = null;

    try {
      const result = await this.userAppService.getCurrentUser();
      runInAction(() => {
        if (result.isSuccess) {
          this.currentUser = result.value;
        } else {
          this.error = result.error;
        }
        this.loading = false;
      });
    } catch (error) {
      runInAction(() => {
        this.error = error instanceof Error ? error.message : 'Load failed';
        this.loading = false;
      });
    }
  }
}
```

## Best Practices Summary

Based on the actual project conditions, we recommend the following DDD implementation best practices:

1. **Incremental Improvement**
   - Do not attempt to refactor the entire application at once
   - Identify core domains and prioritize DDD implementation

2. **Maintain Backward Compatibility**
   - Ensure the new architecture can work with existing frontend components
   - Add adapter layer to connect new and old structures

3. **Focus on Domain Model Design**
   - Migrate business rules from stores to domain models and services
   - Clearly define boundaries of entities, value objects, and aggregates

4. **Utilize TypeScript Strong Typing**
   - Make full use of TypeScript type system
   - Define clear interfaces and types for domain objects

5. **Value Domain Events**
   - Use domain events to decouple between domains
   - Avoid direct dependencies between domains

## Progressive Implementation Roadmap

1. **Phase 1: Domain Identification and Partitioning**
   - Review existing business functionality and identify core domains
   - Define domain models and boundaries

2. **Phase 2: Build Infrastructure**
   - Design repository interfaces
   - Implement data mapping layer

3. **Phase 3: Domain Layer Implementation**
   - Implement domain entities and value objects
   - Develop domain services

4. **Phase 4: Application Layer Implementation**
   - Develop application services
   - Integrate frontend state management

5. **Phase 5: Gradual Migration**
   - Migrate existing functionality one by one to new architecture
   - Verify and adjust
