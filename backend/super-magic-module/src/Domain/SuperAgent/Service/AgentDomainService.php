<?php declare(strict_types=1); /** * Copyright (c) Be Delightful , Distributed under the MIT software license */ namespace Dtyq\SuperMagic\Domain\SuperAgent\Service; use App\Application\Chat\Service\MagicUserInfoAppService; use App\Application\File\Service\FileAppService; use App\Domain\Contact\Entity\ValueObject\DataIsolation; use App\Domain\File\Repository\Persistence\Facade\CloudFileRepositoryInterface; use App\Infrastructure\Core\ValueObject\StorageBucketType; use App\Infrastructure\Util\IdGenerator\IdGenerator; use App\Interfaces\Authorization\Web\MagicUserAuthorization; use Dtyq\SuperMagic\Domain\SuperAgent\Entity\ValueObject\DynamicConfig\DynamicConfigManager; use Dtyq\SuperMagic\Domain\SuperAgent\Entity\ValueObject\InitializationMetadataDTO; use Dtyq\SuperMagic\Domain\SuperAgent\Entity\ValueObject\MessageMetadata; use Dtyq\SuperMagic\Domain\SuperAgent\Entity\ValueObject\MessageType; use Dtyq\SuperMagic\Domain\SuperAgent\Entity\ValueObject\TaskContext; use Dtyq\SuperMagic\Domain\SuperAgent\Entity\ValueObject\UserInfoValueObject; use Dtyq\SuperMagic\Infrastructure\ExternalAPI\SandboxOS\Agent\Constant\WorkspaceStatus; use Dtyq\SuperMagic\Infrastructure\ExternalAPI\SandboxOS\Agent\Request\ChatMessageRequest; use Dtyq\SuperMagic\Infrastructure\ExternalAPI\SandboxOS\Agent\Request\CheckpointRollbackCheckRequest; use Dtyq\SuperMagic\Infrastructure\ExternalAPI\SandboxOS\Agent\Request\CheckpointRollbackCommitRequest; use Dtyq\SuperMagic\Infrastructure\ExternalAPI\SandboxOS\Agent\Request\CheckpointRollbackRequest; use Dtyq\SuperMagic\Infrastructure\ExternalAPI\SandboxOS\Agent\Request\CheckpointRollbackStartRequest; use Dtyq\SuperMagic\Infrastructure\ExternalAPI\SandboxOS\Agent\Request\CheckpointRollbackUndoRequest; use Dtyq\SuperMagic\Infrastructure\ExternalAPI\SandboxOS\Agent\Request\InitAgentRequest; use Dtyq\SuperMagic\Infrastructure\ExternalAPI\SandboxOS\Agent\Request\InterruptRequest; use Dtyq\SuperMagic\Infrastructure\ExternalAPI\SandboxOS\Agent\Response\AgentResponse; use Dtyq\SuperMagic\Infrastructure\ExternalAPI\SandboxOS\Agent\SandboxAgentInterface; use Dtyq\SuperMagic\Infrastructure\ExternalAPI\SandboxOS\Exception\SandboxOperationException; use Dtyq\SuperMagic\Infrastructure\ExternalAPI\SandboxOS\Gateway\Constant\ResponseCode; use Dtyq\SuperMagic\Infrastructure\ExternalAPI\SandboxOS\Gateway\Constant\SandboxStatus; use Dtyq\SuperMagic\Infrastructure\ExternalAPI\SandboxOS\Gateway\Result\BatchStatusResult; use Dtyq\SuperMagic\Infrastructure\ExternalAPI\SandboxOS\Gateway\Result\SandboxStatusResult; use Dtyq\SuperMagic\Infrastructure\ExternalAPI\SandboxOS\Gateway\SandboxGatewayInterface; use Dtyq\SuperMagic\Infrastructure\Utils\WorkDirectoryUtil; use Hyperf\Codec\Json; use Hyperf\Logger\LoggerFactory; use Psr\Log\LoggerInterface; use Throwable; use function Hyperf\Translation\trans; /** * AgentMessageApplicationService * Provide advancedAgentGeneral message Function, Including automaticInitializeAndStatusmanagement.*/ class AgentDomainService { private LoggerInterface $logger; public function __construct( LoggerFactory $loggerFactory, private SandboxGatewayInterface $gateway, private SandboxAgentInterface $agent, private readonly FileAppService $fileAppService, private readonly MagicUserInfoAppService $userInfoAppService, private readonly CloudFileRepositoryInterface $cloudFileRepository, private readonly DynamicConfigManager $dynamicConfigManager, ) { $this->logger = $loggerFactory->get('sandbox'); } /** * callSandboxgateway, CreateSandboxContainer, If sandboxId Does not existin, SystemwilldefaultCreate a each .*/ public function createSandbox(DataIsolation $dataIsolation, string $projectId, string $sandboxID, string $workDir): string { $this->logger->info('[Sandbox][App] Creating sandbox', [ 'project_id' => $projectId, 'sandbox_id' => $sandboxID, 'project_oss_path' => $workDir, ]); $this->gateway->setUserContext($dataIsolation->getCurrentUserId(), $dataIsolation->getCurrentOrganizationCode()); $result = $this->gateway->createSandbox($projectId, $sandboxID, $workDir); // adddetailedDebugLog, Check result Object $this->logger->info('[Sandbox][App] Gateway result analysis', [ 'result_class' => get_class($result), 'result_is_success' => $result->isSuccess(), 'result_code' => $result->getCode(), 'result_message' => $result->getMessage(), 'result_data_raw' => $result->getData(), 'result_data_type' => gettype($result->getData()), 'sandbox_id_via_getDataValue' => $result->getDataValue('sandbox_id'), 'sandbox_id_via_getData_direct' => $result->getData()['sandbox_id'] ?? 'KEY_NOT_FOUND', ]); if (! $result->isSuccess()) { $this->logger->error('[Sandbox][App] Failed to create sandbox', [ 'project_id' => $projectId, 'sandbox_id' => $sandboxID, 'error' => $result->getMessage(), 'code' => $result->getCode(), ]); throw new SandboxOperationException('Create sandbox', $result->getMessage(), $result->getCode()); } $this->logger->info('[Sandbox][App] Create sandbox success', [ 'project_id' => $projectId, 'input_sandbox_id' => $sandboxID, 'returned_sandbox_id' => $result->getDataValue('sandbox_id'), ]); return $result->getDataValue('sandbox_id'); } /** * getSandboxStatus * * @param string $sandboxId SandboxID * @return SandboxStatusResult SandboxStatusResult*/ public function getSandboxStatus(string $sandboxId): SandboxStatusResult { $this->logger->info('[Sandbox][App] Getting sandbox status', [ 'sandbox_id' => $sandboxId, ]); $result = $this->gateway->getSandboxStatus($sandboxId); if (! $result->isSuccess() && $result->getCode() !== ResponseCode::NOT_FOUND) { $this->logger->error('[Sandbox][App] Failed to get sandbox status', [ 'sandbox_id' => $sandboxId, 'error' => $result->getMessage(), 'code' => $result->getCode(), ]); // throw new SandboxOperationException('Get sandbox status', $result->getMessage(), $result->getCode()); } $this->logger->info('[Sandbox][App] Sandbox status retrieved', [ 'sandbox_id' => $sandboxId, 'status' => $result->getStatus(), ]); return $result; } /** * BatchgetSandboxStatus * * @param array $sandboxIds SandboxIDArray * @return BatchStatusResult BatchSandboxStatusResult*/ public function getBatchSandboxStatus(array $sandboxIds): BatchStatusResult { $this->logger->info('[Sandbox][App] Getting batch sandbox status', [ 'sandbox_ids' => $sandboxIds, 'count' => count($sandboxIds), ]); $result = $this->gateway->getBatchSandboxStatus($sandboxIds); if (! $result->isSuccess() && $result->getCode() !== ResponseCode::NOT_FOUND) { $this->logger->error('[Sandbox][App] Failed to get batch sandbox status', [ 'sandbox_ids' => $sandboxIds, 'error' => $result->getMessage(), 'code' => $result->getCode(), ]); throw new SandboxOperationException('Get batch sandbox status', $result->getMessage(), $result->getCode()); } $this->logger->info('[Sandbox][App] Batch sandbox status retrieved', [ 'requested_count' => count($sandboxIds), 'returned_count' => $result->getTotalCount(), 'running_count' => $result->getRunningCount(), ]); return $result; } /** * @param?string $projectOrganizationCode ProjectBelong toOrganization code, 10monthAdd newSupportcrossOrganizationProjectCollaboration, AllFileallinProjectOrganization next  * @param?InitializationMetadataDTO $initMetadata Initialize element Data DTO, Used forconfigurationInitializeRowFor*/ public function initializeAgent(DataIsolation $dataIsolation, TaskContext $taskContext, ?string $memory = Null, ?string $projectOrganizationCode = Null, ?InitializationMetadataDTO $initMetadata = Null): void { $initMetadata = $initMetadata ?? InitializationMetadataDTO::createDefault(); $this->logger->info('[Sandbox][App] Initializing agent', [ 'sandbox_id' => $taskContext->getSandboxId(), 'memory_provided' => $memory !== Null, 'memory_length' => $memory ? strlen($memory) : 0, 'project_organization_code' => $projectOrganizationCode, 'skip_init_messages' => $initMetadata->getSkipInitMessages(), ]); // 1. BuildInitializeinformation $config = $this->generateInitializationInfo($dataIsolation, $taskContext, $memory, projectOrganizationCode: $projectOrganizationCode, initMetadata: $initMetadata); // 2. callInitializeInterface $result = $this->agent->initAgent($taskContext->getSandboxId(), InitAgentRequest::fromArray($config)); if (! $result->isSuccess()) { $this->logger->error('[Sandbox][App] Failed to initialize agent', [ 'sandbox_id' => $taskContext->getSandboxId(), 'error' => $result->getMessage(), 'code' => $result->getCode(), ]); throw new SandboxOperationException('Initialize agent', $result->getMessage(), $result->getCode()); } } /** * SendMessage give  agent.*/ public function sendChatMessage(DataIsolation $dataIsolation, TaskContext $taskContext): void { $taskDynamicConfig = $taskContext->getDynamicConfig(); // addAnyRegister to  DynamicConfigManager Dynamicconfiguration. temp time through TaskId  enter Rowzone divide . $dynamicConfigs = $this->dynamicConfigManager->getByTaskId((string) $taskContext->getTask()->getId()); foreach ($dynamicConfigs as $key => $dynamicConfig) { $taskDynamicConfig[$key] = $dynamicConfig; } // Add image_model configuration if imageModelId exists $extra = $taskContext->getExtra(); if ($extra !== Null) { $imageModelId = $extra->getImageModelId(); if (! empty($imageModelId)) { $taskDynamicConfig['image_model'] = [ 'model_id' => $imageModelId, ]; } } $this->logger->info('[Sandbox][App] Sending chat message to agent', [ 'sandbox_id' => $taskContext->getSandboxId(), 'task_id' => $taskContext->getTask()->getId(), 'prompt' => $taskContext->getTask()->getPrompt(), 'task_mode' => $taskContext->getTask()->getTaskMode(), 'agent_mode' => $taskContext->getAgentMode(), 'mentions' => $taskContext->getTask()->getMentions(), 'mcp_config' => $taskContext->getMcpConfig(), 'model_id' => $taskContext->getModelId(), 'dynamic_config' => $taskDynamicConfig, ]); $mentionsJsonStruct = $this->buildMentionsJsonStruct($taskContext->getTask()->getMentions()); // Get original prompt $userRequest = $taskContext->getTask()->getPrompt(); // Get constraint text if needed $constraintText = $this->getPromptConstraint($taskContext); $prompt = $userRequest . $constraintText; // BuildParameter $chatMessage = ChatMessageRequest::create( messageId: $taskContext->getMessageId(), userId: $dataIsolation->getCurrentUserId(), taskId: (string) $taskContext->getTask()->getId(), prompt: $prompt, taskMode: $taskContext->getTask()->getTaskMode(), agentMode: $taskContext->getAgentMode(), mentions: $mentionsJsonStruct, mcpConfig: $taskContext->getMcpConfig(), modelId: $taskContext->getModelId(), dynamicConfig: $taskDynamicConfig, ); $result = $this->agent->sendChatMessage($taskContext->getSandboxId(), $chatMessage); if (! $result->isSuccess()) { $this->logger->error('[Sandbox][App] Failed to send chat message to agent', [ 'sandbox_id' => $taskContext->getSandboxId(), 'error' => $result->getMessage(), 'code' => $result->getCode(), ]); throw new SandboxOperationException('Send chat message', $result->getMessage(), $result->getCode()); } } /** * Send interruptMessage give Agent. * * @param DataIsolation $dataIsolation DataIsolationcontext * @param string $sandboxId SandboxID * @param string $taskId TaskID * @param string $reason Interruption reason * @return AgentResponse InterruptResponse*/ public function sendInterruptMessage( DataIsolation $dataIsolation, string $sandboxId, string $taskId, string $reason, ): AgentResponse { $this->logger->info('[Sandbox][App] Sending interrupt message to agent', [ 'sandbox_id' => $sandboxId, 'task_id' => $taskId, 'user_id' => $dataIsolation->getCurrentUserId(), 'reason' => $reason, ]); // Send interruptMessage $messageId = (string) IdGenerator::getSnowId(); $interruptRequest = InterruptRequest::create( $messageId, $dataIsolation->getCurrentUserId(), $taskId, $reason, ); $response = $this->agent->sendInterruptMessage($sandboxId, $interruptRequest); if (! $response->isSuccess()) { $this->logger->error('[Sandbox][App] Failed to send interrupt message to agent', [ 'sandbox_id' => $sandboxId, 'task_id' => $taskId, 'user_id' => $dataIsolation->getCurrentUserId(), 'reason' => $reason, 'error' => $response->getMessage(), 'code' => $response->getCode(), ]); throw new SandboxOperationException('Send interrupt message', $response->getMessage(), $response->getCode()); } $this->logger->info('[Sandbox][App] Interrupt message sent to agent successfully', [ 'sandbox_id' => $sandboxId, 'task_id' => $taskId, 'user_id' => $dataIsolation->getCurrentUserId(), 'reason' => $reason, ]); return $response; } /** * getWorkspaceStatus. * * @param string $sandboxId SandboxID * @return AgentResponse WorkspaceStatusResponse*/ public function getWorkspaceStatus(string $sandboxId): AgentResponse { $this->logger->debug('[Sandbox][App] Getting workspace status', [ 'sandbox_id' => $sandboxId, ]); $result = $this->agent->getWorkspaceStatus($sandboxId); if (! $result->isSuccess()) { $this->logger->error('[Sandbox][App] Failed to get workspace status', [ 'sandbox_id' => $sandboxId, 'error' => $result->getMessage(), 'code' => $result->getCode(), ]); throw new SandboxOperationException('Get workspace status', $result->getMessage(), $result->getCode()); } $this->logger->debug('[Sandbox][App] Workspace status retrieved', [ 'sandbox_id' => $sandboxId, 'status' => $result->getDataValue('status'), ]); return $result; } /** * WaitWorkspaceReady. * pollingWorkspaceStatus, direct to InitializeComplete、Failed or Timeout. * * @param string $sandboxId SandboxID * @param int $timeoutSeconds TimeoutTime ( seconds ), default2Minute * @param int $intervalSeconds pollingInterval ( seconds ), default2 seconds  * @throws SandboxOperationException whenInitializeFailed or TimeoutThrow whenAbnormal*/ public function waitForSandboxReady(string $sandboxId, int $timeoutSeconds = 120, int $intervalSeconds = 2): void { $this->logger->info('[Sandbox][App] Waiting for Sandbox to be ready', [ 'sandbox_id' => $sandboxId, 'timeout_seconds' => $timeoutSeconds, 'interval_seconds' => $intervalSeconds, ]); $startTime = time(); $endTime = $startTime + $timeoutSeconds; while (time() < $endTime) { try { $response = $this->getSandboxStatus($sandboxId); $status = $response->getStatus(); $this->logger->debug('[Sandbox][App] Sandbox status check', [ 'sandbox_id' => $sandboxId, 'status' => $status, 'elapsed_seconds' => time() - $startTime, ]); // StatusExit when ready if ($status === SandboxStatus::RUNNING) { $this->logger->info('[Sandbox][App] Sandbox is ready', [ 'sandbox_id' => $sandboxId, 'elapsed_seconds' => time() - $startTime, ]); return; } // WaitNext polling sleep($intervalSeconds); } catch (SandboxOperationException $e) { //  re ThrowSandboxOperationAbnormal throw $e; } catch (Throwable $e) { $this->logger->error('[Sandbox][App] Error while checking sandbox status', [ 'sandbox_id' => $sandboxId, 'error' => $e->getMessage(), 'elapsed_seconds' => time() - $startTime, ]); throw new SandboxOperationException('Wait for sandbox ready', 'Error checking sandbox status: ' . $e->getMessage(), 3002); } } } /** * WaitWorkspaceReady. * pollingWorkspaceStatus, direct to InitializeComplete、Failed or Timeout. * * @param string $sandboxId SandboxID * @param int $timeoutSeconds TimeoutTime ( seconds ), default5Minute * @param float $intervalSeconds pollingInterval ( seconds ), default500ms * @throws SandboxOperationException whenInitializeFailed or TimeoutThrow whenAbnormal*/ public function waitForWorkspaceReady(string $sandboxId, int $timeoutSeconds = 300, float $intervalSeconds = 0.5): void { $this->logger->info('[Sandbox][App] Waiting for workspace to be ready', [ 'sandbox_id' => $sandboxId, 'timeout_seconds' => $timeoutSeconds, 'interval_seconds' => $intervalSeconds, ]); $startTime = time(); $endTime = $startTime + $timeoutSeconds; while (time() < $endTime) { try { $response = $this->getWorkspaceStatus($sandboxId); $status = $response->getDataValue('status'); $this->logger->debug('[Sandbox][App] Workspace status check', [ 'sandbox_id' => $sandboxId, 'status' => $status, 'status_description' => WorkspaceStatus::getDescription($status), 'elapsed_seconds' => time() - $startTime, ]); // StatusExit when ready if (WorkspaceStatus::isReady($status)) { $this->logger->info('[Sandbox][App] Workspace is ready', [ 'sandbox_id' => $sandboxId, 'elapsed_seconds' => time() - $startTime, ]); return; } // StatusForErrorThrow whenAbnormal if (WorkspaceStatus::isError($status)) { $this->logger->error('[Sandbox][App] Workspace initialization failed', [ 'sandbox_id' => $sandboxId, 'status' => $status, 'status_description' => WorkspaceStatus::getDescription($status), 'elapsed_seconds' => time() - $startTime, ]); throw new SandboxOperationException('Wait for workspace ready', 'Workspace initialization failed with status: ' . WorkspaceStatus::getDescription($status), 3001); } // WaitNext polling usleep((int) ($intervalSeconds * 1000000)); // Convert toMicrosecond } catch (SandboxOperationException $e) { //  re ThrowSandboxOperationAbnormal throw $e; } catch (Throwable $e) { $this->logger->error('[Sandbox][App] Error while checking workspace status', [ 'sandbox_id' => $sandboxId, 'error' => $e->getMessage(), 'elapsed_seconds' => time() - $startTime, ]); throw new SandboxOperationException('Wait for workspace ready', 'Error checking workspace status: ' . $e->getMessage(), 3002); } } // Timeout $this->logger->error('[Sandbox][App] Workspace ready timeout', [ 'sandbox_id' => $sandboxId, 'timeout_seconds' => $timeoutSeconds, ]); throw new SandboxOperationException('Wait for workspace ready', 'Workspace ready timeout after ' . $timeoutSeconds . ' seconds', 3003); } /** * Rollback tospecifiedcheckpoint. * * @param string $sandboxId SandboxID * @param string $targetMessageId TargetMessageID * @return AgentResponse RollbackResponse*/ public function rollbackCheckpoint(string $sandboxId, string $targetMessageId): AgentResponse { $this->logger->info('[Sandbox][Domain] Rolling back to checkpoint', [ 'sandbox_id' => $sandboxId, 'target_message_id' => $targetMessageId, ]); try { $request = CheckpointRollbackRequest::create($targetMessageId); $response = $this->agent->rollbackCheckpoint($sandboxId, $request); if ($response->isSuccess()) { $this->logger->info('[Sandbox][Domain] Checkpoint rollback successful', [ 'sandbox_id' => $sandboxId, 'target_message_id' => $targetMessageId, 'message' => $response->getMessage(), ]); } else { $this->logger->error('[Sandbox][Domain] Checkpoint rollback failed', [ 'sandbox_id' => $sandboxId, 'target_message_id' => $targetMessageId, 'code' => $response->getCode(), 'message' => $response->getMessage(), ]); } return $response; } catch (Throwable $e) { $this->logger->error('[Sandbox][Domain] Unexpected error during checkpoint rollback', [ 'sandbox_id' => $sandboxId, 'target_message_id' => $targetMessageId, 'error' => $e->getMessage(), ]); throw new SandboxOperationException('Rollback checkpoint', 'Checkpoint rollback failed: ' . $e->getMessage(), 3004); } } /** * StartRollback tospecifiedcheckpoint (callSandboxgateway). * * @param string $sandboxId SandboxID * @param string $targetMessageId TargetMessageID * @return AgentResponse RollbackResponse*/ public function rollbackCheckpointStart(string $sandboxId, string $targetMessageId): AgentResponse { $this->logger->info('[Sandbox][Domain] Starting checkpoint rollback', [ 'sandbox_id' => $sandboxId, 'target_message_id' => $targetMessageId, ]); try { $request = CheckpointRollbackStartRequest::create($targetMessageId); $response = $this->agent->rollbackCheckpointStart($sandboxId, $request); if ($response->isSuccess()) { $this->logger->info('[Sandbox][Domain] Checkpoint rollback start successful', [ 'sandbox_id' => $sandboxId, 'target_message_id' => $targetMessageId, 'message' => $response->getMessage(), ]); } else { $this->logger->error('[Sandbox][Domain] Checkpoint rollback start failed', [ 'sandbox_id' => $sandboxId, 'target_message_id' => $targetMessageId, 'code' => $response->getCode(), 'message' => $response->getMessage(), ]); } return $response; } catch (Throwable $e) { $this->logger->error('[Sandbox][Domain] Unexpected error during checkpoint rollback start', [ 'sandbox_id' => $sandboxId, 'target_message_id' => $targetMessageId, 'error' => $e->getMessage(), ]); throw new SandboxOperationException('Rollback checkpoint start', 'Checkpoint rollback start failed: ' . $e->getMessage(), 3005); } } /** * SubmitRollback tospecifiedcheckpoint (callSandboxgateway). * * @param string $sandboxId SandboxID * @return AgentResponse RollbackResponse*/ public function rollbackCheckpointCommit(string $sandboxId): AgentResponse { $this->logger->info('[Sandbox][Domain] Committing checkpoint rollback', [ 'sandbox_id' => $sandboxId, ]); try { $request = CheckpointRollbackCommitRequest::create(); $response = $this->agent->rollbackCheckpointCommit($sandboxId, $request); if ($response->isSuccess()) { $this->logger->info('[Sandbox][Domain] Checkpoint rollback commit successful', [ 'sandbox_id' => $sandboxId, 'message' => $response->getMessage(), ]); } else { $this->logger->error('[Sandbox][Domain] Checkpoint rollback commit failed', [ 'sandbox_id' => $sandboxId, 'code' => $response->getCode(), 'message' => $response->getMessage(), ]); } return $response; } catch (Throwable $e) { $this->logger->error('[Sandbox][Domain] Unexpected error during checkpoint rollback commit', [ 'sandbox_id' => $sandboxId, 'error' => $e->getMessage(), ]); throw new SandboxOperationException('Rollback checkpoint commit', 'Checkpoint rollback commit failed: ' . $e->getMessage(), 3006); } } /** * RevokeRollbackSandboxcheckpoint (callSandboxgateway). * * @param string $sandboxId SandboxID * @return AgentResponse RollbackResponse*/ public function rollbackCheckpointUndo(string $sandboxId): AgentResponse { $this->logger->info('[Sandbox][Domain] Undoing checkpoint rollback', [ 'sandbox_id' => $sandboxId, ]); try { $request = CheckpointRollbackUndoRequest::create(); $response = $this->agent->rollbackCheckpointUndo($sandboxId, $request); if ($response->isSuccess()) { $this->logger->info('[Sandbox][Domain] Checkpoint rollback undo successful', [ 'sandbox_id' => $sandboxId, 'message' => $response->getMessage(), ]); } else { $this->logger->error('[Sandbox][Domain] Checkpoint rollback undo failed', [ 'sandbox_id' => $sandboxId, 'code' => $response->getCode(), 'message' => $response->getMessage(), ]); } return $response; } catch (Throwable $e) { $this->logger->error('[Sandbox][Domain] Unexpected error during checkpoint rollback undo', [ 'sandbox_id' => $sandboxId, 'error' => $e->getMessage(), ]); throw new SandboxOperationException('Rollback checkpoint undo', 'Checkpoint rollback undo failed: ' . $e->getMessage(), 3007); } } /** * CheckRollback tospecifiedcheckpointcanRowproperty. * * @param string $sandboxId SandboxID * @param string $targetMessageId TargetMessageID * @return AgentResponse CheckResponse*/ public function rollbackCheckpointCheck(string $sandboxId, string $targetMessageId): AgentResponse { $this->logger->info('[Sandbox][Domain] Checking checkpoint rollback feasibility', [ 'sandbox_id' => $sandboxId, 'target_message_id' => $targetMessageId, ]); try { $request = CheckpointRollbackCheckRequest::create($targetMessageId); $response = $this->agent->rollbackCheckpointCheck($sandboxId, $request); if ($response->isSuccess()) { $this->logger->info('[Sandbox][Domain] Checkpoint rollback check completed', [ 'sandbox_id' => $sandboxId, 'target_message_id' => $targetMessageId, 'can_rollback' => $response->getDataValue('can_rollback'), ]); } else { $this->logger->warning('[Sandbox][Domain] Checkpoint rollback check failed', [ 'sandbox_id' => $sandboxId, 'target_message_id' => $targetMessageId, 'error' => $response->getMessage(), ]); } return $response; } catch (Throwable $e) { $this->logger->error('[Sandbox][Domain] Unexpected error during checkpoint rollback check', [ 'sandbox_id' => $sandboxId, 'target_message_id' => $targetMessageId, 'error' => $e->getMessage(), ]); throw new SandboxOperationException('Rollback checkpoint check', 'Checkpoint rollback check failed: ' . $e->getMessage(), 3008); } } /** * Upgrade sandbox image. * * @param string $messageId MessageID * @param string $contextType contextType, defaultForcontinue * @return AgentResponse UpgradeResponseResult * @throws SandboxOperationException whenUpgradeFailedThrow whenAbnormal*/ public function upgradeSandbox(string $messageId, string $contextType = 'continue'): AgentResponse { $this->logger->info('[Sandbox][Domain] Upgrading sandbox image', [ 'message_id' => $messageId, 'context_type' => $contextType, ]); try { // callgatewayService enter RowUpgrade $result = $this->gateway->upgradeSandbox($messageId, $contextType); if (! $result->isSuccess()) { $this->logger->error('[Sandbox][Domain] Failed to upgrade sandbox', [ 'message_id' => $messageId, 'context_type' => $contextType, 'error' => $result->getMessage(), 'code' => $result->getCode(), ]); throw new SandboxOperationException('Upgrade sandbox', $result->getMessage(), $result->getCode()); } $this->logger->info('[Sandbox][Domain] Sandbox upgraded successfully', [ 'message_id' => $messageId, 'context_type' => $contextType, ]); // ConvertGatewayResultConvert toAgentResponse return AgentResponse::fromGatewayResult($result); } catch (SandboxOperationException $e) { //  re ThrowSandboxOperationAbnormal throw $e; } catch (Throwable $e) { $this->logger->error('[Sandbox][Domain] Unexpected error during sandbox upgrade', [ 'message_id' => $messageId, 'context_type' => $contextType, 'error' => $e->getMessage(), ]); throw new SandboxOperationException('Upgrade sandbox', 'Sandbox upgrade failed: ' . $e->getMessage(), 3009); } } /** * BuildInitializeMessage. * * @param?string $projectOrganizationCode ProjectBelong toOrganization code, 10monthAdd newSupportcrossOrganizationProjectCollaboration, AllFileallinProjectOrganization next  * @param InitializationMetadataDTO $initMetadata Initialize element Data DTO*/ private function generateInitializationInfo(DataIsolation $dataIsolation, TaskContext $taskContext, ?string $memory = Null, ?string $projectOrganizationCode = Null, ?InitializationMetadataDTO $initMetadata = Null): array { $initMetadata = $initMetadata ?? InitializationMetadataDTO::createDefault(); // 1. getUploadconfigurationinformation $storageType = StorageBucketType::SandBox->value; $expires = 3600; // Credential valid for 1 hour // Create user authorization object $userAuthorization = new MagicUserAuthorization(); $userAuthorization->setOrganizationCode($dataIsolation->getCurrentOrganizationCode()); // Use unified FileAppService to get STS Token $projectDir = WorkDirectoryUtil::getRootDir($dataIsolation->getCurrentUserId(), $taskContext->getTask()->getProjectId()); $stsConfig = $this->fileAppService->getStsTemporaryCredentialV2($projectOrganizationCode, $storageType, $projectDir, $expires, false); // 2. Build element Data $userInfoArray = $this->userInfoAppService->getUserInfo($dataIsolation->getCurrentUserId(), $dataIsolation); $userInfo = UserInfoValueObject::fromArray($userInfoArray); $this->logger->info('[Sandbox][App] Language generateInitializationInfo', [ 'language' => $dataIsolation->getLanguage(), ]); $messageMetadata = new MessageMetadata( $taskContext->getAgentUserId(), $dataIsolation->getCurrentUserId(), $dataIsolation->getCurrentOrganizationCode(), $taskContext->getChatConversationId(), $taskContext->getChatTopicId(), (string) $taskContext->getTopicId(), $taskContext->getInstruction()->value, $taskContext->getSandboxId(), (string) $taskContext->getTask()->getId(), $taskContext->getWorkspaceId(), (string) $taskContext->getTask()->getProjectId(), $dataIsolation->getLanguage() ?? '', $userInfo, $initMetadata->getSkipInitMessages() ?? false ); // chat history $fullPrefix = $this->cloudFileRepository->getFullPrefix($projectOrganizationCode); $chatWorkDir = WorkDirectoryUtil::getAgentChatHistoryDir($dataIsolation->getCurrentUserId(), $taskContext->getProjectId()); $fullChatWorkDir = WorkDirectoryUtil::getFullWorkdir($fullPrefix, $chatWorkDir); $fullWorkDir = WorkDirectoryUtil::getFullWorkdir($fullPrefix, $taskContext->getTask()->getWorkDir()); return [ 'message_id' => (string) IdGenerator::getSnowId(), 'user_id' => $dataIsolation->getCurrentUserId(), 'project_id' => (string) $taskContext->getTask()->getProjectId(), 'type' => MessageType::Init->value, 'upload_config' => $stsConfig, 'message_subscription_config' => [ 'method' => 'POST', 'url' => config('super-magic.sandbox.callback_host', '') . '/api/v1/super-agent/tasks/deliver-message', 'headers' => [ 'token' => config('super-magic.sandbox.token', ''), ], ], 'sts_token_refresh' => [ 'method' => 'POST', 'url' => config('super-magic.sandbox.callback_host', '') . '/api/v1/super-agent/file/refresh-sts-token', 'headers' => [ 'token' => config('super-magic.sandbox.token', ''), ], ], 'metadata' => $messageMetadata->toArray(), 'task_mode' => $taskContext->getTask()->getTaskMode(), 'agent_mode' => $taskContext->getAgentMode(), 'magic_service_host' => config('super-magic.sandbox.callback_host', ''), 'memory' => $memory, 'chat_history_dir' => $fullChatWorkDir, 'work_dir' => $fullWorkDir, 'model_id' => $taskContext->getModelId(), 'fetch_history' => ! $taskContext->getIsFirstTask(), ]; } /** * Get prompt constraint text based on extra configuration. * Returns combined constraint text based on extra settings. * * @param TaskContext $taskContext Task context containing extra and language info * @return string Constraint text or empty string */ private function getPromptConstraint(TaskContext $taskContext): string { $extra = $taskContext->getExtra(); if ($extra === Null) { return ''; } $language = $taskContext->getDataIsolation()->getLanguage(); $constraints = []; // Check web search constraint if ($extra->getEnableWebSearch() === false) { $constraints[] = trans('prompt.disable_web_search_constraint', [], $language); $this->logger->info('[Sandbox][App] Web search disabled, constraint text will be appended to prompt', [ 'task_id' => $taskContext->getTask()->getId(), 'language' => $language, ]); } return empty($constraints) ? '' : implode('', $constraints); } /** * @param Null|string $mentionsJson mentions JSON String * @return array Process/Handle after  mentions Array*/ private function buildMentionsJsonStruct(?string $mentionsJson): array { if ($mentionsJson && json_validate($mentionsJson)) { $mentions = (array) Json::decode($mentionsJson); } else { $mentions = []; } if (empty($mentionsJson) || empty($mentions)) { return $mentions; } return $mentions; } } 