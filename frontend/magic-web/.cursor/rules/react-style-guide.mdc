---
description: 
globs: 
alwaysApply: false
---
@rule React Component Style Guide
@description React component development standards and best practices
@priority high
@category development

# React Component Style Guide

## Component Types

1. **Function Components**: Use function components and Hooks by default, avoid class components
   ```tsx
   export const MyComponent = ({ prop1, prop2 }: MyComponentProps) => {
     // Component logic
     return <div>Component content</div>;
   };
   ```

2. **HOC Pattern**: Use higher-order components when shared logic is needed
   ```tsx
   export const withAuth = (Component: React.ComponentType<any>) => {
     return (props: any) => {
       // Authentication logic
       return <Component {...props} />;
     };
   };
   ```

3. **Compound Components**: Use compound component pattern for complex components
   ```tsx
   export const Tabs = ({ children }: TabsProps) => {
     // Tabs logic
     return <div className="tabs">{children}</div>;
   };
   
   Tabs.Item = ({ children }: TabItemProps) => {
     return <div className="tab-item">{children}</div>;
   };
   ```

## Style Conventions

1. Use `createStyle` to create styles (based on ant-design 5)
   ```tsx
   import { createStyle } from 'antd-style';
   
   const useStyles = createStyle(({ token }) => ({
     container: {
       padding: token.padding,
       backgroundColor: token.colorBgContainer,
       borderRadius: token.borderRadius,
     },
     title: {
       color: token.colorTextHeading,
       fontSize: token.fontSizeHeading3,
     },
   }));
   
   export const MyComponent = () => {
     const styles = useStyles();
     return (
       <div className={styles.container}>
         <h2 className={styles.title}>Title</h2>
       </div>
     );
   };
   ```

## State Management

1. **Local State**: Use `useState` or `useReducer`
2. **Global State**: Use Zustand or MobX
3. **Complex Form State**: Use `antd`'s `Form` component

## Props Design

1. Clearly define Props types
   ```tsx
   interface ButtonProps {
     type?: 'primary' | 'default' | 'danger';
     size?: 'small' | 'middle' | 'large';
     onClick?: (e: React.MouseEvent) => void;
     disabled?: boolean;
     children: React.ReactNode;
   }
   ```

2. Use Props destructuring and default values
   ```tsx
   export const Button = ({
     type = 'default',
     size = 'middle',
     onClick,
     disabled = false,
     children,
   }: ButtonProps) => {
     // Component implementation
   };
   ```

## Performance Optimization

1. Use `useMemo` to cache computed results
2. Use `useCallback` to cache function references
3. Use `React.memo` to avoid unnecessary re-renders
4. Appropriately use Code Splitting and lazy loading

## Error Handling

1. Use ErrorBoundary component to catch rendering errors
2. Unified handling of API request errors
3. Use try-catch to handle expected exceptions

## Accessibility

1. Use semantic HTML tags
2. Provide appropriate ARIA attributes
3. Ensure keyboard navigation
4. Maintain appropriate color contrast
