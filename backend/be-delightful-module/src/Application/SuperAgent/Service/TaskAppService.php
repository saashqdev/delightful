<?php declare(strict_types=1); /** * Copyright (c) Be Delightful , Distributed under the MIT software license */ namespace Delightful\BeDelightful\Application\SuperAgent\Service; use App\Application\Chat\Service\DelightfulChatMessageAppService; use App\Application\Chat\Service\DelightfulUserInfoAppService; use App\Application\File\Service\FileAppService; use App\Domain\Chat\Entity\Items\SeqExtra; use App\Domain\Chat\Entity\DelightfulSeqEntity; use App\Domain\Chat\Entity\ValueObject\ConversationType; use App\Domain\Chat\Entity\ValueObject\MessageType\ChatMessageType; use App\Domain\Chat\Service\DelightfulChatFileDomainService; use App\Domain\Contact\Entity\ValueObject\DataIsolation; use App\Domain\Contact\Entity\ValueObject\UserType; use App\Domain\Contact\Service\DelightfulUserDomainService; use App\Domain\ModelGateway\Service\AccessTokenDomainService; use App\Domain\ModelGateway\Service\ApplicationDomainService; use App\ErrorCode\GenericErrorCode; use App\Infrastructure\Core\Exception\BusinessException; use App\Infrastructure\Core\Exception\EventException; use App\Infrastructure\Core\Exception\ExceptionBuilder; use App\Infrastructure\Util\Context\CoContext; use App\Infrastructure\Util\IdGenerator\IdGenerator; use App\Infrastructure\Util\Locker\LockerInterface; use App\Interfaces\Authorization\Web\DelightfulUserAuthorization; use Delightful\AsyncEvent\AsyncEventUtil; use Delightful\BeDelightful\Application\SuperAgent\DTO\TaskMessageDTO; use Delightful\BeDelightful\Application\SuperAgent\DTO\UserMessageDTO; use Delightful\BeDelightful\Domain\SuperAgent\Entity\TaskEntity; use Delightful\BeDelightful\Domain\SuperAgent\Entity\TaskMessageEntity; use Delightful\BeDelightful\Domain\SuperAgent\Entity\TopicEntity; use Delightful\BeDelightful\Domain\SuperAgent\Entity\ValueObject\ChatInstruction; use Delightful\BeDelightful\Domain\SuperAgent\Entity\ValueObject\FileType; use Delightful\BeDelightful\Domain\SuperAgent\Entity\ValueObject\MessageMetadata; use Delightful\BeDelightful\Domain\SuperAgent\Entity\ValueObject\MessagePayload; use Delightful\BeDelightful\Domain\SuperAgent\Entity\ValueObject\MessageType; use Delightful\BeDelightful\Domain\SuperAgent\Entity\ValueObject\TaskContext; use Delightful\BeDelightful\Domain\SuperAgent\Entity\ValueObject\TaskStatus; use Delightful\BeDelightful\Domain\SuperAgent\Entity\ValueObject\UserInfoValueObject; use Delightful\BeDelightful\Domain\SuperAgent\Event\RunTaskAfterEvent; use Delightful\BeDelightful\Domain\SuperAgent\Event\RunTaskBeforeEvent; use Delightful\BeDelightful\Domain\SuperAgent\Event\RunTaskCallbackEvent; use Delightful\BeDelightful\Domain\SuperAgent\Repository\Facade\TaskRepositoryInterface; use Delightful\BeDelightful\Domain\SuperAgent\Service\MessageBuilderDomainService; use Delightful\BeDelightful\Domain\SuperAgent\Service\ProjectDomainService; use Delightful\BeDelightful\Domain\SuperAgent\Service\TaskDomainService; use Delightful\BeDelightful\Domain\SuperAgent\Service\TopicDomainService; use Delightful\BeDelightful\Domain\SuperAgent\Service\WorkspaceDomainService; use Delightful\BeDelightful\ErrorCode\SuperAgentErrorCode; use Delightful\BeDelightful\Infrastructure\ExternalAPI\Sandbox\Config\WebSocketConfig; use Delightful\BeDelightful\Infrastructure\ExternalAPI\Sandbox\SandboxResult; use Delightful\BeDelightful\Infrastructure\ExternalAPI\Sandbox\SandboxStruct; use Delightful\BeDelightful\Infrastructure\ExternalAPI\Sandbox\Volcengine\SandboxService; use Delightful\BeDelightful\Infrastructure\ExternalAPI\Sandbox\WebSocket\WebSocketSession; use Delightful\BeDelightful\Infrastructure\Utils\TaskStatusValidator; use Delightful\BeDelightful\Infrastructure\Utils\ToolProcessor; use Delightful\BeDelightful\Interfaces\SuperAgent\DTO\TopicTaskMessageDTO; use Error; use Exception; use Hyperf\Codec\Json; use Hyperf\Coroutine\Coroutine; use Hyperf\Coroutine\Parallel; use Hyperf\Logger\LoggerFactory; use Hyperf\Odin\Message\Role; use Psr\Log\LoggerInterface; use RuntimeException; use Throwable; class TaskAppService extends AbstractAppService { protected LoggerInterface $logger; /** * MessageBuildService*/ private MessageBuilderDomainService $messageBuilder; public function __construct( private readonly WorkspaceDomainService $workspaceDomainService, private readonly TopicDomainService $topicDomainService, private readonly TaskDomainService $taskDomainService, private readonly DelightfulChatMessageAppService $chatMessageAppService, private readonly DelightfulUserInfoAppService $userInfoAppService, private readonly DelightfulChatFileDomainService $chatFileDomainService, private readonly FileAppService $fileAppService, private readonly SandboxService $sandboxService, private readonly FileProcessAppService $fileProcessAppService, protected DelightfulUserDomainService $userDomainService, protected TaskRepositoryInterface $taskRepository, protected LockerInterface $locker, LoggerFactory $loggerFactory, protected AccessTokenDomainService $accessTokenDomainService, protected ApplicationDomainService $applicationDomainService, protected ProjectDomainService $projectDomainService, ) { $this->messageBuilder = new MessageBuilderDomainService(); $this->logger = $loggerFactory->get(get_class($this)); } /** * InitializeAgentTask, establishWebSocketConnect, AndStartProcess/Handlecoroutine.*/ public function initAgentTask( DataIsolation $dataIsolation, string $agentUserId, string $conversationId, string $chatTopicId, string $prompt, ?string $attachments = Null, ChatInstruction $instruction = ChatInstruction::Normal, string $taskMode = '' ): string { $topicId = 0; $taskId = ''; try { $topicEntity = $this->topicDomainService->getTopicByChatTopicId($dataIsolation, $chatTopicId); if (is_Null($topicEntity)) { ExceptionBuilder::throw(SuperAgentErrorCode::TOPIC_NOT_FOUND, 'topic.topic_not_found'); } $topicId = $topicEntity->getId(); // CheckuserTaskQuantityLimitAnd whitelist $this->beforeInitTask($dataIsolation, $instruction, $topicEntity); // InitializeTask $userMessageDTO = new UserMessageDTO( agentUserId: $agentUserId, chatConversationId: $conversationId, chatTopicId: $chatTopicId, topicId: $topicId, prompt: $prompt, attachments: $attachments, mentions: Null, instruction: $instruction, taskMode: $taskMode ); // Get task mode from DTO, fallback to topic's task mode if empty $taskMode = $userMessageDTO->getTaskMode(); if ($taskMode === '') { $taskMode = $topicEntity->getTaskMode(); } $data = [ 'user_id' => $dataIsolation->getCurrentUserId(), 'workspace_id' => $topicEntity->getWorkspaceId(), 'project_id' => $topicEntity->getProjectId(), 'topic_id' => $topicId, 'task_id' => '', // Initially empty, this is agent's task id 'task_mode' => $taskMode, 'sandbox_id' => $topicEntity->getSandboxId(), // Current task prioritizes reusing previous topic's sandbox id 'prompt' => $userMessageDTO->getPrompt(), 'attachments' => $userMessageDTO->getAttachments(), 'mentions' => $userMessageDTO->getMentions(), 'task_status' => TaskStatus::WAITING->value, 'work_dir' => $topicEntity->getWorkDir() ?? '', 'created_at' => date('Y-m-d H:i:s'), 'updated_at' => date('Y-m-d H:i:s'), ]; $taskEntity = TaskEntity::fromArray($data); // Initialize task $taskEntity = $this->taskDomainService->initTopicTask( dataIsolation: $dataIsolation, topicEntity: $topicEntity, taskEntity: $taskEntity ); $taskEntity = $this->taskDomainService->initTopicTask($dataIsolation, $topicEntity, $taskEntity); $taskId = (string) $taskEntity->getId(); // Initializecontext $taskContext = new TaskContext( $taskEntity, $dataIsolation, $conversationId, $chatTopicId, $agentUserId, $topicEntity->getSandboxId(), $taskId, $instruction, ); // If is InterruptInstruction, directlySend interruptInstruction if ($instruction == ChatInstruction::Interrupted) { $this->sendInternalMessageToSandbox($taskContext, $topicEntity); return $taskId; } // RemainingInstructionall is Conversationinformation // Process/HandleuserSendinformation // RecorduserSendMessage $attachmentsArr = is_Null($attachments) ? [] : json_decode($attachments, true); // Create TaskMessageDTO for user message $taskMessageDTO = new TaskMessageDTO( taskId: (string) $taskEntity->getId(), role: Role::User->value, senderUid: $dataIsolation->getCurrentUserId(), receiverUid: $agentUserId, messageType: 'chat', content: $prompt, status: Null, steps: Null, tool: Null, topicId: $taskEntity->getTopicId(), event: '', attachments: $attachmentsArr, mentions: Null, showInUi: true, messageId: Null ); $taskMessageEntity = TaskMessageEntity::taskMessageDTOToTaskMessageEntity($taskMessageDTO); $this->taskDomainService->recordTaskMessage($taskMessageEntity); // Process/HandleuserUploadAttachment $this->fileProcessAppService->processInitialAttachments($attachments, $taskEntity, $dataIsolation); // InitializeSandboxEnvironment // No/NoneSandboxid,  that whatonefixed is first times Task $isFirstTaskMessage = empty($taskEntity->getSandboxId()); /** @var bool $isInitConfig */ [$isInitConfig, $sandboxId] = $this->initSandbox($taskEntity->getSandboxId()); if (empty($sandboxId)) { $this->updateTaskStatus( $taskEntity, $dataIsolation, $taskEntity->getTaskId(), TaskStatus::ERROR, 'CreateSandboxFailed' ); throw new BusinessException('CreateSandboxFailed', 500); } $this->logger->info(sprintf('CreateSandboxSuccess: %s', $sandboxId)); $taskEntity->setSandboxId($sandboxId); // setTaskStatusForWait in  $this->updateTaskStatus($taskEntity, $dataIsolation, $taskId, TaskStatus::WAITING); $taskContext->setSandboxId($sandboxId); // 5. Start coroutineProcess/HandleWebSocketGeneral message  $requestId = CoContext::getOrSetRequestId(); Coroutine::create(function () use ($taskContext, $isInitConfig, $isFirstTaskMessage, $requestId) { try { CoContext::setRequestId($requestId); $this->sendChatMessageToSandbox($taskContext, $isInitConfig, $isFirstTaskMessage); } catch (Throwable $e) { $this->logger->error(sprintf( 'WebSocketGeneral message Process/HandleAbnormal: %s, TaskID: %s', $e->getMessage(), $taskContext->getTaskId() )); // UpdateTaskStatusForError $this->updateTaskStatus( $taskContext->getTask(), $taskContext->getDataIsolation(), $taskContext->getTaskId(), TaskStatus::ERROR, $e->getMessage() ); } }); return $taskContext->getTaskId(); } catch (EventException $e) { $this->logger->error(sprintf( 'InitializeTask, EventProcess/HandleFailed: %s', $e->getMessage() )); // SendMessage give Client $this->sendErrorMessageToClient($topicId, $taskId, $chatTopicId, $conversationId, $e->getMessage()); throw new BusinessException('InitializeTask, EventProcess/HandleFailed', 500); } catch (Throwable $e) { $this->logger->error(sprintf( 'InitializeTaskFailed: %s', $e->getMessage() )); $text = 'Systembusy，please wait after Retry'; if ($e->getCode() === GenericErrorCode::IllegalOperation->value) { $text = $e->getMessage(); } // SendMessage give Client $this->sendErrorMessageToClient($topicId, (string) $taskId, $chatTopicId, $conversationId, $text); throw new BusinessException('InitializeTaskFailed', 500); } } public function beforeInitTask(DataIsolation $dataIsolation, ChatInstruction $instruction, TopicEntity $topicEntity): void { if ($instruction == ChatInstruction::Interrupted) { return; } $topicEntities = $this->topicDomainService->getUserRunningTopics($dataIsolation); $currentTaskRunCount = count($topicEntities); // OriginalQuantity，FalsesetallinRun if ($currentTaskRunCount > 0) { // Use coroutines to concurrently check real sandbox status $parallel = new Parallel(10); $requestId = CoContext::getOrSetRequestId(); foreach ($topicEntities as $index => $topicEntityItem) { $parallel->add(function () use ($topicEntityItem, $requestId) { CoContext::setRequestId($requestId); // Check real sandbox status and return 1 if not running (need to subtract) $realStatus = $this->updateTaskStatusFromSandbox($topicEntityItem); return $realStatus !== TaskStatus::RUNNING ? 1 : 0; }, (string) $index); } try { $results = $parallel->wait(); // Subtract non-running topics from total count foreach ($results as $needSubtract) { $currentTaskRunCount -= $needSubtract; } } catch (Throwable $e) { $this->logger->error(sprintf('Failed to check real task status concurrently: %s', $e->getMessage())); // Fallback: use original count without real status check } } $taskRound = $this->taskDomainService->getTaskNumByTopicId($topicEntity->getId()); AsyncEventUtil::dispatch(new RunTaskBeforeEvent($dataIsolation->getCurrentOrganizationCode(), $dataIsolation->getCurrentUserId(), $topicEntity->getId(), $taskRound, $currentTaskRunCount, [], '', '')); $this->logger->info(sprintf('DeliverTaskStartEvent，Topicid：%s, round: %d, currentTaskRunCount: %d (after real status check)', $topicEntity->getId(), $taskRound, $currentTaskRunCount)); } public function updateTaskStatusFromSandbox(TopicEntity $topicEntity): TaskStatus { $this->logger->info(sprintf('StartCheckTaskStatus: topic_id=%s', $topicEntity->getId())); if (! $topicEntity->getSandboxId()) { return TaskStatus::WAITING; } // callSandboxServicegetStatusInterfacegetContainerStatus $result = $this->sandboxService->getStatus($topicEntity->getSandboxId()); // IfSandbox store inandStatusFor running, directlyReturnThisSandbox if ($result->getCode() === SandboxResult::Normal && $result->getSandboxData()->getStatus() === SandboxResult::SandboxRunnig) { $this->logger->info(sprintf('SandboxStatusNormal(running): sandboxId=%s', $topicEntity->getSandboxId())); return TaskStatus::RUNNING; } // RecordNeedCreate new Sandboxoriginalbecause if ($result->getCode() === SandboxResult::NotFound) { $errMsg = 'SandboxDoes not existin'; } elseif ($result->getCode() === SandboxResult::Normal && $result->getSandboxData()->getStatus() === 'exited') { $errMsg = 'Sandbox already throughexitoutput'; } else { $errMsg = 'SandboxAbnormal'; } // getCurrentTask $taskId = $topicEntity->getCurrentTaskId(); if ($taskId) { // UpdateTaskStatus $this->taskDomainService->updateTaskStatusByTaskId($taskId, TaskStatus::ERROR, $errMsg); } // UpdateTopicStatus $this->topicDomainService->updateTopicStatus($topicEntity->getId(), $taskId, TaskStatus::ERROR); // TriggerCompleteEvent AsyncEventUtil::dispatch(new RunTaskAfterEvent( $topicEntity->getUserOrganizationCode(), $topicEntity->getUserId(), $topicEntity->getId(), $taskId, TaskStatus::ERROR->value, Null )); $this->logger->info(sprintf('EndCheckTaskStatus: topic_id=%s, status=%s, error_msg=%s', $topicEntity->getId(), TaskStatus::ERROR->value, $errMsg)); return TaskStatus::ERROR; } /** * SendterminateTaskinformation. * @throws Throwable*/ public function sendInternalMessageToSandbox(TaskContext $taskContext, TopicEntity $topicEntity, string $msg = ''): void { $text = empty($msg) ? 'Task already terminate.' : $msg; // CheckSandboxwhether store in if (empty($topicEntity->getSandboxId())) { $this->logger->info('SandboxidDoes not existin，directlyUpdateTaskStatus'); $this->updateTaskStatus($taskContext->getTask(), $taskContext->getDataIsolation(), $taskContext->getTaskId(), TaskStatus::Suspended, 'SandboxidDoes not existin，directlyUpdateTaskStatus'); $this->sendErrorMessageToClient($topicEntity->getId(), (string) $taskContext->getTask()->getId(), $taskContext->getChatTopicId(), $taskContext->getChatConversationId(), $text); return; } // callfarprocessQuerySandboxwhether store in $result = $this->sandboxService->checkSandboxExists($topicEntity->getSandboxId()); if ($result->getCode() == SandboxResult::NotFound || $result?->getSandboxData()?->getStatus() == SandboxResult::SandboxExited) { $this->logger->info('SandboxDoes not existinOr exit，directlyUpdateTaskStatus'); $this->updateTaskStatus($taskContext->getTask(), $taskContext->getDataIsolation(), $taskContext->getTaskId(), TaskStatus::Suspended, 'SandboxDoes not existinOr exit，directlyUpdateTaskStatus'); $this->sendErrorMessageToClient($topicEntity->getId(), (string) $taskContext->getTask()->getId(), $taskContext->getChatTopicId(), $taskContext->getChatConversationId(), $text); } // IfSandbox store in, Build websocket Generalway enter RowConnect $websocketSession = $this->getSandboxWebsocketClient($taskContext); if (is_Null($websocketSession)) { throw new BusinessException('GetSandboxwebsocketClientFailed', 500); } try { // setInterruptInstruction $taskContext->getTask()->setPrompt('terminateTask'); $taskContext->setInstruction(ChatInstruction::Interrupted); $message = $this->messageBuilder->buildInterruptMessage( $taskContext->getCurrentUserId(), $taskContext->getTask()->getId(), $taskContext->getTask()->getTaskMode(), $msg ); $this->sendMessageToSandbox($websocketSession, $taskContext->getTask()->getId(), $message); } catch (Exception $e) { $this->logger->error(sprintf('terminateSandboxTaskInformationFailed，ErrorContentFor: %s', $e->getMessage())); throw new BusinessException('SendterminateTaskFailed', 500); } finally { $websocketSession->disconnect(); } } /** * Process/HandleTopicTaskMessage. * * @param TopicTaskMessageDTO $messageDTO MessageDTO*/ public function handleTopicTaskMessage(TopicTaskMessageDTO $messageDTO): void { $this->logger->info(sprintf( 'StartProcess/HandleTopicTaskMessage，task_id: %s , MessageContentFor: %s', $messageDTO->getPayload()->getTaskId() ?? '', json_encode($messageDTO->toArray(), JSON_UNESCAPED_UNICODE | JSON_UNESCAPED_SLASHES) )); // CreateDataIsolationObject $dataIsolation = DataIsolation::create( $messageDTO->getMetadata()->getOrganizationCode(), $messageDTO->getMetadata()->getUserId() ); // Process/HandleMessagePre-distributeEvent $topicEntity = $this->topicDomainService->getTopicByChatTopicId($dataIsolation, $messageDTO->getMetadata()->getChatTopicId()); if (is_Null($topicEntity)) { throw new RuntimeException(sprintf('By/According tochatTopic id: %s Not foundTopicInformation', $messageDTO->getMetadata()->getChatTopicId())); } // getTaskinformation $taskEntity = $this->taskDomainService->getTaskById($topicEntity->getCurrentTaskId()); if (is_Null($taskEntity)) { throw new RuntimeException(sprintf('By/According toTask id: %s Not foundTaskInformation', $topicEntity->getCurrentTaskId() ?? '')); } // CreateTaskcontext $taskContext = new TaskContext( task: $taskEntity, dataIsolation: $dataIsolation, chatConversationId: $messageDTO->getMetadata()?->getChatConversationId(), chatTopicId: $messageDTO->getMetadata()?->getChatTopicId(), agentUserId: $messageDTO->getMetadata()?->getAgentUserId(), sandboxId: $messageDTO->getMetadata()?->getSandboxId(), taskId: $messageDTO->getPayload()?->getTaskId(), instruction: ChatInstruction::tryFrom($messageDTO->getMetadata()?->getInstruction()) ?? ChatInstruction::Normal ); try { // Process/HandleReceivedMessage $this->handleReceivedMessage($messageDTO, $taskContext); // Process/HandleTaskStatus $status = $messageDTO->getPayload()->getStatus(); $taskStatus = TaskStatus::tryFrom($status) ?? TaskStatus::ERROR; if (TaskStatus::tryFrom($status)) { $this->updateTaskStatus($taskContext->getTask(), $taskContext->getDataIsolation(), $taskContext->getTaskId(), $taskStatus); } AsyncEventUtil::dispatch(new RunTaskCallbackEvent( $taskContext->getCurrentOrganizationCode(), $taskContext->getCurrentUserId(), $taskContext->getTopicId(), $topicEntity->getTopicName(), $taskContext->getTask()->getId(), $messageDTO, $messageDTO->getMetadata()->getLanguage() )); $this->logger->info(sprintf( 'Process/HandleTopicTaskMessageComplete，message_id: %s', $messageDTO->getPayload()->getMessageId() )); } catch (EventException $e) { $this->logger->error(sprintf('Process/HandleMessageEventCallback's overprocessappearAbnormal: %s', $e->getMessage())); $this->sendInternalMessageToSandbox($taskContext, $topicEntity, $e->getMessage()); } catch (Throwable $e) { $this->logger->error(sprintf( 'Process/HandleTopicTaskMessageAbnormal: %s, message_id: %s', $e->getMessage(), $messageDTO->getPayload()->getMessageId() ), [ 'exception' => $e, 'message' => $messageDTO->toArray(), ]); } } /** * getDistribute style mutex lock . * * @param string $lockKey  lock Keyname * @param string $lockOwner  lock Holder * @param int $lockExpireSeconds  lock Expired at ( seconds ) * @return bool whetherSuccessget lock */ public function acquireLock(string $lockKey, string $lockOwner, int $lockExpireSeconds): bool { return $this->locker->mutexLock($lockKey, $lockOwner, $lockExpireSeconds); } /** * releaseDistribute style mutex lock . * * @param string $lockKey  lock Keyname * @param string $lockOwner  lock Holder * @return bool whetherSuccessrelease lock */ public function releaseLock(string $lockKey, string $lockOwner): bool { return $this->locker->release($lockKey, $lockOwner); } public function sendContinueMessageToSandbox(string $sandboxId, bool $isInit = false): bool { // throughSandboxid $topicEntity = $this->topicDomainService->getTopicBySandboxId($sandboxId); if (is_Null($topicEntity)) { throw new RuntimeException(sprintf('By/According toSandbox id: %s Not foundTopicInformation', $sandboxId)); } // CreateDataIsolationObject $dataIsolation = DataIsolation::create( $topicEntity->getUserOrganizationCode(), $topicEntity->getUserId(), ); // getTaskinformation $taskEntity = $this->taskDomainService->getTaskById($topicEntity->getCurrentTaskId()); if (is_Null($taskEntity)) { throw new RuntimeException(sprintf('By/According toTask id: %s Not foundTaskInformation', $topicEntity->getCurrentTaskId() ?? '')); } $taskContext = new TaskContext( task: $taskEntity, dataIsolation: $dataIsolation, chatConversationId: $topicEntity->getChatConversationId(), chatTopicId: $topicEntity->getChatTopicId(), agentUserId: '', sandboxId: $sandboxId, taskId: (string) $taskEntity->getId(), instruction: ChatInstruction::FollowUp ); // throughSandbox id QueryCurrent $session = $this->getSandboxWebsocketClient($taskContext); if (is_Null($session)) { throw new BusinessException('GetSandboxwebsocketClientFailed'); } // SendInitializeMessage if ($isInit) { $this->initTaskMessageToSandbox($session, $taskContext, false); } $chatMessage = $this->messageBuilder->buildContinueMessage( $dataIsolation->getCurrentUserId(), $taskContext->getChatConversationId(), ); $this->sendMessageToSandbox($session, $taskEntity->getId(), $chatMessage); return true; } /** * Summary of getTaskById. */ public function getTaskById(int $taskId): ?TaskEntity { return $this->taskDomainService->getTaskById($taskId); } /** * get websocket Clientcheap.*/ private function getSandboxWebsocketClient(TaskContext $taskContext): ?WebSocketSession { $config = new WebSocketConfig(); $task = $taskContext->getTask(); $sandboxId = $taskContext->getSandboxId(); $wsUrl = $this->sandboxService->getWebsocketUrl($sandboxId); // PrintConnectParameter $this->logger->info(sprintf( 'WebSocketConnectParameter，URL: %s，MaximumConnectTime: %d seconds ', $wsUrl, $config->getConnectTimeout() )); // Create WebSocket Session $session = new WebSocketSession( $config, $this->logger, $wsUrl, $task->getTaskId() ); try { $session->connect(); return $session; } catch (Exception $e) { $this->logger->error(sprintf( 'WebSocketConnectFailed，URL: %s，ErrorInformation: %s', $wsUrl, $e->getMessage() )); return Null; } } /** * Process/HandleWebSocketGeneral message */ private function sendChatMessageToSandbox( TaskContext $taskContext, bool $isInitConfig, bool $isFirstTaskMessage, ): void { // establishConnect $session = $this->getSandboxWebsocketClient($taskContext); if (is_Null($session)) { throw new BusinessException('GetSandboxwebsocketClientFailed'); } try { // SendInitializeMessage if ($isInitConfig) { $this->initTaskMessageToSandbox($session, $taskContext, $isFirstTaskMessage); } // SendChatMessage $dataIsolation = $taskContext->getDataIsolation(); $task = $taskContext->getTask(); $attachmentUrls = $this->getAttachmentUrls($task->getAttachments(), $dataIsolation->getCurrentOrganizationCode()); $chatMessage = $this->messageBuilder->buildChatMessage( $dataIsolation->getCurrentUserId(), $task->getId(), $taskContext->getInstruction()->value, $task->getPrompt(), $attachmentUrls, $task->getTaskMode() ); $taskId = $this->sendMessageToSandbox($session, $task->getId(), $chatMessage); // InitializeSuccess after , UpdateStatusFor running $taskContext->getTask()->setTaskId($taskId); // UpdateTaskForExecuteStatus $this->updateTaskStatus($taskContext->getTask(), $taskContext->getDataIsolation(), $taskId, TaskStatus::RUNNING); // Heregetoneconfiguration, whetherNeed enter input websocket loop $mode = config('super-magic.sandbox.pull_message_mode'); // websocket Mode, ConvertcontinuousWait if ($mode === 'websocket') { $this->processMessageLoop($session, $taskContext); } } catch (Throwable $e) { $this->logger->error(sprintf('WebSocketSessionAbnormal: %s', $e->getMessage()), [ 'exception' => $e, 'task_id' => $taskContext->getTask()->getTaskId(), 'sandbox_id' => $taskContext->getTask()->getSandboxId(), ]); $this->updateTaskStatus($taskContext->getTask(), $taskContext->getDataIsolation(), $taskContext->getTaskId(), TaskStatus::ERROR, $e->getMessage()); $this->sendErrorMessageToClient($taskContext->getTask()->getTopicId(), (string) $taskContext->getTask()->getId(), $taskContext->getChatTopicId(), $taskContext->getChatConversationId(), 'farprocessServicedeviceConnectFailed，please wait after Retry'); throw $e; } finally { // EnsureConnect be Close try { $session->disconnect(); $this->logger->info(sprintf( 'WebSocketSessionCloseSuccess，TaskID: %s', $taskContext->getTaskId() )); } catch (Throwable $e) { $this->logger->warning(sprintf( 'CloseWebSocketConnectFailed，Error: %s，TaskID: %s', $e->getMessage(), $taskContext->getTaskId() )); } } } private function initTaskMessageToSandbox(WebSocketSession $session, TaskContext $taskContext, bool $isFirstTaskMessage): string { $dataIsolation = $taskContext->getDataIsolation(); $task = $taskContext->getTask(); // Get ProjectEntity $projectEntity = $this->projectDomainService->getProjectNotUserId($task->getProjectId()); $uploadCredential = $this->getUploadCredential( $dataIsolation->getCurrentUserId(), $projectEntity->getUserOrganizationCode(), $task->getWorkDir() ); // getuserinformation $userInfo = Null; try { $userInfoArray = $this->userInfoAppService->getUserInfo($dataIsolation->getCurrentUserId(), $dataIsolation); $userInfo = UserInfoValueObject::fromArray($userInfoArray); } catch (Throwable $e) { $this->logger->warning(sprintf( 'GetUserInformationFailed: %s, UserID: %s', $e->getMessage(), $dataIsolation->getCurrentUserId() )); } // UseValueObjectreplaceOriginalArray $messageMetadata = new MessageMetadata( agentUserId: $taskContext->getAgentUserId(), userId: $dataIsolation->getCurrentUserId(), organizationCode: $dataIsolation->getCurrentOrganizationCode(), chatConversationId: $taskContext->getChatConversationId(), chatTopicId: $taskContext->getChatTopicId(), instruction: $taskContext->getInstruction()->value, sandboxId: $taskContext->getSandboxId(), superDelightfulTaskId: (string) $task->getId(), userInfo: $userInfo ); $topicEntity = $this->workspaceDomainService->getTopicById($task->getTopicId()); if (is_Null($topicEntity)) { throw new RuntimeException('Initialize agent discoverTopicDoes not existin，Topic id: ' . $task->getTopicId()); } $sandboxConfig = ! empty($topicEntity->getSandboxConfig()) ? json_decode($topicEntity->getSandboxConfig(), true) : Null; $initMessage = $this->messageBuilder->buildInitMessage( $dataIsolation->getCurrentUserId(), $uploadCredential, $messageMetadata, $isFirstTaskMessage, $sandboxConfig, $task->getTaskMode(), ); $this->logger->info(sprintf('[Send to Sandbox Init Message] task_id: %s, data: %s', $task->getTaskId(), json_encode($initMessage, JSON_UNESCAPED_UNICODE))); $session->send($initMessage); // WaitInitializeResponse $message = $session->receive(900); if ($message === Null) { throw new RuntimeException('Wait agent InitializeResponseTimeout'); } $this->logger->info(sprintf( '[Receive from Sandbox Init Message] task_id: %s, data: %s', $task->getTaskId(), json_encode($message, JSON_UNESCAPED_UNICODE) )); // ConvertOriginalMessageConvert tounifiedformat $messageDTO = $this->convertWebSocketMessageToDTO($message); $payload = $messageDTO->getPayload(); // UseNew unifiedformat enter RowValidate if (! $payload->getType() || $payload->getType() !== MessageType::Init->value) { throw new RuntimeException('Received unexpectedInitializeResponseType'); } if ($payload->getStatus() === TaskStatus::ERROR->value) { throw new RuntimeException('agent InitializeFailed: ' . json_encode($messageDTO->toArray(), JSON_UNESCAPED_UNICODE)); } return $payload->getTaskId(); } private function sendMessageToSandbox(WebSocketSession $session, int $taskId, array $chatMessage): string { $session->send($chatMessage); $this->logger->info(sprintf('[Send to Sandbox Chat Message] task_id: %d, data: %s', $taskId, json_encode($chatMessage, JSON_UNESCAPED_UNICODE))); // WaitResponse $message = $session->receive(60); if ($message === Null) { throw new RuntimeException('Wait agent ResponseTimeout'); } $this->logger->info(sprintf( '[Receive from Sandbox Chat Message] task_id: %d, data: %s', $taskId, json_encode($message, JSON_UNESCAPED_UNICODE) )); // ConvertOriginalMessageConvert tounifiedformat $messageDTO = $this->convertWebSocketMessageToDTO($message); $payload = $messageDTO->getPayload(); // UseNew unifiedformat enter RowValidate if (! $payload->getType() || $payload->getType() !== MessageType::Chat->value) { throw new RuntimeException('Received unexpectedResponseType'); } if ($payload->getStatus() === TaskStatus::ERROR->value) { throw new RuntimeException('agent ResponseFailed: ' . json_encode($messageDTO->toArray(), JSON_UNESCAPED_UNICODE)); } return $payload->getTaskId(); } /** * Process/HandleWebSocketMessageProcess.*/ private function processMessageLoop( WebSocketSession $session, TaskContext $taskContext ): void { // addMaximumProcess/HandleTimeLimit, avoidnolimitloop $startTime = time(); $config = new WebSocketConfig(); $taskTimeout = $config->getTaskTimeout(); $task = $taskContext->getTask(); while (true) { try { // CheckConnectStatus if (! $session->isConnected()) { $this->logger->warning('WebSocketConnect already Disconnect，try re Connect'); try { $session->connect(); } catch (Throwable $e) { $this->logger->error(sprintf( ' re ConnectFailed: %s, TaskID: %s', $e->getMessage(), $taskContext->getTaskId() )); $this->updateTaskStatus($task, $taskContext->getDataIsolation(), $taskContext->getTaskId(), TaskStatus::ERROR, $e->getMessage()); return; // exitoutputProcess/Handle } } // ReceiveMessage $message = $session->receive($config->getReadTimeout()); if ($message === Null) { // fixedperiodCheckTaskwhetherAlreadythroughTimeout if (time() - $startTime > $taskTimeout) { $errMsg = sprintf( 'TaskProcess/HandleTimeout，TaskID: %s，RunTime: %d seconds ，TaskTimeoutTime: %d seconds ', $taskContext->getTaskId(), time() - $startTime, $taskTimeout ); $this->logger->warning($errMsg); $this->updateTaskStatus($task, $taskContext->getDataIsolation(), $taskContext->getTaskId(), TaskStatus::ERROR, $errMsg); return; // exitoutputProcess/Handle } continue; } $this->logger->info('[Websocket Server] ReceivedServiceend's Message: ' . json_encode($message, JSON_UNESCAPED_UNICODE)); // ConvertMessageConvert tounifiedformat $messageDTO = $this->convertWebSocketMessageToDTO($message); // set task id $taskContext->setTaskId($messageDTO->getPayload()->getTaskId() ?: $task->getTaskId()); // Process/HandleMessageAndJudgewhetherNeedContinueProcess/Handle $shouldContinue = $this->handleReceivedMessage($messageDTO, $taskContext); if (! $shouldContinue) { $this->logger->info('[Task already throughComplete] task_id: ' . $taskContext->getTaskId()); break; // If is terminateMessage，exitoutputloop } } catch (Throwable $e) { $this->logger->error(sprintf( 'Task Process/HandleMessageAbnormal: %s, TaskID: %s', $e->getMessage(), $taskContext->getTaskId() )); // Judgewhether is fatalError, If is  then terminateProcess/Handle if ($this->isFatalError($e)) { $this->updateTaskStatus($task, $taskContext->getDataIsolation(), $taskContext->getTaskId(), TaskStatus::ERROR, $e->getMessage()); return; // exitoutputProcess/Handle } // NonfatalError, ContinueProcess/Handle continue; } } } /** * Process/HandleReceivedMessage. * * @param TopicTaskMessageDTO $messageDTO Message * @param TaskContext $taskContext Taskcontext * @return bool whetherContinueProcess/HandleMessage*/ private function handleReceivedMessage(TopicTaskMessageDTO $messageDTO, TaskContext $taskContext): bool { $payload = $messageDTO->getPayload(); // 1. parseMessageBasicinformation $messageType = $payload->getType() ?: 'unknown'; $content = $payload->getContent(); $status = $payload->getStatus() ?: TaskStatus::RUNNING->value; $tool = $payload->getTool() ?? []; $steps = $payload->getSteps() ?? []; $event = $payload->getEvent(); $attachments = $payload->getAttachments() ?? []; $projectArchive = $payload->getProjectArchive() ?? []; $showInUi = $payload->getShowInUi() ?? true; $messageId = $payload->getMessageId(); $correlationId = $payload->getCorrelationId(); // 2. Process/HandleUnknownMessageType if (! MessageType::isValid($messageType)) { $this->logger->warning(sprintf( 'ReceivedUnknownType's Message，Type: %s，TaskID: %s', $messageType, $taskContext->getTaskId() )); return true; } // If is PersistenceSandboxMessage if ($messageType == MessageType::ProjectArchive->value) { $this->workspaceDomainService->updateTopicSandboxConfig($taskContext->getDataIsolation(), $taskContext->getTopicId(), $projectArchive); return true; } // 3. Process/HandleToolAttachment (If have ) try { if (! empty($tool['attachments'])) { $this->processToolAttachments($tool, $taskContext); // UseToolProcess/HandledeviceProcess/HandleFileIDMatch ToolProcessor::processToolAttachments($tool); } // Process/HandleMessageAttachment $this->processMessageAttachments($attachments, $taskContext); // everyStatusNeeddoSomespecialProcess/Handle if ($status === TaskStatus::Suspended->value) { $this->pauseTaskSteps($steps); } elseif ($status === TaskStatus::FINISHED->value) { // UseToolProcess/HandledeviceGenerateOutputContentTool $outputTool = ToolProcessor::generateOutputContentTool($attachments); if ($outputTool !== Null) { $tool = $outputTool; } } // 4. RecordAIMessage $task = $taskContext->getTask(); // Create TaskMessageDTO for AI message $taskMessageDTO = new TaskMessageDTO( taskId: (string) $task->getId(), role: Role::Assistant->value, senderUid: $taskContext->getAgentUserId(), receiverUid: $task->getUserId(), messageType: $messageType, content: $content, status: $status, steps: $steps, tool: $tool, topicId: $task->getTopicId(), event: $event, attachments: $attachments, mentions: Null, showInUi: $showInUi, messageId: $messageId, correlationId: $correlationId, ); $taskMessageEntity = TaskMessageEntity::taskMessageDTOToTaskMessageEntity($taskMessageDTO); $this->taskDomainService->recordTaskMessage($taskMessageEntity); // 5. SendMessage to Client if ($showInUi) { $this->sendMessageToClient( topicId: $task->getTopicId(), taskId: (string) $task->getId(), chatTopicId: $taskContext->getChatTopicId(), chatConversationId: $taskContext->getChatConversationId(), content: $content, messageType: $messageType, status: $status, event: $event, steps: $steps, tool: $tool, attachments: $attachments, correlationId: $correlationId, ); } return true; } catch (Exception $e) { $this->logger->error(sprintf('Process/HandleMessage's overprocessappearAbnormal: %s', $e->getMessage())); return true; } } private function pauseTaskSteps(array &$steps): void { if (empty($steps)) { return; } // ConvertCurrentStepsetForPause foreach ($steps as $key => $step) { if ($step['status'] === TaskStatus::RUNNING->value) { // beforeendPause kind  style  $steps[$key]['status'] = TaskStatus::Suspended->value; } } } private function sendErrorMessageToClient(int $topicId, string $taskId, string $chatTopicId, string $chatConversationId, string $message): void { $this->sendMessageToClient( topicId: $topicId, taskId: $taskId, chatTopicId: $chatTopicId, chatConversationId: $chatConversationId, content: $message, messageType: MessageType::Error->value, status: TaskStatus::ERROR->value, event: '', steps: [], tool: [], attachments: [], correlationId: Null, ); } /** * SendMessage to Client. * * @param int $topicId TopicID * @param string $taskId TaskID * @param string $chatTopicId ChatTopicID * @param string $chatConversationId ChatSessionID * @param string $content MessageContent * @param string $messageType MessageType * @param string $status Status * @param string $event Event * @param Null|array $steps Step * @param Null|array $tool Tool * @param Null|array $attachments Attachment*/ private function sendMessageToClient( int $topicId, string $taskId, string $chatTopicId, string $chatConversationId, string $content, string $messageType, string $status, string $event, ?array $steps = Null, ?array $tool = Null, ?array $attachments = Null, ?string $correlationId = Null, ): void { // CreateMessageObject $message = $this->messageBuilder->createSuperAgentMessage( $topicId, $taskId, $content, $messageType, $status, $event, $steps, $tool, $attachments, $correlationId, ); // CreateSequenceEntity $seqDTO = new DelightfulSeqEntity(); $seqDTO->setObjectType(ConversationType::Ai); $seqDTO->setContent($message); $seqDTO->setSeqType(ChatMessageType::SuperAgentCard); $extra = new SeqExtra(); $extra->setTopicId($chatTopicId); $seqDTO->setExtra($extra); $seqDTO->setConversationId($chatConversationId); $this->logger->info('[Send to Client] Send give ClientMessage: ' . json_encode($message->toArray(), JSON_UNESCAPED_UNICODE)); // SendMessage $this->chatMessageAppService->aiSendMessage($seqDTO, (string) IdGenerator::getSnowId()); } /** * getUploadCredential*/ private function getUploadCredential(string $agentUserId, string $organizationCode, string $workDir): array { /*$userAuthorization = new DelightfulUserAuthorization(); $userAuthorization->setId($agentUserId); $userAuthorization->setOrganizationCode($organizationCode); $userAuthorization->setUserType(UserType::Ai);*/ // sts token temp time set 2 day return $this->fileAppService->getStsTemporaryCredentialV2($organizationCode, 'private', $workDir, 3600 * 2); } /** * getAttachmentURL.*/ private function getAttachmentUrls(string $attachmentsJson, string $organizationCode): array { if (empty($attachmentsJson)) { return []; } $attachments = Json::decode($attachmentsJson); if (empty($attachments)) { return []; } $fileIds = []; foreach ($attachments as $attachment) { $fileId = $attachment['file_id'] ?? ''; if (empty($fileId)) { continue; } $fileIds[] = $fileId; } if (empty($fileIds)) { return []; } $files = []; $fileEntities = $this->chatFileDomainService->getFileEntitiesByFileIds($fileIds, Null, Null, true); foreach ($fileEntities as $fileEntity) { $files[] = [ 'file_extension' => $fileEntity->getFileExtension(), 'file_key' => $fileEntity->getFileKey(), 'file_size' => $fileEntity->getFileSize(), 'filename' => $fileEntity->getFileName(), 'display_filename' => $fileEntity->getFileName(), 'file_tag' => FileType::USER_UPLOAD->value, 'file_url' => $fileEntity->getExternalUrl(), ]; } return $files; } /** * InitializeSandboxEnvironment, getSandboxID. * * @param string $sandboxId Already have SandboxID (If have ) * @return array [bool $needInit, string $sandboxId] thA element elementTableshowwhetherNeedInitializeconfiguration, thtwo each  element elementForSandboxID*/ private function initSandbox(string $sandboxId): array { try { // IfAlready have SandboxID,  first CheckSandboxStatus if (! empty($sandboxId)) { // CheckSandboxwhether store in $result = $this->sandboxService->checkSandboxExists($sandboxId); // RecordSandboxStatus $this->logger->info(sprintf( 'CheckSandboxStatus: sandboxId=%s, code=%d, success=%s, data=%s', $sandboxId, $result->getCode(), $result->isSuccess() ? 'true' : 'false', json_encode($result->getSandboxData()->toArray(), JSON_UNESCAPED_UNICODE) )); // IfSandbox store inandStatusFor running, directlyReturnThisSandbox if ($result->getCode() === SandboxResult::Normal && $result->getSandboxData()->getStatus() === SandboxResult::SandboxRunnig) { $this->logger->info(sprintf('SandboxStatusNormal(running)，directlyUse: sandboxId=%s', $sandboxId)); return [false, $sandboxId]; // No needInitializeConfiguration } // RecordNeedCreate new Sandboxoriginalbecause (DebugUse, No/Nonebusiness logic, Ignorable) if ($result->getCode() === SandboxResult::NotFound) { $this->logger->info(sprintf('SandboxDoes not existin，needCreate new Sandbox: sandboxId=%s', $sandboxId)); } elseif ($result->getCode() === SandboxResult::Normal && $result->getSandboxData()->getStatus() === SandboxResult::SandboxExited) { $this->logger->info(sprintf('SandboxStatusFor exited，needCreate new Sandbox: sandboxId=%s', $sandboxId)); } else { $this->logger->info(sprintf( 'SandboxStatusAbnormal，needCreate new Sandbox: sandboxId=%s, status=%s', $sandboxId, $result->getSandboxData()->getStatus() )); } } else { $this->logger->info('SandboxIDForEmpty，needCreate new Sandbox'); } // Create new Sandbox $struct = new SandboxStruct(); $struct->setSandboxId($sandboxId); $result = $this->sandboxService->create($struct); // RecordCreateResult $this->logger->info(sprintf( 'CreateSandboxResult: code=%d, success=%s, message=%s, data=%s, sandboxId=%s', $result->getCode(), $result->isSuccess() ? 'true' : 'false', $result->getMessage(), json_encode($result->getSandboxData()->toArray(), JSON_UNESCAPED_UNICODE), $result->getSandboxData()->getSandboxId() ?? 'Null' )); // CheckCreateResult if (! $result->isSuccess()) { $this->logger->error(sprintf( 'CreateSandboxFailed: code=%d, message=%s', $result->getCode(), $result->getMessage() )); return [false, '']; // Creation failed } // Created successfully, ReturnNeedInitializeconfiguration return [true, $result->getSandboxData()->getSandboxId()]; } catch (Throwable $e) { $this->logger->error(sprintf( 'SandboxInitializeAbnormal: %s, trace=%s', $e->getMessage(), $e->getTraceAsString() )); return [false, '']; } } /** * UpdateTaskStatus.*/ private function updateTaskStatus( TaskEntity $task, DataIsolation $dataIsolation, string $taskId, TaskStatus $status, string $errMsg = '' ): void { try { // getCurrentTaskStatus enter RowChecksum $currentTask = $this->taskDomainService->getTaskById($task->getId()); $currentStatus = $currentTask?->getStatus(); // UseToolClassValidateStatusConvert if (! TaskStatusValidator::isTransitionAllowed($currentStatus, $status)) { $reason = TaskStatusValidator::getRejectReason($currentStatus, $status); $this->logger->warning('RejectedStatusUpdate', [ 'task_id' => $taskId, 'current_status' => $currentStatus->value ?? Null, 'new_status' => $status->value, 'reason' => $reason, 'error_msg' => $errMsg, ]); return; // silentRejectedUpdate } // ExecuteStatusUpdate $this->taskDomainService->updateTaskStatus( status: $status, id: $task->getId(), taskId: $taskId, sandboxId: $task->getSandboxId(), errMsg: $errMsg ); // RecordSuccessLog $this->logger->info('TaskStatusUpdateComplete', [ 'task_id' => $taskId, 'previous_status' => $currentStatus->value ?? Null, 'new_status' => $status->value, 'error_msg' => $errMsg, ]); } catch (Throwable $e) { $this->logger->error('UpdateTaskStatusFailed', [ 'task_id' => $taskId, 'status' => $status->value, 'error' => $e->getMessage(), 'error_msg' => $errMsg, ]); throw $e; } } /** * JudgewhetherFor fatalError. * * @param Throwable $e AbnormalObject * @return bool whetherFor fatalError*/ private function isFatalError(Throwable $e): bool { // ConnectError、Insufficient memory、TimeoutwaitallviewFor fatalError $errorMessage = strtolower($e->getMessage()); return $e instanceof Error // PHPfatalError || str_contains($errorMessage, 'memory') || str_contains($errorMessage, 'timeout') || str_contains($errorMessage, 'socket') || str_contains($errorMessage, 'closed'); } /** * Process/HandleTool in Attachment, ConvertitsSave to TaskFileTableAndChatFileTable in .*/ private function processToolAttachments(?array &$tool, TaskContext $taskContext): void { if (empty($tool)) { return; } $task = $taskContext->getTask(); $dataIsolation = $taskContext->getDataIsolation(); // Process/HandleToolContentstored to Objectstored $this->processToolContentStorage($tool, $taskContext); // Process/HandleToolAttachment if (! empty($tool['attachments'])) { foreach ($tool['attachments'] as $i => $iValue) { $tool['attachments'][$i] = $this->processSingleAttachment( $iValue, $task, $dataIsolation ); } } } /** * Process/HandleToolContentstored to Objectstored. * * @param array $tool ToolArray (ReferencePass) * @param TaskContext $taskContext Taskcontext*/ private function processToolContentStorage(array &$tool, TaskContext $taskContext): void { // CheckwhetherEnableObjectstored $objectStorageEnabled = config('super-magic.task.tool_message.object_storage_enabled', true); if (! $objectStorageEnabled) { return; } // CheckToolContent $content = $tool['detail']['data']['content'] ?? ''; if (empty($content)) { return; } // CheckContentLengthwhetherreach to thresholdValue $minContentLength = config('super-magic.task.tool_message.min_content_length', 200); if (strlen($content) < $minContentLength) { return; } $this->logger->info(sprintf( 'StartProcess/HandleToolContentStorage，ToolID: %s，ContentLength: %d', $tool['id'] ?? 'unknown', strlen($content) )); try { // BuildParameter $fileName = $tool['detail']['data']['file_name'] ?? 'tool_content.txt'; $fileExtension = pathinfo($fileName, PATHINFO_EXTENSION) ?: 'txt'; $fileKey = ($tool['id'] ?? 'unknown') . '.' . $fileExtension; $task = $taskContext->getTask(); $workDir = rtrim($task->getWorkdir(), '/') . '/task_' . $task->getId() . '/.chat/'; // callFileProcessAppServiceSaveContent $fileId = $this->fileProcessAppService->saveToolMessageContent( fileName: $fileName, workDir: $workDir, fileKey: $fileKey, content: $content, dataIsolation: $taskContext->getDataIsolation(), projectId: $task->getProjectId(), topicId: $task->getTopicId(), taskId: (int) $task->getId() ); // ModifyToolDatastructure $tool['detail']['data']['file_id'] = (string) $fileId; $tool['detail']['data']['content'] = ''; // clearEmptyContent $tool['detail']['data']['file_extension'] = $fileExtension; $this->logger->info(sprintf( 'ToolContentStorageComplete，ToolID: %s，FileID: %d，originalContentLength: %d', $tool['id'] ?? 'unknown', $fileId, strlen($content) )); } catch (Throwable $e) { $this->logger->error(sprintf( 'ToolContentStorageFailed: %s，ToolID: %s，ContentLength: %d', $e->getMessage(), $tool['id'] ?? 'unknown', strlen($content) )); // storedFailedNot affect mainProcess,  only RecordError } } private function processMessageAttachments(?array &$attachments, TaskContext $taskContext): void { if (empty($attachments)) { return; } $task = $taskContext->getTask(); $dataIsolation = $taskContext->getDataIsolation(); foreach ($attachments as $i => $iValue) { $attachments[$i] = $this->processSingleAttachment( $iValue, $task, $dataIsolation ); } } /** * Process/Handlesingle each Attachment, Save to TaskFileTableAndChatFileTable in . * * @param array $attachment Attachmentinformation * @param TaskEntity $task TaskEntity * @param DataIsolation $dataIsolation DataIsolationObject * @return array Process/Handle after Attachmentinformation*/ private function processSingleAttachment(array $attachment, TaskEntity $task, DataIsolation $dataIsolation): array { // CheckMustfield if (empty($attachment['file_key']) || empty($attachment['file_extension']) || empty($attachment['filename'])) { $this->logger->warning(sprintf( 'AttachmentInformationIncomplete，SkipProcess/Handle，TaskID: %s，AttachmentContent: %s', $task->getTaskId(), json_encode($attachment, JSON_UNESCAPED_UNICODE | JSON_UNESCAPED_SLASHES) )); return []; } try { // directlycallFileProcessAppServiceProcess/HandleAttachment [$fileId, $taskFileEntity] = $this->fileProcessAppService->processFileByFileKey( $attachment['file_key'], $dataIsolation, $attachment, $task->getProjectId(), $task->getTopicId(), (int) $task->getId(), $attachment['file_tag'] ?? FileType::PROCESS->value ); // SaveFileID to Attachmentinformation in  $attachment['file_id'] = (string) $fileId; $this->logger->info(sprintf( 'AttachmentSaved successfully，FileID: %s，TaskID: %s，Filename: %s', $fileId, $task->getTaskId(), $attachment['filename'] )); } catch (Throwable $e) { $this->logger->error(sprintf( 'Process/HandleAttachmentAbnormal: %s, AttachmentName: %s, TaskID: %s', $e->getMessage(), $attachment['filename'] ?? 'Unknown', $task->getTaskId() )); } return $attachment; } /** * fromWebSocketReceivedMessageConvert tounifiedMessageformat. * * @param array $message WebSocketReceivedMessage * @return TopicTaskMessageDTO unifiedMessageDTO*/ private function convertWebSocketMessageToDTO(array $message): TopicTaskMessageDTO { // Build element DataValueObject $metadata = MessageMetadata::fromArray($message['metadata'] ?? []); // CreateloadValueObject $payload = MessagePayload::fromArray($message['payload'] ?? []); // CreateDTO return new TopicTaskMessageDTO($metadata, $payload); } } 