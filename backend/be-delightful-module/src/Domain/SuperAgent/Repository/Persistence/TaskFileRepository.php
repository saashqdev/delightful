<?php declare(strict_types=1); /** * Copyright (c) Be Delightful , Distributed under the MIT software license */ namespace Delightful\BeDelightful\Domain\BeAgent\Repository\Persistence; use App\Domain\Contact\Entity\ValueObject\DataIsolation; use App\Infrastructure\Util\IdGenerator\IdGenerator; use Delightful\BeDelightful\Domain\BeAgent\Entity\TaskFileEntity; use Delightful\BeDelightful\Domain\BeAgent\Entity\ValueObject\StorageType; use Delightful\BeDelightful\Domain\BeAgent\Repository\Facade\TaskFileRepositoryInterface; use Delightful\BeDelightful\Domain\BeAgent\Repository\Model\TaskFileModel; use Hyperf\DbConnection\Db; class TaskFileRepository implements TaskFileRepositoryInterface { public function __construct(protected TaskFileModel $model) { } public function getById(int $id): ?TaskFileEntity { $model = $this->model::query()->where('file_id', $id)->first(); if (! $model) { return Null; } return new TaskFileEntity($model->toArray()); } public function getFilesByIds(array $fileIds, int $projectId = 0): array { $query = $this->model::query()->whereIn('file_id', $fileIds); if ($projectId > 0) { $query->where('project_id', $projectId); } $models = $query->get(); $list = []; foreach ($models as $model) { $list[] = new TaskFileEntity($model->toArray()); } return $list; } /** * @return TaskFileEntity[] */ public function getTaskFilesByIds(array $ids, int $projectId = 0): array { if (empty($ids)) { return []; } $query = $this->model::query()->whereIn('file_id', $ids); if ($projectId > 0) { $query = $query->where('project_id', $projectId); } $models = $query->get(); $entities = []; foreach ($models as $model) { $entities[] = new TaskFileEntity($model->toArray()); } return $entities; } /** * By/According tofileKeygetFile. * * @param string $fileKey FileKey * @param Null|int $topicId TopicID, defaultFor0 * @param bool $withTrash whethercontaining already DeleteFile, defaultForfalse*/ public function getByFileKey(string $fileKey, ?int $topicId = 0, bool $withTrash = false): ?TaskFileEntity { // By/According towithTrashParameterDecideQueryrange if ($withTrash) { $query = $this->model::withTrashed(); } else { $query = $this->model::query(); } $query = $query->where('file_key', $fileKey); if ($topicId) { $query = $query->where('topic_id', $topicId); } $model = $query->first(); if (! $model) { return Null; } return new TaskFileEntity($model->toArray()); } /** * By/According tofileKeyArrayBatchgetFile.*/ public function getByFileKeys(array $fileKeys): array { if (empty($fileKeys)) { return []; } $models = $this->model::query() ->whereIn('file_key', $fileKeys) ->get(); $entities = []; foreach ($models as $model) { $entity = new TaskFileEntity($model->toArray()); $entities[$entity->getFileKey()] = $entity; } return $entities; } /** * By/According toProject IDAndfileKeygetFile.*/ public function getByProjectIdAndFileKey(int $projectId, string $fileKey): ?TaskFileEntity { $model = $this->model::query() ->where('project_id', $projectId) ->where('file_key', $fileKey) ->first(); if (! $model) { return Null; } return new TaskFileEntity($model->toArray()); } /** * By/According toTopicIDgetFilelist. * * @param int $topicId TopicID * @param int $page Page number * @param int $pageSize Per pageQuantity * @param array $fileType File typeFilter * @param string $storageType storedType * @return array{list: TaskFileEntity[], total: int} FilelistAndTotal*/ public function getByTopicId(int $topicId, int $page, int $pageSize = 200, array $fileType = [], string $storageType = 'workspace'): array { $offset = ($page - 1) * $pageSize; // BuildQuery $query = $this->model::query()->where('topic_id', $topicId); // Ifspecified ed File typeArrayAnd not beEmpty, addFile typeFilterCondition if (! empty($fileType)) { $query->whereIn('file_type', $fileType); } // Ifspecified ed storedType, addstoredTypeFilterCondition if (! empty($storageType)) { $query->where('storage_type', $storageType); } // Filter already through be Delete, deleted_at Not beEmpty $query->whereNull('deleted_at'); //  first getTotal $total = $query->count(); // getPaginationData, UseEloquentget()method let $caststake effect,  by HierarchyAndSort fieldSort $models = $query->skip($offset) ->take($pageSize) ->orderBy('parent_id', 'ASC') // By parentDirectoryGroup ->orderBy('sort', 'ASC') //  by SortValueSort ->orderBy('file_id', 'ASC') // SortValueSame time  by IDSort ->get(); $list = []; foreach ($models as $model) { $list[] = new TaskFileEntity($model->toArray()); } return [ 'list' => $list, 'total' => $total, ]; } /** * By/According toProject IDgetFilelist. * * @param int $projectId Project ID * @param int $page Page number * @param int $pageSize Per pageQuantity * @param array $fileType File typeFilter * @param string $storageType storedTypeFilter * @param Null|string $updatedAfter Updated atFilter (QuerythisTimeAfterUpdateFile) * @return array{list: TaskFileEntity[], total: int} FilelistAndTotal*/ public function getByProjectId(int $projectId, int $page, int $pageSize = 200, array $fileType = [], string $storageType = '', ?string $updatedAfter = Null): array { $offset = ($page - 1) * $pageSize; // BuildQuery $query = $this->model::query()->where('project_id', $projectId); // Ifspecified ed File typeArrayAnd not beEmpty, addFile typeFilterCondition if (! empty($fileType)) { $query->whereIn('file_type', $fileType); } // Ifspecified ed storedType, addstoredTypeFilterCondition if (! empty($storageType)) { $query->where('storage_type', $storageType); } // Ifspecified ed Updated atFilter, addTimeFilterCondition (Data database GradeFilter) if ($updatedAfter !== Null) { $query->where('updated_at', '>', $updatedAfter); } // Filter already through be Delete, deleted_at Not beEmpty $query->whereNull('deleted_at'); //  first getTotal $total = $query->count(); // getPaginationData, UseEloquentget()method let $caststake effect,  by HierarchyAndSort fieldSort $models = $query->skip($offset) ->take($pageSize) ->orderBy('parent_id', 'ASC') // By parentDirectoryGroup ->orderBy('sort', 'ASC') //  by SortValueSort ->orderBy('file_id', 'ASC') // SortValueSame time  by IDSort ->get(); $list = []; foreach ($models as $model) { $list[] = new TaskFileEntity($model->toArray()); } return [ 'list' => $list, 'total' => $total, ]; } /** * By/According toTaskIDgetFilelist. * * @param int $taskId TaskID * @param int $page Page number * @param int $pageSize Per pageQuantity * @return array{list: TaskFileEntity[], total: int} FilelistAndTotal*/ public function getByTaskId(int $taskId, int $page, int $pageSize): array { $offset = ($page - 1) * $pageSize; //  first getTotal $total = $this->model::query() ->where('task_id', $taskId) ->count(); // getPaginationData, UseEloquentget()method let $caststake effect $models = $this->model::query() ->where('task_id', $taskId) ->skip($offset) ->take($pageSize) ->orderBy('file_id', 'desc') ->get(); $list = []; foreach ($models as $model) { $list[] = new TaskFileEntity($model->toArray()); } return [ 'list' => $list, 'total' => $total, ]; } /** * ForKeepBackwardCompatibility, Provide thismethod. * @deprecated Use getByTopicId And getByTaskId Instead*/ public function getByTopicTaskId(int $topicTaskId, int $page, int $pageSize): array { // byinDatastructureChange, thismethodNo moredirectlysuitableuse // ForKeepBackwardCompatible, CantryFindRelatedData // HereImplementationA simpleEmptyResult return [ 'list' => [], 'total' => 0, ]; } public function insert(TaskFileEntity $entity): TaskFileEntity { $date = date('Y-m-d H:i:s'); $entity->setCreatedAt($date); $entity->setUpdatedAt($date); $entityArray = $entity->toArray(); $model = $this->model::query()->create($entityArray); // setData database GenerateID if (! empty($model->file_id)) { $entity->setFileId($entity->getFileId()); } return $entity; } /** * InsertFile, If store inIgnore on conflict. * By/According tofile_keyAndtopic_idJudgewhether store inConflict*/ public function insertOrIgnore(TaskFileEntity $entity): ?TaskFileEntity { // first first Checkwhether already through store inSamefile_keyAndtopic_idRecord $existingEntity = $this->model::query() ->where('file_key', $entity->getFileKey()) ->first(); // IfAlready existsinRecord,  then ReturnAlready existsinEntity if ($existingEntity) { return new TaskFileEntity($existingEntity->toArray()); } // Does not existin then Create new Record $date = date('Y-m-d H:i:s'); if (empty($entity->getFileId())) { $entity->setFileId(IdGenerator::getSnowId()); } $entity->setCreatedAt($date); $entity->setUpdatedAt($date); $entityArray = $entity->toArray(); $this->model::query()->create($entityArray); return $entity; } /** * Insert or UpdateFile. * Use INSERT... ON DUPLICATE KEY UPDATE language method  * when file_key UniqueIndexOn conflictUpdateExistingRecord, OtherwiseInsert new Record. * * MainUsed forsolvehighConcurrentScenario next UniqueKeyConflictissue: * - Business layer firstQueryDoes not existin * - butinInsertbefore, Otherthread already throughInsert ed Same file_key * - this time Use upsert avoidUniqueKeyConflictError report*/ public function insertOrUpdate(TaskFileEntity $entity): TaskFileEntity { $date = date('Y-m-d H:i:s'); // PrepareInsertData if (empty($entity->getFileId())) { $entity->setFileId(IdGenerator::getSnowId()); } if (empty($entity->getCreatedAt())) { $entity->setCreatedAt($date); } $entity->setUpdatedAt($date); $entityArray = $entity->toArray(); // Use Hyperf upsert method // ththreeParameterexplicitExclude file_id And created_at, Ensure it  them  not will be Update $affectedRows = $this->model::query()->upsert( [$entityArray], // Data ['file_key'], // Based on file_key UniqueIndexJudgeConflict array_values(array_diff( // explicitSpecifiedwantUpdate's Field array_keys($entityArray), ['file_id', 'file_key', 'created_at'] // ExcludePrimary key、UniqueKey、Created at )) ); // Process/HandleConcurrentConflictSituation // MySQL upsert affected rows: // 1 = InsertNewRecord (NormalSituation) // 2 = Update ed Already existsinRecord (ConcurrentConflict) // 0 = AllfieldValueSame,  un ActualUpdate (extremefewsee) if ($affectedRows !== 1) { // happen ed ConcurrentConflict, NeedgetData database  in Trueactual file_id And created_at $record = $this->model::query() ->where('file_key', $entity->getFileKey()) ->first(); if ($record) { $entity->setFileId($record->file_id); $entity->setCreatedAt($record->created_at); } } return $entity; } public function updateById(TaskFileEntity $entity): TaskFileEntity { $entity->setUpdatedAt(date('Y-m-d H:i:s')); $entityArray = $entity->toArray(); $this->model::query() ->where('file_id', $entity->getFileId()) ->update($entityArray); return $entity; } public function updateFileByCondition(array $condition, array $data): bool { return $this->model::query() ->where($condition) ->update($data) > 0; } public function deleteById(int $id, bool $forceDelete = true): void { $query = $this->model::query()->where('file_id', $id); if ($forceDelete) { $query->forceDelete(); } else { $query->delete(); } } /** * By/According to file_key And project_id DeleteFile (PhysicalDelete).*/ public function deleteByFileKeyAndProjectId(string $fileKey, int $projectId): int { $result = $this->model::query()->where('file_key', $fileKey)->where('project_id', $projectId)->forceDelete(); return $result ?? 0; } public function getByFileKeyAndSandboxId(string $fileKey, int $sandboxId): ?TaskFileEntity { $model = $this->model::query() ->where('file_key', $fileKey) ->where('sandbox_id', $sandboxId) ->first(); if (! $model) { return Null; } return new TaskFileEntity($model->toArray()); } /** * By/According toFileIDArrayAndUser IDBatchgetuserFile. * * @param array $fileIds FileIDArray * @param string $userId User ID * @return TaskFileEntity[] userFilelist*/ public function findUserFilesByIds(array $fileIds, string $userId): array { if (empty($fileIds)) { return []; } // QueryattributeinspecifieduserFile $models = $this->model::query() ->whereIn('file_id', $fileIds) ->where('user_id', $userId) ->whereNull('deleted_at') // Filter already Delete's File ->orderBy('file_id', 'desc') ->get(); $entities = []; foreach ($models as $model) { $entities[] = new TaskFileEntity($model->toArray()); } return $entities; } public function findUserFilesByTopicId(string $topicId): array { $models = $this->model::query() ->where('topic_id', $topicId) ->where('is_hidden', 0) ->whereNull('deleted_at') // Filter already Delete's File ->orderBy('file_id', 'desc') ->limit(1000) ->get(); $entities = []; foreach ($models as $model) { $entities[] = new TaskFileEntity($model->toArray()); } return $entities; } public function findUserFilesByProjectId(string $projectId): array { $models = $this->model::query() ->where('project_id', $projectId) ->where('is_hidden', 0) ->whereNull('deleted_at') // Filter already Delete's File ->orderBy('file_id', 'desc') ->limit(1000) ->get(); $entities = []; foreach ($models as $model) { $entities[] = new TaskFileEntity($model->toArray()); } return $entities; } /** * @return array|TaskFileEntity[] */ public function findFilesByProjectIdAndIds(int $projectId, array $fileIds): array { $models = $this->model::query() ->where('project_id', $projectId) ->whereIn('file_id', $fileIds) ->whereNull('deleted_at') // Filter already Delete's File ->orderBy('file_id', 'desc') ->get(); $entities = []; foreach ($models as $model) { $entities[] = new TaskFileEntity($model->toArray()); } return $entities; } /** * By/According toProject IDgetAllFilefile_keylist (highPerformanceQuery).*/ public function getFileKeysByProjectId(int $projectId, int $limit = 1000): array { $query = $this->model::query() ->select(['file_key']) ->where('project_id', $projectId) ->whereNull('deleted_at') ->limit($limit); return $query->pluck('file_key')->toArray(); } /** * BatchInsert new FileRecord.*/ public function batchInsertFiles(DataIsolation $dataIsolation, int $projectId, array $newFileKeys, array $objectStorageFiles = []): void { if (empty($newFileKeys)) { return; } $insertData = []; $now = date('Y-m-d H:i:s'); foreach ($newFileKeys as $fileKey) { // fromObjectstoredFileinformationget fromdetailedinformation $fileInfo = $objectStorageFiles[$fileKey] ?? []; $insertData[] = [ 'file_id' => IdGenerator::getSnowId(), 'user_id' => $dataIsolation->getCurrentUserId(), 'organization_code' => $dataIsolation->getCurrentOrganizationCode(), 'project_id' => $projectId, 'topic_id' => 0, 'task_id' => 0, 'file_key' => $fileKey, 'file_name' => $fileInfo['file_name'] ?? basename($fileKey), 'file_extension' => $fileInfo['file_extension'] ?? pathinfo($fileKey, PATHINFO_EXTENSION), 'file_type' => 'auto_sync', 'file_size' => $fileInfo['file_size'] ?? 0, 'storage_type' => 'workspace', 'is_hidden' => false, 'created_at' => $now, 'updated_at' => $now, ]; } // UseBatchInsertEnhancePerformance $this->model::query()->insert($insertData); } /** * BatchMarkFileFor alreadyDelete.*/ public function batchMarkAsDeleted(array $deletedFileKeys): void { if (empty($deletedFileKeys)) { return; } $this->model::query() ->whereIn('file_key', $deletedFileKeys) ->whereNull('deleted_at') ->update([ 'deleted_at' => date('Y-m-d H:i:s'), 'updated_at' => date('Y-m-d H:i:s'), ]); } /** * BatchUpdateFileinformation.*/ public function batchUpdateFiles(array $updatedFileKeys): void { if (empty($updatedFileKeys)) { return; } // Simplified implementation:  only UpdateModifyTime $this->model::query() ->whereIn('file_key', $updatedFileKeys) ->whereNull('deleted_at') ->update([ 'updated_at' => date('Y-m-d H:i:s'), ]); } /** * By/According toDirectoryPathFindFilelist.*/ public function findFilesByDirectoryPath(int $projectId, string $directoryPath, int $limit = 1000): array { $models = $this->model::query() ->where('project_id', $projectId) ->where('file_key', 'like', $directoryPath . '%') ->whereNull('deleted_at') ->limit($limit) ->get(); $list = []; foreach ($models as $model) { $list[] = new TaskFileEntity($model->toArray()); } return $list; } /** * By/According to parent_id And project_id FindsubFilelist. * thisQuerywillUseIndex: idx_project_parent_sort (project_id, parent_id, sort, file_id).*/ public function getChildrenByParentAndProject(int $projectId, int $parentId, int $limit = 500): array { $models = $this->model::query() ->where('project_id', $projectId) ->where('parent_id', $parentId) ->whereNull('deleted_at') ->limit($limit) ->get(); $list = []; foreach ($models as $model) { $list[] = new TaskFileEntity($model->toArray()); } return $list; } /** * BatchQueryMultipleparentDirectorysubFile (Use IN Query, avoid N+1 issue). * Use idx_project_parent_sort Index. * * @param int $projectId Project ID * @param array $parentIds parentDirectoryIDArray * @param int $limit Limit quantity * @return TaskFileEntity[] FileEntitylist*/ public function getChildrenByParentIdsAndProject(int $projectId, array $parentIds, int $limit = 1000): array { if (empty($parentIds)) { return []; } $models = $this->model::query() ->where('project_id', $projectId) ->whereIn('parent_id', $parentIds) ->whereNull('deleted_at') ->limit($limit) ->get(); $list = []; foreach ($models as $model) { $list[] = new TaskFileEntity($model->toArray()); } return $list; } /** * BatchUpdateFile file_key. * Use CASE WHEN languagesentenceImplementationOne-timeBatchUpdate. * * @param array $updateBatch [['file_id' => 1, 'file_key' => 'new/path', 'updated_at' => '...'],...] * @return int UpdateFileQuantity*/ public function batchUpdateFileKeys(array $updateBatch): int { if (empty($updateBatch)) { return 0; } $fileIds = array_column($updateBatch, 'file_id'); // Build CASE WHEN languagesentenceAndBindParameter (correctSequential) $fileKeyCases = []; $updatedAtCases = []; $fileKeyBindings = []; $updatedAtBindings = []; foreach ($updateBatch as $item) { $fileKeyCases[] = 'WHEN ? THEN ?'; $updatedAtCases[] = 'WHEN ? THEN ?'; // file_key Parameter $fileKeyBindings[] = $item['file_id']; $fileKeyBindings[] = $item['file_key']; // updated_at Parameter $updatedAtBindings[] = $item['file_id']; $updatedAtBindings[] = $item['updated_at']; } $fileKeyCasesSql = implode(' ', $fileKeyCases); $updatedAtCasesSql = implode(' ', $updatedAtCases); // Build SQL (According to correctSequentialMergeParameter) $sql = sprintf( 'UPDATE %s SET file_key = CASE file_id %s END, updated_at = CASE file_id %s END WHERE file_id IN (%s)', $this->model->getTable(), $fileKeyCasesSql, $updatedAtCasesSql, implode(',', array_fill(0, count($fileIds), '?')) ); // correctParameterSequential:  first  file_key CASE, again updated_at CASE,  most  after  is  WHERE IN $bindings = array_merge($fileKeyBindings, $updatedAtBindings, $fileIds); return Db::update($sql, $bindings); } /** * BatchDeleteFile (PhysicalDelete).*/ public function deleteByIds(array $fileIds): void { if (empty($fileIds)) { return; } $this->model::query() ->whereIn('file_id', $fileIds) ->forceDelete(); } /** * By/According toFileKeysBatchDeleteFile (PhysicalDelete).*/ public function deleteByFileKeys(array $fileKeys): void { if (empty($fileKeys)) { return; } $this->model::query() ->whereIn('file_key', $fileKeys) ->forceDelete(); } /** * getspecifiedparentDirectoryMinimum underSortValue.*/ public function getMinSortByParentId(?int $parentId, int $projectId): ?int { $query = $this->model::query() ->where('project_id', $projectId) ->whereNull('deleted_at'); if ($parentId === Null) { $query->whereNull('parent_id'); } else { $query->where('parent_id', $parentId); } return $query->min('sort'); } /** * getspecifiedparentDirectoryMaximum underSortValue.*/ public function getMaxSortByParentId(?int $parentId, int $projectId): ?int { $query = $this->model::query() ->where('project_id', $projectId) ->whereNull('deleted_at'); if ($parentId === Null) { $query->whereNull('parent_id'); } else { $query->where('parent_id', $parentId); } return $query->max('sort'); } /** * getspecifiedFileSortValue.*/ public function getSortByFileId(int $fileId): ?int { return $this->model::query() ->where('file_id', $fileId) ->whereNull('deleted_at') ->value('sort'); } /** * getspecifiedSortValueNext afterSortValue.*/ public function getNextSortAfter(?int $parentId, int $currentSort, int $projectId): ?int { $query = $this->model::query() ->where('project_id', $projectId) ->where('sort', '>', $currentSort) ->whereNull('deleted_at'); if ($parentId === Null) { $query->whereNull('parent_id'); } else { $query->where('parent_id', $parentId); } return $query->min('sort'); } /** * getSame parentDirectory next AllSibling node.*/ public function getSiblingsByParentId(?int $parentId, int $projectId, string $orderBy = 'sort', string $direction = 'ASC'): array { $query = $this->model::query() ->where('project_id', $projectId) ->whereNull('deleted_at'); if ($parentId === Null) { $query->whereNull('parent_id'); } else { $query->where('parent_id', $parentId); } return $query->orderBy($orderBy, $direction)->get()->toArray(); } public function getSiblingCountByParentId(int $parentId, int $projectId): int { return $this->model::query() ->where('project_id', $projectId) ->where('parent_id', $parentId) ->whereNull('deleted_at') ->count(); } /** * BatchUpdateSortValue.*/ public function batchUpdateSort(array $updates): void { if (empty($updates)) { return; } foreach ($updates as $update) { $this->model::query() ->where('file_id', $update['file_id']) ->update(['sort' => $update['sort'], 'updated_at' => date('Y-m-d H:i:s')]); } } /** * Batch bind files to project with parent directory. * Updates both project_id and parent_id atomically. */ public function batchBindToProject(array $fileIds, int $projectId, int $parentId): int { if (empty($fileIds)) { return 0; } return $this->model::query() ->whereIn('file_id', $fileIds) ->where(function ($query) { $query->whereNull('project_id') ->orWhere('project_id', 0); }) ->update([ 'project_id' => $projectId, 'parent_id' => $parentId, 'updated_at' => date('Y-m-d H:i:s'), ]); } public function findLatestUpdatedByProjectId(int $projectId): ?TaskFileEntity { $model = $this->model::query() ->withTrashed() ->where('project_id', $projectId) ->orderBy('updated_at', 'desc') ->first(); if (! $model) { return Null; } return new TaskFileEntity($model->toArray()); } /** * Count files by project ID. */ public function countFilesByProjectId(int $projectId): int { return $this->model::query() ->where('project_id', $projectId) ->where('storage_type', StorageType::WORKSPACE->value) ->where('is_hidden', false) ->whereNull('deleted_at') ->count(); } /** * Get files by project ID with resume support. * Used for fork migration with pagination and resume capability. */ public function getFilesByProjectIdWithResume(int $projectId, ?int $lastFileId, int $limit): array { $query = $this->model::query() ->where('project_id', $projectId) ->where('storage_type', StorageType::WORKSPACE->value) ->where('is_hidden', false) ->whereNull('deleted_at') ->orderBy('file_id', 'asc') ->limit($limit); // Support resume from last file ID if ($lastFileId !== Null) { $query->where('file_id', '>', $lastFileId); } $models = $query->get(); $entities = []; foreach ($models as $model) { $entities[] = new TaskFileEntity($model->toArray()); } return $entities; } /** * Batch update parent_id for multiple files. * Used for fixing parent relationships during fork operations. */ public function batchUpdateParentId(array $fileIds, int $parentId, string $userId): int { if (empty($fileIds)) { return 0; } return $this->model::query() ->whereIn('file_id', $fileIds) ->whereNull('deleted_at') ->update([ 'parent_id' => $parentId, 'updated_at' => date('Y-m-d H:i:s'), ]); } public function lockDirectChildrenForUpdate(int $parentId): array { return $this->model::query() ->where('parent_id', $parentId) ->orderBy('sort', 'ASC') ->orderBy('file_id', 'ASC') ->lockForUpdate() ->get() ->toArray(); } public function getAllChildrenByParentId(int $parentId): array { return $this->model::query() ->where('parent_id', $parentId) ->orderBy('sort', 'ASC') ->orderBy('file_id', 'ASC') ->get() ->toArray(); } /** * Recover beingDeleteFile.*/ public function restoreFile(int $fileId): void { $this->model::withTrashed() ->where('file_id', $fileId) ->restore(); } } 