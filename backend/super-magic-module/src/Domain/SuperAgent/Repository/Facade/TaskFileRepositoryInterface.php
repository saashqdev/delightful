<?php declare(strict_types=1); /** * Copyright (c) Be Delightful , Distributed under the MIT software license */ namespace Delightful\SuperMagic\Domain\SuperAgent\Repository\Facade; use App\Domain\Contact\Entity\ValueObject\DataIsolation; use Dtyq\SuperMagic\Domain\SuperAgent\Entity\TaskFileEntity; interface TaskFileRepositoryInterface { /** * By/According toIDgetFile.*/ public function getById(int $id): ?TaskFileEntity; /** * By/According toIDBatchgetFile. * @return TaskFileEntity[]*/ public function getFilesByIds(array $fileIds, int $projectId = 0): array; /** * By/According toIDBatchgetFile. * @return TaskFileEntity[]*/ public function getTaskFilesByIds(array $ids, int $projectId = 0): array; /** * By/According tofileKeygetFile. * * @param string $fileKey FileKey * @param Null|int $topicId TopicID, defaultFor0 * @param bool $withTrash whethercontaining already DeleteFile, defaultForfalse*/ public function getByFileKey(string $fileKey, ?int $topicId = 0, bool $withTrash = false): ?TaskFileEntity; /** * By/According tofileKeyArrayBatchgetFile. * * @param array $fileKeys FileKeyArray * @return TaskFileEntity[] FileEntityArray, byfile_keyForKey*/ public function getByFileKeys(array $fileKeys): array; /** * By/According toProject IDAndfileKeygetFile.*/ public function getByProjectIdAndFileKey(int $projectId, string $fileKey): ?TaskFileEntity; /** * By/According toTopicIDgetFilelist. * * @param int $topicId TopicID * @param int $page Page number * @param int $pageSize Per pageQuantity * @param array $fileType File typeFilter * @param string $storageType storedType * @return array{list: TaskFileEntity[], total: int} FilelistAndTotal*/ public function getByTopicId(int $topicId, int $page, int $pageSize, array $fileType = [], string $storageType = 'workspace'): array; /** * By/According toProject IDgetFilelist. * * @param int $projectId Project ID * @param int $page Page number * @param int $pageSize Per pageQuantity * @param array $fileType File typeFilter * @param string $storageType storedTypeFilter * @param Null|string $updatedAfter Updated atFilter (QuerythisTimeAfterUpdateFile) * @return array{list: TaskFileEntity[], total: int} FilelistAndTotal*/ public function getByProjectId(int $projectId, int $page, int $pageSize = 200, array $fileType = [], string $storageType = '', ?string $updatedAfter = Null): array; /** * By/According toTaskIDgetFilelist. * * @param int $taskId TaskID * @param int $page Page number * @param int $pageSize Per pageQuantity * @return array{list: TaskFileEntity[], total: int} FilelistAndTotal*/ public function getByTaskId(int $taskId, int $page, int $pageSize): array; /** * By/According toTopicTaskIDgetFilelist. * * @param int $topicTaskId TopicTaskID * @param int $page Page number * @param int $pageSize Per pageQuantity * @return array{list: TaskFileEntity[], total: int} FilelistAndTotal * @deprecated Use getByTopicId And getByTaskId methodreplace*/ public function getByTopicTaskId(int $topicTaskId, int $page, int $pageSize): array; /** * InsertFile.*/ public function insert(TaskFileEntity $entity): TaskFileEntity; /** * InsertFile, If store inIgnore on conflict. * By/According tofile_keyAndtopic_idJudgewhether store inConflict*/ public function insertOrIgnore(TaskFileEntity $entity): ?TaskFileEntity; /** * Insert or UpdateFile. * Use INSERT... ON DUPLICATE KEY UPDATE language method  * when file_key On conflictUpdateExistingRecord, OtherwiseInsert new Record. * * @param TaskFileEntity $entity FileEntity * @return TaskFileEntity Insert or Update after FileEntity*/ public function insertOrUpdate(TaskFileEntity $entity): TaskFileEntity; /** * UpdateFile.*/ public function updateById(TaskFileEntity $entity): TaskFileEntity; /** * Delete file by ID. * * @param int $id File ID * @param bool $forceDelete Whether to force delete (hard delete), default true */ public function deleteById(int $id, bool $forceDelete = true): void; public function deleteByFileKeyAndProjectId(string $fileKey, int $projectId): int; /** * By/According toFileIDArrayAndUser IDBatchgetuserFile. * * @param array $fileIds FileIDArray * @param string $userId User ID * @return TaskFileEntity[] userFilelist*/ public function findUserFilesByIds(array $fileIds, string $userId): array; public function findUserFilesByTopicId(string $topicId): array; public function findUserFilesByProjectId(string $projectId): array; /** * @return TaskFileEntity[] userFilelist*/ public function findFilesByProjectIdAndIds(int $projectId, array $fileIds): array; /** * By/According toProject IDgetAllFilefile_keylist (highPerformanceQuery).*/ public function getFileKeysByProjectId(int $projectId, int $limit = 1000): array; /** * BatchInsert new FileRecord.*/ public function batchInsertFiles(DataIsolation $dataIsolation, int $projectId, array $newFileKeys, array $objectStorageFiles = []): void; /** * BatchMarkFileFor alreadyDelete.*/ public function batchMarkAsDeleted(array $deletedFileKeys): void; /** * getspecifiedparentDirectoryMinimum underSortValue.*/ public function getMinSortByParentId(?int $parentId, int $projectId): ?int; /** * getspecifiedparentDirectoryMaximum underSortValue.*/ public function getMaxSortByParentId(?int $parentId, int $projectId): ?int; /** * getspecifiedFileSortValue.*/ public function getSortByFileId(int $fileId): ?int; /** * getspecifiedSortValueNext afterSortValue.*/ public function getNextSortAfter(?int $parentId, int $currentSort, int $projectId): ?int; /** * getSame parentDirectory next AllSibling node.*/ public function getSiblingsByParentId(?int $parentId, int $projectId, string $orderBy = 'sort', string $direction = 'ASC'): array; public function getSiblingCountByParentId(int $parentId, int $projectId): int; /** * BatchUpdateSortValue.*/ public function batchUpdateSort(array $updates): void; /** * BatchUpdateFileinformation.*/ public function batchUpdateFiles(array $updatedFileKeys): void; /** * By/According toDirectoryPathFindFilelist. * * @param int $projectId Project ID * @param string $directoryPath DirectoryPath * @param int $limit QueryLimit * @return TaskFileEntity[] Filelist*/ public function findFilesByDirectoryPath(int $projectId, string $directoryPath, int $limit = 1000): array; /** * Get children files by parent_id and project_id. * * @param int $projectId Project ID * @param int $parentId Parent directory ID * @param int $limit Maximum number of files to return * @return TaskFileEntity[] File entity list */ public function getChildrenByParentAndProject(int $projectId, int $parentId, int $limit = 500): array; /** * Get children files by multiple parent_ids and project_id (batch query). * Uses idx_project_parent_sort index to avoid N+1 problem. * * @param int $projectId Project ID * @param array $parentIds Parent directory IDs * @param int $limit Maximum number of files to return * @return TaskFileEntity[] File entity list */ public function getChildrenByParentIdsAndProject(int $projectId, array $parentIds, int $limit = 1000): array; /** * Batch update file_key for multiple files. * * @param array $updateBatch Array of [['file_id' => 1, 'file_key' => 'new/path', 'updated_at' => '...'], ...] * @return int Number of updated files */ public function batchUpdateFileKeys(array $updateBatch): int; /** * BatchDeleteFile. * * @param array $fileIds FileIDArray*/ public function deleteByIds(array $fileIds): void; /** * By/According toFileKeysBatchDeleteFile. * * @param array $fileKeys FileKeyArray*/ public function deleteByFileKeys(array $fileKeys): void; /** * Batch bind files to project with parent directory. * Updates both project_id and parent_id atomically. * * @param array $fileIds Array of file IDs to bind * @param int $projectId Project ID to bind to * @param int $parentId Parent directory ID * @return int Number of affected rows */ public function batchBindToProject(array $fileIds, int $projectId, int $parentId): int; public function findLatestUpdatedByProjectId(int $projectId): ?TaskFileEntity; /** * Count files by project ID. * * @param int $projectId Project ID * @return int Total count of files in the project */ public function countFilesByProjectId(int $projectId): int; /** * Get files by project ID with resume support. * Used for fork migration with pagination and resume capability. * * @param int $projectId Project ID * @param Null|int $lastFileId Last processed file ID for resume * @param int $limit Number of files to fetch * @return TaskFileEntity[] Array of file entities */ public function getFilesByProjectIdWithResume(int $projectId, ?int $lastFileId, int $limit): array; /** * Batch update parent_id for multiple files. * Used for fixing parent relationships during fork operations. * * @param array $fileIds Array of file IDs to update * @param int $parentId New parent ID to set * @param string $userId User performing the update * @return int Number of affected rows */ public function batchUpdateParentId(array $fileIds, int $parentId, string $userId): int; public function updateFileByCondition(array $condition, array $data): bool; public function lockDirectChildrenForUpdate(int $parentId): array; public function getAllChildrenByParentId(int $parentId): array; /** * Recover beingDeleteFile. * * @param int $fileId FileID*/ public function restoreFile(int $fileId): void; } 