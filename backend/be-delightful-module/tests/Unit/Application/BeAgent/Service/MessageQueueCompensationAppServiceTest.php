<?php 
declare(strict_types=1);
 /** * Copyright (c) Be Delightful , Distributed under the MIT software license */
 namespace Delightful\BeDelightful\Tests\Unit\Application\BeAgent\Service;
 use App\Application\Chat\Service\DelightfulChatMessageAppService;
 use App\Domain\Contact\Service\DelightfulUserDomainService;
 use App\Infrastructure\Util\Locker\LockerInterface;
 use Delightful\BeDelightful\Application\BeAgent\Service\MessageQueueCompensationAppService;
 use Delightful\BeDelightful\Domain\BeAgent\Service\MessageQueueDomainService;
 use Delightful\BeDelightful\Domain\BeAgent\Service\TopicDomainService;
 use Hyperf\Logger\LoggerFactory;
 use PHPUnit\Framework\MockObject\MockObject;
 use PHPUnit\Framework\TestCase;
 /** * MessageQueueCompensationAppService Unit Test. * MessageQueueCompensationApplicationServiceUnit test. * @internal*/
 class MessageQueueCompensationAppServiceTest extends TestCase  {
 private MessageQueueCompensationAppService $service;
 private DelightfulChatMessageAppService|MockObject $mockChatAppService;
 private MessageQueueDomainService|MockObject $mockMessageQueueDomainService;
 private MockObject|TopicDomainService $mockTopicDomainService;
 private DelightfulUserDomainService|MockObject $mockUserDomainService;
 private LockerInterface|MockObject $mockLocker;
 private LoggerFactory|MockObject $mockLoggerFactory;
 protected function setUp(): void  {
 parent::setUp();
 $this->mockChatAppService = $this->createMock(DelightfulChatMessageAppService::class);
 $this->mockMessageQueueDomainService = $this->createMock(MessageQueueDomainService::class);
 $this->mockTopicDomainService = $this->createMock(TopicDomainService::class);
 $this->mockUserDomainService = $this->createMock(DelightfulUserDomainService::class);
 $this->mockLocker = $this->createMock(LockerInterface::class);
 $this->mockLoggerFactory = $this->createMock(LoggerFactory::class);
 $this->service = new MessageQueueCompensationAppService( $this->mockChatAppService, $this->mockMessageQueueDomainService, $this->mockTopicDomainService, $this->mockUserDomainService, $this->mockLocker, $this->mockLoggerFactory );
    }
 /** * Test executeCompensation when disabled. * TestDisable time CompensationExecute. * * ðŸ”’ Configuration Test: * â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” * â”‚ Config â”‚ Enabled â”‚ Expected â”‚ Behavior â”‚ * â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ * â”‚ Disabled â”‚ false â”‚ Empty stats â”‚ Early return â”‚ * â”‚ Enabled + No lock â”‚ true â”‚ Empty stats â”‚ Lock failed â”‚ * â”‚ Enabled + No topics â”‚ true â”‚ Empty stats â”‚ No topics found â”‚ * â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜*/
 public function testExecuteCompensationWhenDisabled(): void  {
 // Note: In a real test environment, you would mock the config function // For now, we'll test the enabled path since config mocking is complex $this->markTestSkipped('Config function mocking requires more complex setup'); } /** * Test executeCompensation global lock failure. * TestGlobal lockgetFailedSituation.*/ public function testExecuteCompensationGlobalLockFailure(): void { // Mock global lock failure $this->mockLocker->expects($this->once()) ->method('spinLock') ->willReturn(false); // Note: Logger calls are handled internally by the service // We don't need to mock logger method calls for this test $result = $this->service->executeCompensation(); $expected = ['processed' => 0, 'success' => 0, 'failed' => 0, 'skipped' => 0]; $this->assertEquals($expected, $result); } /** * Test executeCompensation with no topics found. * TestNo/NoneFoundpendingProcess/HandleTopicSituation.*/ public function testExecuteCompensationNoTopicsFound(): void { // Mock successful global lock $this->mockLocker->expects($this->once()) ->method('spinLock') ->willReturn(true); // Mock no topics found $this->mockMessageQueueDomainService->expects($this->once()) ->method('getCompensationTopics') ->with(50, []) ->willReturn([]); $this->mockLocker->expects($this->once()) ->method('release'); $result = $this->service->executeCompensation(); $expected = ['processed' => 0, 'success' => 0, 'failed' => 0, 'skipped' => 0]; $this->assertEquals($expected, $result); } /** * Test executeCompensation with successful processing. * TestSuccessProcess/HandleCompensationExecute. * * ðŸŽ¯ End-to-End Flow Test: * â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” * â”‚ Phase â”‚ Action â”‚ Result â”‚ Stats â”‚ * â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ * â”‚ Global lock â”‚ Acquire â”‚ Success â”‚ - â”‚ * â”‚ Topic discovery â”‚ Query â”‚ [123, 456] â”‚ - â”‚ * â”‚ Topic processing â”‚ Process â”‚ 1 success, 1 skip â”‚ processed: 2 â”‚ * â”‚ Final stats â”‚ Return â”‚ Statistics â”‚ success: 1 â”‚ * â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜*/ public function testExecuteCompensationSuccessfulProcessing(): void { $this->markTestSkipped('Complex integration test requires more setup'); } /** * Test topic processing with running status. * TestcorrectinRunStatusTopicProcess/Handle. * * ðŸƒâ€â™‚ï¸ Running Topic Test: * â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” * â”‚ Scenario â”‚ Topic Status â”‚ Action â”‚ Result â”‚ * â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ * â”‚ Topic running â”‚ RUNNING â”‚ Delay messages â”‚ 'delayed' â”‚ * â”‚ Topic finished â”‚ FINISHED â”‚ Process normallyâ”‚ 'success' â”‚ * â”‚ Topic not found â”‚ Null â”‚ Skip topic â”‚ 'skipped' â”‚ * â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜*/ public function testProcessTopicWithRunningStatus(): void { $this->markTestSkipped('Complex integration test requires more setup'); } /** * Test organization whitelist filtering. * TestOrganizationwhitenamesingleFilter.*/ public function testExecuteCompensationWithOrganizationWhitelist(): void { $this->markTestSkipped('Config function mocking requires more complex setup'); } } 

