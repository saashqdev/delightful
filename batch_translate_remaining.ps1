$file = 'c:\Users\kubew\magic\backend\be-delightful\delightful_use\js\lens.js'
$enc = [System.Text.UTF8Encoding]::new($false)
$c = [System.IO.File]::ReadAllText($file, $enc)

# Large batch replacement array
$replacements = @(
    @('有序list', 'Ordered list'),
    @('行内code', 'Inline code'),
    @('水平线', 'Horizontal line'),
    @('行内style', 'Inline style'),
    @('italic \(note：I tagif没被 IGNORED_TAGS 排除\)', 'italic (note: I tag if not excluded by IGNORED_TAGS)'),
    @('table内部结构element \(TR, THEAD, TBODY, TFOOT\)：', 'Table internal structure elements (TR, THEAD, TBODY, TFOOT):'),
    @('这些element本身不直接生成 Markdown，而是作为容器', 'These elements themselves do not directly generate Markdown, but serve as containers'),
    @('table单元格 \(TD, TH\)：', 'Table cells (TD, TH):'),
    @('其他常见块级/容器', 'Other common block-level/containers'),
    @('通常contains IMG 和 FIGCAPTION', 'Usually contains IMG and FIGCAPTION'),
    @('可折叠区域', 'Collapsible area'),
    @('check是否是通过CSSstyle实现的bold', 'Check if bold is implemented via CSS style'),
    @('增加 `skipNode` option来跳过特定子node', 'Add `skipNode` option to skip specific child nodes'),
    @('contains所有valid子nodeconcatenate后 Markdown 的resultobject', 'Result object containing Markdown from concatenation of all valid child nodes'),
    @('`isBlock` attribute表示子node中是否contains块级element', '`isBlock` attribute indicates whether child nodes contain block-level elements'),
    @('记录previousvalid子result', 'Record previous valid child result'),
    @('用于有序list项的indexcount', 'Used for index counting of ordered list items'),
    @('标记子node中是否contains块级element', 'Mark whether child nodes contain block-level elements'),
    @('traverse所有子node \(包括textnode和Element node\)', 'Traverse all child nodes (including text nodes and Element nodes)'),
    @('新增：跳过指定node', 'New: Skip specified nodes'),
    @('end新增', 'End new'),
    @('为list项 \(LI\) create特定的上下文，passindex', 'Create specific context for list items (LI), pass index'),
    @('忽略Invalid或空的子result', 'Ignore invalid or empty child results'),
    @('if子result是块级，则标记父级group合result也应视为块级（影响后续concatenate）', 'If child result is block-level, mark parent aggregation result should also be considered block-level (affects subsequent concatenation)'),
    @('智能concatenate逻辑 \(与 generateMarkdownFromElements 类似\)', 'Intelligent concatenation logic (similar to generateMarkdownFromElements)'),
    @('之前的块级separator逻辑可能过于宽松，导致过多line break，尤其是在行内element之间', 'Previous block-level separator logic may be too loose, causing too many line breaks, especially between inline elements'),
    @('optimization：仅当 \*两者之一\* 是块级时才需要块级separator', 'Optimization: Only need block-level separator when *either one* is block-level'),
    @('确保之前的 markdown 以适当的line breakend', 'Ensure previous markdown ends with appropriate line breaks'),
    @('if前一个不是块级，可能只需要一个line break？ 保持 ''\\n\\n'' 更security', 'If previous is not block-level, may only need one line break? Keep ''\\n\\n'' for safety'),
    @('两个行内element相邻', 'Two inline elements adjacent'),
    @('iftraverse完所有子node后，没有收集到任何Valid Markdown content', 'If after traversing all child nodes, no valid Markdown content was collected'),
    @('return null 表示此element没有validcontent', 'Return null indicates this element has no valid content'),
    @('returncontainsgroup合后 Markdown 和块级标记的resultobject', 'Return result object containing aggregated Markdown and block-level markers'),
    @('optimization：ifparent element本身是行内tag \(e\.g\., span, a\) 且child element不含块级，则整体应为行内', 'Optimization: If parent element itself is inline tag (e.g., span, a) and child elements do not contain block-level, overall should be inline'),
    @('contains块child element，或者parent element不是行内element时，整体视为块', 'Contains block child elements, or when parent element is not inline element, overall is considered block'),
    @('它会将link内的firstheading作为linktext，生成带link的 Markdown heading', 'It will use the first heading inside the link as link text, generate Markdown heading with link'),
    @('结构化link的 A element', 'Structured link A element'),
    @('获取 URL', 'Get URL'),
    @('findlink内的firstheadingelement \(h1-h6\)', 'Find first heading element (h1-h6) inside link'),
    @('提取headingtext', 'Extract heading text'),
    @('剥离 Markdown', 'Strip Markdown'),
    @('生成带link的 Markdown heading', 'Generate Markdown heading with link'),
    @('remove可能的前导空白/line break', 'Remove possible leading whitespace/line breaks'),
    @('group合最终 Markdown', 'Aggregate final Markdown'),
    @('最终clean首尾空白', 'Final cleaning of leading/trailing whitespace'),
    @('结构化link通常表示一个块级content', 'Structured links usually represent a block-level content'),
    @('heading级别 \(1-6\)', 'Heading level (1-6)'),
    @('特殊情况：headingcontent仅为一个link', 'Special case: heading content is only a link'),
    @('if是普通link，则用 H tag包裹', 'If is normal link, wrap with H tag'),
    @('没有valid子content', 'No valid child content'),
    @('从子nodegroup合的 Markdown 中剥离标记，得到纯textheadingcontent', 'Strip markings from child node aggregated Markdown to get plain text heading content'),
    @('剥离后empty，也视为Invalid', 'Empty after stripping, also considered invalid'),
    @('将子nodegroup合的 Markdown clean内部多余line break后，用 `markdownGenerator\.paragraph` format化', 'Clean internal excess line breaks from child node aggregated Markdown, then format with `markdownGenerator.paragraph`'),
    @('paragraph或类似element', 'Paragraph or similar element'),
    @('处理所有子node', 'Process all child nodes'),
    @('clean子nodegroup合 Markdown 中的多余line break（paragraph内部通常不需要多个连续line break）', 'Clean excess line breaks in child node aggregated Markdown (paragraphs usually do not need multiple consecutive line breaks)'),
    @('remove首尾空白', 'Remove leading/trailing whitespace'),
    @('clean后empty，视为Invalid', 'Empty after cleaning, considered invalid'),
    @('useclean后的contentGenerate Markdown paragraph', 'Use cleaned content to generate Markdown paragraph'),
    @('paragraph是块级', 'Paragraph is block-level'),
    @('获取 `href` attribute并parse为绝对 URL', 'Get `href` attribute and parse as absolute URL'),
    @('确定linktext：', 'Determine link text:'),
    @('优先use内部uniquevalidimage的 alt text', 'Prioritize using alt text of internal unique valid image'),
    @('获取并parse URL', 'Get and parse URL'),
    @('parse失败或 URL 被阻止', 'Parsing failed or URL blocked'),
    @('确定linktextcontent', 'Determine link text content'),
    @('check是否只contains一个直接child element，且该child element是validimage', 'Check if only contains one direct child element, and that child element is a valid image'),
    @('if是imagelink，useimage的 alt text作为linktext', 'If is image link, use image alt text as link text'),
    @('从子nodegroup合的 Markdown 中剥离标记', 'Strip markings from child node aggregated Markdown'),
    @('link是行内element', 'Link is inline element'),
    @('获取 Alt text', 'Get Alt text'),
    @('获取 URL', 'Get URL'),
    @('必须同时有Valid URL \(alt 可以是default值 "graph像"\)', 'Must have valid URL (alt can be default value "Image")'),
    @('image在 Markdown 中通常视为块级element（单独一行）', 'Image in Markdown is usually considered a block-level element (on its own line)'),
    @('确定list级别 \(`context\.listLevel`\)', 'Determine list level (`context.listLevel`)'),
    @('为每个 `<li>` call `processListItem`，passupdate后的上下文（增加 level，setting isOrdered, index）', 'For each `<li>` call `processListItem`, pass updated context (increase level, set isOrdered, index)'),
    @('收集所有Validlist项 Markdown result', 'Collect all valid list item Markdown results'),
    @('将所有list项的 Markdown 用line break符join起来，并在末尾add两个line break', 'Join all list item Markdown with line breaks, and add two line breaks at the end'),
    @('标记是否为有序list \(OL\)', 'Mark whether is ordered list (OL)'),
    @('获取current嵌套级别，default为 0', 'Get current nesting level, default is 0'),
    @('create子上下文，增加list级别，并pass in是否有序的标记', 'Create child context, increase list level, and pass in ordered marker'),
    @('标记current在list内部', 'Mark currently inside list'),
    @('有序list的indexcount器', 'Index counter for ordered list'),
    @('traverse直接child element', 'Traverse direct child elements'),
    @('passcurrent项的index', 'Pass current item index'),
    @('收集result', 'Collect result'),
    @('递增index \(即使是Unordered list也递增，虽然不用\)', 'Increment index (even for unordered lists, though not used)'),
    @('在 UL/OL 中遇到非 LI 的直接child element，通常是Invalid HTML，忽略它', 'Encountered non-LI direct child element in UL/OL, usually invalid HTML, ignore it'),
    @('if没有收集到任何Validlist项', 'If no valid list items collected'),
    @('将所有list项的 Markdown 用line break符join', 'Join all list item Markdown with line breaks'),
    @('list作为一个整体是块级element，末尾需要两个line break', 'List as a whole is a block-level element, needs two line breaks at end'),
    @('获取第一行content', 'Get first line content'),
    @('use `markdownGenerator\.listItem` format化第一行（addindent和标记）', 'Use `markdownGenerator.listItem` to format first line (add indent and markers)'),
    @('对后续行add正确的indent', 'Add correct indent to subsequent lines'),
    @('returncontainsformat化后list项content的 `ProcessResult`', 'Return `ProcessResult` containing formatted list item content'),
    @('currentlist项的嵌套级别', 'Nesting level of current list item'),
    @('父list是否有序', 'Whether parent list is ordered'),
    @('currentlist项在有序list中的index', 'Index of current list item in ordered list'),
    @('处理list项的所有子node', 'Process all child nodes of list item'),
    @('获取子nodegroup合的 Markdown，并按行split', 'Get child node aggregated Markdown and split by lines'),
    @('先 trim remove首尾空白/line break', 'First trim to remove leading/trailing whitespace/line breaks'),
    @('处理第一行', 'Process first line'),
    @('取第一行并 trim', 'Take first line and trim'),
    @('use生成器format化第一行，addindent和list标记', 'Use generator to format first line, add indent and list markers'),
    @('处理后续行 \(ifexists\)', 'Process subsequent lines (if exists)'),
    @('从第二行start', 'Start from second line'),
    @('跳过空行', 'Skip empty lines'),
    @('计算后续行的indent：current级别的indent \+ list标记的width', 'Calculate indent for subsequent lines: current level indent + list marker width')
)

foreach ($pair in $replacements) {
    $c = $c -creplace $pair[0], $pair[1]
}

[System.IO.File]::WriteAllText($file, $c, $enc)
Write-Output "Batch translation complete - processed $($replacements.Count) patterns"
