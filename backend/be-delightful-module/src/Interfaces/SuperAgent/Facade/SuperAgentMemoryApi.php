<?php declare(strict_types=1); /** * Copyright (c) Be Delightful , Distributed under the MIT software license */ namespace Delightful\BeDelightful\Interfaces\BeAgent\Facade; use App\Application\LongTermMemory\Service\LongTermMemoryAppService; use App\Domain\LongTermMemory\DTO\CreateMemoryDTO; use App\Domain\LongTermMemory\DTO\UpdateMemoryDTO; use App\Domain\LongTermMemory\Entity\ValueObject\MemoryStatus; use App\Domain\LongTermMemory\Entity\ValueObject\MemoryType; use App\ErrorCode\GenericErrorCode; use App\Infrastructure\Core\Exception\ExceptionBuilder; use App\Infrastructure\Util\ShadowCode\ShadowCode; use Delightful\ApiResponse\Annotation\ApiResponse; use Delightful\BeDelightful\Domain\BeAgent\Constant\AgentConstant; use Delightful\BeDelightful\Domain\BeAgent\Entity\ValueObject\MessageMetadata; use Hyperf\HttpServer\Contract\RequestInterface; use Hyperf\Validation\Contract\ValidatorFactoryInterface; use InvalidArgumentException; use function Hyperf\Translation\trans; #[ApiResponse('low_code')] class BeAgentMemoryApi extends AbstractApi { public function __construct( protected RequestInterface $request, protected ValidatorFactoryInterface $validator, protected LongTermMemoryAppService $longTermMemoryAppService, ) { parent::__construct($request); } /** * Create memory.*/ public function createMemory(): array { // Validate sandbox Token $this->validateSandboxToken(); $requestData = $this->getRequestData(); $rules = [ 'explanation' => 'required|string', 'memory' => 'required|string', 'tags' => 'array', 'metadata' => 'required|array', 'immediate_effect' => 'boolean|Nullable', 'project_id' => 'Nullable|integer|string', ]; $validatedParams = $this->checkParams($requestData, $rules); $metadata = $this->parseMetadata($validatedParams['metadata']); // By/According to immediate_effect ParameterDecide memoryStatusAndContentset $immediateEffect = (bool) ($validatedParams['immediate_effect'] ?? false); if ($immediateEffect) { // standinstanttake effect: memoryContentdirectlyPut intocontent, StatusForactive $content = $validatedParams['memory']; $pendingContent = Null; $status = MemoryStatus::ACTIVE->value; $enabled = true; // activeStatus's memoryDefaultEnable } else { // defaultRowFor: memoryContentPut intopendingContent, StatusForpending $content = ''; $pendingContent = $validatedParams['memory']; $status = MemoryStatus::PENDING->value; $enabled = false; // pendingStatus's memoryDefault not Enable } $dto = new CreateMemoryDTO([ 'content' => $content, 'pendingContent' => $pendingContent, 'explanation' => $validatedParams['explanation'], 'memoryType' => MemoryType::MANUAL_INPUT->value, 'status' => $status, 'enabled' => $enabled, 'tags' => $validatedParams['tags'] ?? [], 'orgId' => $metadata->getOrganizationCode(), 'appId' => AgentConstant::SUPER_DELIGHTFUL_CODE, // Project id Cannotfrom $metadata get, Because thisParameter is usecomezone divide memory is Projectstill is Global. 'projectId' => isset($validatedParams['project_id']) ? (string) $validatedParams['project_id'] : Null, 'userId' => $metadata->getUserId(), 'expiresAt' => Null, ]); $memoryId = $this->longTermMemoryAppService->createMemory($dto); return ['memory_id' => $memoryId, 'success' => true]; } /** * AgentUpdatememorycoreLogic.*/ public function agentUpdateMemory(string $id): array { // Validate sandbox Token $this->validateSandboxToken(); $requestData = $this->getRequestData(); $rules = [ 'explanation' => 'string', 'memory' => 'string', 'tags' => 'array', 'metadata' => 'required|array', ]; $validatedParams = $this->checkParams($requestData, $rules); $metadata = $this->parseMetadata($validatedParams['metadata']); // CheckPermission $this->checkMemoryPermission($id, $metadata); // BuildUpdateDTO, StatusConvertbyDomainServiceAutoProcess/Handle $dto = new UpdateMemoryDTO([ 'pendingContent' => $validatedParams['memory'] ?? Null, 'explanation' => $validatedParams['explanation'] ?? Null, 'tags' => $validatedParams['tags'] ?? Null, 'metadata' => $validatedParams['metadata'] ?? Null, ]); $this->longTermMemoryAppService->updateMemory($id, $dto); return ['success' => true]; } /** * Deletememory.*/ public function deleteMemory(string $id): array { // Validate sandbox Token $this->validateSandboxToken(); $requestData = $this->getRequestData(); $rules = [ 'metadata' => 'required|array', ]; $validatedParams = $this->checkParams($requestData, $rules); $metadata = $this->parseMetadata($validatedParams['metadata']); // CheckPermission $this->checkMemoryPermission($id, $metadata); $this->longTermMemoryAppService->deleteMemory($id); return [ 'success' => true, 'message' => trans('long_term_memory.api.memory_deleted_successfully'), ]; } /** * ChecksumRequestParameter. * * @throws InvalidArgumentException*/ protected function checkParams(array $params, array $rules): array { $validator = $this->validator->make($params, $rules); if ($validator->fails()) { throw new InvalidArgumentException(trans('long_term_memory.api.parameter_validation_failed', ['errors' => implode(', ', $validator->errors()->all())])); } return $validator->validated(); } /** * getRequestData (Process/HandleObfuscate).*/ private function getRequestData(): array { // ViewwhetherObfuscate $isConfusion = $this->request->input('obfuscated', false); if ($isConfusion) { // ObfuscateProcess/Handle $rawData = ShadowCode::unShadow($this->request->input('data', '')); return json_decode($rawData, true); } return $this->request->all(); } /** * parsemetadata.*/ private function parseMetadata(array $metadataArray): MessageMetadata { return MessageMetadata::fromArray($metadataArray); } /** * CheckmemoryPermission.*/ private function checkMemoryPermission(string $memoryId, MessageMetadata $metadata): void { if (! $this->longTermMemoryAppService->isMemoryBelongToUser( $memoryId, $metadata->getOrganizationCode(), AgentConstant::SUPER_DELIGHTFUL_CODE, $metadata->getUserId() )) { ExceptionBuilder::throw(GenericErrorCode::AccessDenied, trans('long_term_memory.api.memory_not_belong_to_user')); } } } 