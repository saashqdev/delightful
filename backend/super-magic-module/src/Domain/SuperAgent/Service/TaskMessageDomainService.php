<?php declare(strict_types=1); /** * Copyright (c) Be Delightful , Distributed under the software license */ namespace Dtyq\SuperMagic\Domain\SuperAgent\Service; use Dtyq\SuperMagic\Domain\SuperAgent\Entity\TaskMessageEntity; use Dtyq\SuperMagic\Domain\SuperAgent\Repository\Facade\TaskFileRepositoryInterface; use Dtyq\SuperMagic\Domain\SuperAgent\Repository\Facade\TaskMessageRepositoryInterface; use Dtyq\SuperMagic\Domain\SuperAgent\Repository\Model\TaskMessageModel; use Hyperf\Contract\StdoutLoggerInterface; use InvalidArgumentException; class TaskMessageDomainService { public function __construct( protected TaskMessageRepositoryInterface $messageRepository, protected TaskFileRepositoryInterface $taskFileRepository, private readonly StdoutLoggerInterface $logger ) { } public function getNextSeqId(int $topicId, int $taskId): int { return $this->messageRepository->getNextSeqId($topicId, $taskId); } public function updateProcessingStatus(int $id, string $processingStatus, ?string $errorMessage = Null, int $retryCount = 0): void { $this->messageRepository->updateProcessingStatus($id, $processingStatus, $errorMessage, $retryCount); } public function findProcessableMessages(int $topicId, int $taskId, string $senderType = 'assistant', int $timeoutMinutes = 30, int $maxRetries = 3, int $limit = 50): array { return $this->messageRepository->findProcessableMessages($topicId, $taskId, $senderType, $timeoutMinutes, $maxRetries, $limit); } public function findByTopicIdAndMessageId(int $topicId, string $messageId): ?TaskMessageEntity { return $this->messageRepository->findByTopicIdAndMessageId($topicId, $messageId); } public function updateExistingMessage(TaskMessageEntity $message): void { $this->messageRepository->updateExistingMessage($message); } /** * storedTopicTaskMessage. * * @param TaskMessageEntity $messageEntity MessageEntity * @param array $rawData OriginalMessageData * @param string $processStatus Process/HandleStatus * @return TaskMessageEntity stored after MessageEntity*/ public function storeTopicTaskMessage(TaskMessageEntity $messageEntity, array $rawData, string $processStatus = TaskMessageModel::PROCESSING_STATUS_PENDING): TaskMessageEntity { $this->logger->info('StartStorageTopicTaskMessage', [ 'topic_id' => $messageEntity->getTopicId(), 'message_id' => $messageEntity->getMessageId(), ]); // 1. getseq_id ( should this already inDTOConvert time set) $seqId = $messageEntity->getSeqId(); if ($seqId === Null) { throw new InvalidArgumentException('seq_id must be set before storing message'); } // 2. CheckMessagewhetherrepeat (throughseq_id + topic_id) $existingMessage = $this->messageRepository->findBySeqIdAndTopicId( $seqId, (int) $messageEntity->getTaskId(), (int) $messageEntity->getTopicId(), ); if ($existingMessage) { $this->logger->info('MessageAlready store inï¼ŒSkipDuplicateStorage', [ 'topic_id' => $messageEntity->getTopicId(), 'seq_id' => $seqId, 'task_id' => $messageEntity->getTaskId(), 'message_id' => $messageEntity->getMessageId(), ]); return $existingMessage; } // 3. MessageDoes not existin,  enter Rowstored $messageEntity->setRetryCount(0); $this->messageRepository->saveWithRawData( $rawData, // OriginalData $messageEntity, $processStatus ); $this->logger->info('TopicTaskMessageStorageComplete', [ 'topic_id' => $messageEntity->getTopicId(), 'seq_id' => $seqId, 'message_id' => $messageEntity->getMessageId(), ]); return $messageEntity; } /** * Update message IM sequence ID. * * @param int $messageId Message ID * @param Null|int $imSeqId IM sequence ID, Null to skip update */ public function updateMessageSeqId(int $messageId, ?int $imSeqId): void { $this->messageRepository->updateMessageSeqId($messageId, $imSeqId); } } 