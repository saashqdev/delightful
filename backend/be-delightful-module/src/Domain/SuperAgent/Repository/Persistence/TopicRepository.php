<?php declare(strict_types=1); /** * Copyright (c) Be Delightful , Distributed under the MIT software license */ namespace Delightful\BeDelightful\Domain\SuperAgent\Repository\Persistence; use App\Domain\Chat\Entity\ValueObject\DelightfulMessageStatus; use App\Domain\Chat\Repository\Persistence\Model\DelightfulChatSequenceModel; use App\Domain\Chat\Repository\Persistence\Model\DelightfulChatTopicMessageModel; use App\Domain\Chat\Repository\Persistence\Model\DelightfulMessageModel; use App\Infrastructure\Util\IdGenerator\IdGenerator; use Delightful\BeDelightful\Domain\SuperAgent\Entity\TopicEntity; use Delightful\BeDelightful\Domain\SuperAgent\Entity\ValueObject\TaskStatus; use Delightful\BeDelightful\Domain\SuperAgent\Repository\Facade\TopicRepositoryInterface; use Delightful\BeDelightful\Domain\SuperAgent\Repository\Model\TaskMessageModel; use Delightful\BeDelightful\Domain\SuperAgent\Repository\Model\TopicModel; use Delightful\BeDelightful\Domain\SuperAgent\Repository\Model\WorkspaceModel; use Exception; use Hyperf\DbConnection\Db; use Hyperf\Logger\LoggerFactory; use Psr\Log\LoggerInterface; class TopicRepository implements TopicRepositoryInterface { private LoggerInterface $logger; public function __construct( protected TopicModel $model, protected DelightfulChatSequenceModel $delightfulChatSequenceModel, protected DelightfulChatTopicMessageModel $delightfulChatTopicMessageModel, protected DelightfulMessageModel $delightfulMessageModel, LoggerFactory $loggerFactory ) { $this->logger = $loggerFactory->get(static::class); } public function getTopicById(int $id): ?TopicEntity { // First by id Query $model = $this->model::query()->whereNull('deleted_at') ->where('id', $id) ->first(); if ($model) { $data = $this->convertModelToEntityData($model->toArray()); return new TopicEntity($data); } // If by  id noFound, Then by chat_topic_id Query $model = $this->model::query()->whereNull('deleted_at') ->where('chat_topic_id', $id) ->first(); if ($model) { //  by  chat_topic_id check to Data time , RecordErrorLogAnd trace $this->logger->error('TopicRepository getTopicById  by  chat_topic_id check to Data，May existinData not Consistentissue', [ 'search_id' => $id, 'found_topic_id' => $model->id, 'found_chat_topic_id' => $model->chat_topic_id, 'trace' => (new Exception())->getTraceAsString(), ]); $data = $this->convertModelToEntityData($model->toArray()); return new TopicEntity($data); } return Null; } public function getTopicsByIds(array $ids): array { if (empty($ids)) { return []; } $models = $this->model::query()->whereNull('deleted_at')->whereIn('id', $ids)->get(); $entities = []; foreach ($models as $model) { $data = $this->convertModelToEntityData($model->toArray()); $entities[] = new TopicEntity($data); } return $entities; } public function getTopicWithDeleted(int $id): ?TopicEntity { $model = $this->model::query()->withTrashed()->find($id); if (! $model) { return Null; } $data = $this->convertModelToEntityData($model->toArray()); return new TopicEntity($data); } public function getTopicBySandboxId(string $sandboxId): ?TopicEntity { $model = $this->model::query()->whereNull('deleted_at')->where('sandbox_id', $sandboxId)->first(); if (! $model) { return Null; } $data = $this->convertModelToEntityData($model->toArray()); return new TopicEntity($data); } /** * By/According toConditiongetTopiclist. * SupportFilter、PaginationAndSort. * * @param array $conditions QueryCondition,  like  ['workspace_id' => 1, 'user_id' => 'xxx'] * @param bool $needPagination whetherNeedPagination * @param int $pageSize PaginationSize * @param int $page Page number * @param string $orderBy Sort field * @param string $orderDirection Sort direction, asc  or  desc * @return array{list: TopicEntity[], total: int} TopiclistAndTotal*/ public function getTopicsByConditions( array $conditions = [], bool $needPagination = true, int $pageSize = 10, int $page = 1, string $orderBy = 'id', string $orderDirection = 'desc' ): array { // BuildBaseQuery $query = $this->model::query(); // defaultFilter already DeleteData $query->whereNull('deleted_at'); // ApplicationConditionFilter foreach ($conditions as $field => $value) { if (is_array($value)) { $query->whereIn($field, $value); } elseif ($field === 'topic_name') { // topic_name fieldUse like Operation enter RowfuzzyMatch $query->where($field, 'like', '%' . $value . '%'); } else { $query->where($field, $value); } } // getTotal $total = $query->count(); // ApplicationSort $query->orderBy($orderBy, $orderDirection); // ApplicationPagination if ($needPagination) { $offset = ($page - 1) * $pageSize; $query->skip($offset)->take($pageSize); } // getData $topics = Db::select($query->toSql(), $query->getBindings()); // Convert toEntityObject $list = []; foreach ($topics as $topic) { $list[] = new TopicEntity($topic); } return [ 'list' => $list, 'total' => $total, ]; } public function createTopic(TopicEntity $topicEntity): TopicEntity { $date = date('Y-m-d H:i:s'); $topicEntity->setId(IdGenerator::getSnowId()); $topicEntity->setCreatedAt($date); $topicEntity->setUpdatedAt($date); $entityArray = $topicEntity->toArray(); $model = $this->model::query()->create($entityArray); /* @var TopicModel $model */ $topicEntity->setId($model->id); return $topicEntity; } public function updateTopic(TopicEntity $topicEntity): bool { $topicEntity->setUpdatedAt(date('Y-m-d H:i:s')); $entityArray = $topicEntity->toArray(); return $this->model::query() ->where('id', $topicEntity->getId()) ->update($entityArray) > 0; } // Useupdated_at AsOptimistic lock public function updateTopicWithUpdatedAt(TopicEntity $topicEntity, string $updatedAt): bool { $topicEntity->setUpdatedAt(date('Y-m-d H:i:s')); $entityArray = $topicEntity->toArray(); return $this->model::query() ->where('id', $topicEntity->getId()) ->where('updated_at', $updatedAt) ->update($entityArray) > 0; } public function updateTopicByCondition(array $condition, array $data): bool { return $this->model::query() ->where($condition) ->update($data) > 0; } public function deleteTopic(int $id): bool { return $this->model::query() ->where('id', $id) ->update([ 'deleted_at' => date('Y-m-d H:i:s'), ]) > 0; } /** * throughTopicIDCollectiongetWorkspaceinformation. * * @param array $topicIds TopicIDCollection * @return array byTopicIDForKey, WorkspaceinformationForValueassociatedArray, format: ['TopicID' => ['workspace_id' => 'Workspace ID', 'workspace_name' => 'WorkspaceName']]*/ public function getWorkspaceInfoByTopicIds(array $topicIds): array { if (empty($topicIds)) { return []; } // ConvertAllIDForInteger $topicIds = array_map('intval', $topicIds); // UseNativeSQLconnectTableQuery, ImprovePerformance $sql = 'SELECT t.id as topic_id, w.id as workspace_id, w.name as workspace_name FROM ' . $this->model->getTable() . ' t JOIN ' . (new WorkspaceModel())->getTable() . ' w ON t.workspace_id = w.id WHERE t.id IN (' . implode(',', $topicIds) . ') AND t.deleted_at IS NULL AND w.deleted_at IS NULL'; $results = Db::select($sql); // OrganizeResultForTopicIDForKeyassociatedArray $workspaceInfo = []; foreach ($results as $row) { $workspaceInfo[$row['topic_id']] = [ 'workspace_id' => (string) $row['workspace_id'], 'workspace_name' => $row['workspace_name'], ]; } return $workspaceInfo; } /** * getTopicStatusStatisticsData. * * @param array $conditions StatisticsCondition,  like  ['user_id' => '123', 'organization_code' => 'abc'] * @return array containingeachStatusQuantityArray*/ public function getTopicStatusMetrics(array $conditions = []): array { // UseNativeSQLQuerybyImprovePerformance,  by StatusGroupgetCount $baseQuery = $this->model::query(); // Process/HandleFilterCondition foreach ($conditions as $field => $value) { if (is_array($value)) { $baseQuery->whereIn($field, $value); } else { $baseQuery->where($field, $value); } } // defaultFilter already DeleteData $baseQuery->whereNull('deleted_at'); // StatisticsUniqueuser count  $userCount = $baseQuery->distinct()->count('user_id'); // StatisticsTopicTotal $topicCount = $baseQuery->count(); // StatisticseachStatusTopicQuantity $statusCounts = $baseQuery ->selectRaw('current_task_status, COUNT(*) as count') ->groupBy('current_task_status') ->get() ->keyBy('current_task_status') ->map(function ($item) { return (int) $item->count; }) ->toArray(); // PrepareReturnResult return [ 'status_metrics' => [ 'error_count' => $statusCounts['error'] ?? 0, 'completed_count' => $statusCounts['finished'] ?? 0, 'running_count' => $statusCounts['running'] ?? 0, 'waiting_count' => $statusCounts['waiting'] ?? 0, 'paused_count' => ($statusCounts['suspended'] ?? 0) + ($statusCounts['stopped'] ?? 0), ], 'total_metrics' => [ 'user_count' => $userCount, 'topic_count' => $topicCount, ], ]; } public function updateTopicStatus(int $id, $taskId, TaskStatus $status): bool { return $this->model::query() ->where('id', $id) ->update([ 'current_task_id' => $taskId, 'current_task_status' => $status->value, 'updated_at' => date('Y-m-d H:i:s'), ]) > 0; } public function updateTopicStatusAndSandboxId(int $id, $taskId, TaskStatus $status, string $sandboxId): bool { return $this->model::query() ->where('id', $id) ->update([ 'current_task_id' => $taskId, 'current_task_status' => $status->value, 'sandbox_id' => $sandboxId, 'updated_at' => date('Y-m-d H:i:s'), ]) > 0; } /** * getRecentUpdated atexceedspecifiedTimeTopiclist. * * @param string $timeThreshold TimethresholdValue, IfTopicUpdated atEarlier than thisTime, Will becontaininginResult in  * @param int $limit ReturnResultMaximumQuantity * @return array<TopicEntity> TopicEntitylist*/ public function getTopicsExceedingUpdateTime(string $timeThreshold, int $limit = 100): array { $models = $this->model::query() ->where('updated_at', '<', $timeThreshold) ->where('current_task_status', TaskStatus::RUNNING->value) ->whereNull('deleted_at') ->orderBy('id', 'asc') ->limit($limit) ->get(); $result = []; foreach ($models as $model) { $data = $this->convertModelToEntityData($model->toArray()); $result[] = new TopicEntity($data); } return $result; } public function updateTopicStatusBySandboxIds(array $sandboxIds, string $status): bool { return $this->model::query() ->whereIn('sandbox_id', $sandboxIds) ->update([ 'current_task_status' => $status, 'updated_at' => date('Y-m-d H:i:s'), ]) > 0; } /** * By/According toProject IDgetTopiclist.*/ public function getTopicsByProjectId(int $projectId, string $userId): array { $models = $this->model::query() ->where('project_id', $projectId) ->where('user_id', $userId) ->whereNull('deleted_at') ->orderBy('updated_at', 'desc') ->get(); $result = []; foreach ($models as $model) { $data = $this->convertModelToEntityData($model->toArray()); $result[] = new TopicEntity($data); } return $result; } /** * StatisticsProject next TopicQuantity.*/ public function countTopicsByProjectId(int $projectId): int { return $this->model::query() ->where('project_id', $projectId) ->whereNull('deleted_at') ->count(); } /** * Batchget have Run in TopicWorkspace IDlist. * * @param array $workspaceIds Workspace IDArray * @param Null|string $userId OptionalUser ID, specified time  only QuerythisuserTopic * @return array  have Run in TopicWorkspace IDArray*/ public function getRunningWorkspaceIds(array $workspaceIds, ?string $userId = Null): array { if (empty($workspaceIds)) { return []; } $query = $this->model::query() ->whereIn('workspace_id', $workspaceIds) ->where('current_task_status', TaskStatus::RUNNING->value) ->whereNull('deleted_at'); if ($userId !== Null) { $query->where('user_id', $userId); } return $query ->distinct() ->pluck('workspace_id') ->toArray(); } /** * Batchget have Run in TopicProject IDlist. * * @param array $projectIds Project IDArray * @param Null|string $userId OptionalUser ID, specified time  only QuerythisuserTopic * @return array  have Run in TopicProject IDArray*/ public function getRunningProjectIds(array $projectIds, ?string $userId = Null): array { if (empty($projectIds)) { return []; } $query = $this->model::query() ->whereIn('project_id', $projectIds) ->where('current_task_status', TaskStatus::RUNNING->value) ->whereNull('deleted_at'); if ($userId !== Null) { $query->where('user_id', $userId); } return $query ->distinct() ->pluck('project_id') ->toArray(); } // ======================= MessageRollbackRelatedmethodImplementation ======================= /** * By/According toSequenceIDgetdelightful_message_id.*/ public function getDelightfulMessageIdBySeqId(string $seqId): ?string { $result = $this->delightfulChatSequenceModel::query() ->where('id', $seqId) ->value('delightful_message_id'); return $result ?: Null; } /** * By/According todelightful_message_idgetAllRelatedseq_id (Allviewrole).*/ public function getAllSeqIdsByDelightfulMessageId(string $delightfulMessageId): array { // ReturnAllRelatedseq_id return $this->delightfulChatSequenceModel::query() ->where('delightful_message_id', $delightfulMessageId) ->pluck('id') ->toArray(); } /** * By/According toBaseseq_idsgetCurrentTopicCurrentMessageAnd thisMessageafterAllMessage.*/ public function getAllSeqIdsFromCurrent(array $baseSeqIds): array { if (empty($baseSeqIds)) { return []; } // BatchQueryAllbaseSeqIdsPair should conversation_idAndtopic_id $topicInfos = $this->delightfulChatTopicMessageModel::query() ->select(['seq_id', 'conversation_id', 'topic_id']) ->whereIn('seq_id', $baseSeqIds) ->get() ->keyBy('seq_id'); if ($topicInfos->isEmpty()) { return []; } $allSeqIds = []; // TraverseQuery to topicInfo, geteveryTopic next Greater thanwaitinthisseq_idAllMessage foreach ($topicInfos as $topicInfo) { // QuerythisTopic next Greater thanwaitinthisseq_idAllMessage (containingCurrentMessageAnd subsequentMessage) $seqIds = $this->delightfulChatTopicMessageModel::query() ->where('conversation_id', $topicInfo->conversation_id) ->where('topic_id', $topicInfo->topic_id) ->where('seq_id', '>=', $topicInfo->seq_id) ->pluck('seq_id') ->toArray(); $allSeqIds[] = $seqIds; } ! empty($allSeqIds) && $allSeqIds = array_merge(...$allSeqIds); return array_values(array_unique($allSeqIds)); } /** * Deletetopic_messagesData.*/ public function deleteTopicMessages(array $seqIds): int { if (empty($seqIds)) { return 0; } return $this->delightfulChatTopicMessageModel::query() ->whereIn('seq_id', $seqIds) ->delete(); } /** * By/According toseq_idsDeletemessagesAndsequencesData.*/ public function deleteMessagesAndSequencesBySeqIds(array $seqIds): bool { if (empty($seqIds)) { return true; } // getAllRelateddelightful_message_ids $delightfulMessageIds = $this->delightfulChatSequenceModel::query() ->whereIn('id', $seqIds) ->distinct() ->pluck('delightful_message_id') ->toArray(); // Delete delightful_chat_messages if (! empty($delightfulMessageIds)) { $this->delightfulMessageModel::query() ->whereIn('delightful_message_id', $delightfulMessageIds) ->delete(); } // Delete delightful_chat_sequences $this->delightfulChatSequenceModel::query() ->whereIn('id', $seqIds) ->delete(); return true; } /** * By/According toim_seq_idDeletedelightful_super_agent_messageTable in Pair should TopicSubsequentMessage.*/ public function deleteSuperAgentMessagesFromSeqId(int $seqId): int { // 1. By/According toseq_idQueryPair should MessageRecord $targetMessage = TaskMessageModel::query() ->where('im_seq_id', $seqId) ->first(['id', 'topic_id']); if (! $targetMessage) { return 0; } $messageId = (int) $targetMessage->id; $topicId = (int) $targetMessage->topic_id; // 2. DeleteCurrentTopic in  id >= messageId AllData return TaskMessageModel::query() ->where('topic_id', $topicId) ->where('id', '>=', $messageId) ->delete(); } /** * BatchUpdatedelightful_chat_sequencesTablestatusfield.*/ public function batchUpdateSeqStatus(array $seqIds, DelightfulMessageStatus $status): bool { if (empty($seqIds)) { return true; } return (bool) $this->delightfulChatSequenceModel::query() ->whereIn('id', $seqIds) ->update(['status' => $status->value]); } /** * By/According toBaseseq_idsgetCurrentTopicLess than inspecifiedseq_idAllMessage.*/ public function getAllSeqIdsBeforeCurrent(array $baseSeqIds): array { if (empty($baseSeqIds)) { return []; } // BatchQueryAllbaseSeqIdsPair should conversation_idAndtopic_id $topicInfos = $this->delightfulChatTopicMessageModel::query() ->select(['seq_id', 'conversation_id', 'topic_id']) ->whereIn('seq_id', $baseSeqIds) ->get() ->keyBy('seq_id'); if ($topicInfos->isEmpty()) { return []; } $allSeqIds = []; // TraverseQuery to topicInfo, geteveryTopicBelow less than thisseq_idAllMessage foreach ($topicInfos as $topicInfo) { // QuerythisTopicBelow less than thisseq_idAllMessage $seqIds = $this->delightfulChatTopicMessageModel::query() ->where('conversation_id', $topicInfo->conversation_id) ->where('topic_id', $topicInfo->topic_id) ->where('seq_id', '<', $topicInfo->seq_id) ->pluck('seq_id') ->toArray(); $allSeqIds[] = $seqIds; } ! empty($allSeqIds) && $allSeqIds = array_merge(...$allSeqIds); return array_values(array_unique($allSeqIds)); } /** * By/According toTopicIDgetAllWithdrawStatusMessageseq_ids.*/ public function getRevokedSeqIdsByTopicId(int $topicId, string $userId): array { //  first getSuperAgentTopicEntity $topic = $this->getTopicById($topicId); if (! $topic) { return []; } // getPair should ChatTopicID $chatTopicId = $topic->getChatTopicId(); if (empty($chatTopicId)) { return []; } // UseChatTopicIDQuerythisTopic next AllWithdrawStatusMessage return $this->delightfulChatTopicMessageModel::query() ->join('delightful_chat_sequences', 'delightful_chat_topic_messages.seq_id', '=', 'delightful_chat_sequences.id') ->where('delightful_chat_topic_messages.topic_id', $chatTopicId) ->where('delightful_chat_sequences.status', DelightfulMessageStatus::Revoked->value) ->pluck('delightful_chat_topic_messages.seq_id') ->toArray(); } /** * Batch get topic names by IDs. */ public function getTopicNamesBatch(array $topicIds): array { if (empty($topicIds)) { return []; } $results = $this->model::query() ->whereIn('id', $topicIds) ->whereNull('deleted_at') ->select(['id', 'topic_name']) ->get(); $topicNames = []; foreach ($results as $result) { $topicNames[(string) $result->id] = $result->topic_name; } return $topicNames; } /** * ConvertData database ModelDataConvert toEntityData. * @param array $modelData ModelData * @return array EntityData*/ private function convertModelToEntityData(array $modelData): array { // ConvertUnderscore namingConvert tocamel casename $entityData = []; foreach ($modelData as $key => $value) { $camelKey = $this->snakeToCamel($key); $entityData[$camelKey] = $value; } return $entityData; } /** * ConvertUnderscore namingConvert tocamel casename. * For example: user_id => userId, topic_name => topicName. * * @param string $snake Underscore namingString * @return string camel casenameString*/ private function snakeToCamel(string $snake): string { // Process/HandleconnectCharacterAnd underscoreSituation return lcfirst(str_replace(' ', '', ucwords(str_replace(['_', '-'], ' ', $snake)))); } } 