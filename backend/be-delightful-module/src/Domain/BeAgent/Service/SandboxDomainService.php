<?php declare(strict_types=1); /** * Copyright (c) Be Delightful , Distributed under the MIT software license */ namespace Delightful\BeDelightful\Domain\BeAgent\Service; use BeDelightful\BeDelightful\Infrastructure\ExternalAPI\SandboxOS\Exception\SandboxOperationException; use BeDelightful\BeDelightful\Infrastructure\ExternalAPI\SandboxOS\Gateway\Constant\ResponseCode; use BeDelightful\BeDelightful\Infrastructure\ExternalAPI\SandboxOS\Gateway\Constant\SandboxStatus; use BeDelightful\BeDelightful\Infrastructure\ExternalAPI\SandboxOS\Gateway\Result\SandboxStatusResult; use BeDelightful\BeDelightful\Infrastructure\ExternalAPI\SandboxOS\Gateway\SandboxGatewayInterface; use Hyperf\Logger\LoggerFactory; use Psr\Log\LoggerInterface; use Throwable; class SandboxDomainService { private LoggerInterface $logger; public function __construct( LoggerFactory $loggerFactory, private readonly SandboxGatewayInterface $gateway, ) { $this->logger = $loggerFactory->get('sandbox'); } /** * callSandboxgateway, CreateSandboxContainer, If sandboxId Does not existin, SystemwilldefaultCreate a each .*/ public function createSandbox(string $projectId, string $sandboxID, string $workDir): string { $this->logger->info('[Sandbox][App] Creating sandbox', [ 'project_id' => $projectId, 'sandbox_id' => $sandboxID, ]); $result = $this->gateway->createSandbox($projectId, $sandboxID, $workDir); // adddetailedDebugLog, Check result Object $this->logger->info('[Sandbox][App] Gateway result analysis', [ 'result_class' => get_class($result), 'result_is_success' => $result->isSuccess(), 'result_code' => $result->getCode(), 'result_message' => $result->getMessage(), 'result_data_raw' => $result->getData(), 'result_data_type' => gettype($result->getData()), 'sandbox_id_via_getDataValue' => $result->getDataValue('sandbox_id'), 'sandbox_id_via_getData_direct' => $result->getData()['sandbox_id'] ?? 'KEY_NOT_FOUND', ]); if (! $result->isSuccess()) { $this->logger->error('[Sandbox][App] Failed to create sandbox', [ 'project_id' => $projectId, 'sandbox_id' => $sandboxID, 'error' => $result->getMessage(), 'code' => $result->getCode(), ]); throw new SandboxOperationException('Create sandbox', $result->getMessage(), $result->getCode()); } $this->logger->info('[Sandbox][App] Create sandbox success', [ 'project_id' => $projectId, 'input_sandbox_id' => $sandboxID, 'returned_sandbox_id' => $result->getDataValue('sandbox_id'), ]); return $result->getDataValue('sandbox_id'); } /** * WaitWorkspaceReady. * pollingWorkspaceStatus, direct to InitializeCompleteã€Failed or Timeout. * * @param string $sandboxId SandboxID * @param int $timeoutSeconds TimeoutTime ( seconds ), default2Minute * @param int $intervalSeconds pollingInterval ( seconds ), default2 seconds  * @throws SandboxOperationException whenInitializeFailed or TimeoutThrow whenAbnormal*/ public function waitForSandboxReady(string $sandboxId, int $timeoutSeconds = 120, int $intervalSeconds = 2): void { $this->logger->info('[Sandbox][App] Waiting for Sandbox to be ready', [ 'sandbox_id' => $sandboxId, 'timeout_seconds' => $timeoutSeconds, 'interval_seconds' => $intervalSeconds, ]); $startTime = time(); $endTime = $startTime + $timeoutSeconds; while (time() < $endTime) { try { $response = $this->getSandboxStatus($sandboxId); $status = $response->getStatus(); $this->logger->debug('[Sandbox][App] Sandbox status check', [ 'sandbox_id' => $sandboxId, 'status' => $status, 'elapsed_seconds' => time() - $startTime, ]); // StatusExit when ready if ($status === SandboxStatus::RUNNING) { $this->logger->info('[Sandbox][App] Sandbox is ready', [ 'sandbox_id' => $sandboxId, 'elapsed_seconds' => time() - $startTime, ]); return; } // WaitNext polling sleep($intervalSeconds); } catch (SandboxOperationException $e) { //  re ThrowSandboxOperationAbnormal throw $e; } catch (Throwable $e) { $this->logger->error('[Sandbox][App] Error while checking sandbox status', [ 'sandbox_id' => $sandboxId, 'error' => $e->getMessage(), 'elapsed_seconds' => time() - $startTime, ]); throw new SandboxOperationException('Wait for sandbox ready', 'Error checking sandbox status: ' . $e->getMessage(), 3002); } } } /** * getSandboxStatus * * @param string $sandboxId SandboxID * @return SandboxStatusResult SandboxStatusResult*/ public function getSandboxStatus(string $sandboxId): SandboxStatusResult { $this->logger->info('[Sandbox][App] Getting sandbox status', [ 'sandbox_id' => $sandboxId, ]); $result = $this->gateway->getSandboxStatus($sandboxId); if (! $result->isSuccess() && $result->getCode() !== ResponseCode::NOT_FOUND) { $this->logger->error('[Sandbox][App] Failed to get sandbox status', [ 'sandbox_id' => $sandboxId, 'error' => $result->getMessage(), 'code' => $result->getCode(), ]); throw new SandboxOperationException('Get sandbox status', $result->getMessage(), $result->getCode()); } $this->logger->info('[Sandbox][App] Sandbox status retrieved', [ 'sandbox_id' => $sandboxId, 'status' => $result->getStatus(), ]); return $result; } } 