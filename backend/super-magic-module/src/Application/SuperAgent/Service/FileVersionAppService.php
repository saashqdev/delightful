<?php declare(strict_types=1); /** * Copyright (c) Be Delightful , Distributed under the MIT software license */ namespace Dtyq\SuperMagic\Application\SuperAgent\Service; use App\Infrastructure\Core\Exception\ExceptionBuilder; use App\Infrastructure\Util\Context\RequestContext; use Dtyq\SuperMagic\Domain\SuperAgent\Service\ProjectDomainService; use Dtyq\SuperMagic\Domain\SuperAgent\Service\TaskFileDomainService; use Dtyq\SuperMagic\Domain\SuperAgent\Service\TaskFileVersionDomainService; use Dtyq\SuperMagic\ErrorCode\SuperAgentErrorCode; use Dtyq\SuperMagic\Interfaces\SuperAgent\DTO\Request\CreateFileVersionRequestDTO; use Dtyq\SuperMagic\Interfaces\SuperAgent\DTO\Request\GetFileVersionsRequestDTO; use Dtyq\SuperMagic\Interfaces\SuperAgent\DTO\Request\RollbackFileToVersionRequestDTO; use Dtyq\SuperMagic\Interfaces\SuperAgent\DTO\Response\CreateFileVersionResponseDTO; use Dtyq\SuperMagic\Interfaces\SuperAgent\DTO\Response\GetFileVersionsResponseDTO; use Dtyq\SuperMagic\Interfaces\SuperAgent\DTO\Response\RollbackFileToVersionResponseDTO; use Hyperf\Logger\LoggerFactory; use Psr\Log\LoggerInterface; class FileVersionAppService extends AbstractAppService { private readonly LoggerInterface $logger; public function __construct( private readonly ProjectDomainService $projectDomainService, private readonly TaskFileDomainService $taskFileDomainService, private readonly TaskFileVersionDomainService $taskFileVersionDomainService, LoggerFactory $loggerFactory ) { $this->logger = $loggerFactory->get(get_class($this)); } /** * CreateFileVersion. * * @param CreateFileVersionRequestDTO $requestDTO RequestDTO * @return CreateFileVersionResponseDTO CreateResult*/ public function createFileVersion( CreateFileVersionRequestDTO $requestDTO ): CreateFileVersionResponseDTO { // getuserauthorizationinformation $fileKey = $requestDTO->getFileKey(); $editType = $requestDTO->getEditType(); $this->logger->info('Creating file version', [ 'file_key' => $fileKey, 'edit_type' => $editType, ]); // ValidateFilewhether store in $fileEntity = $this->taskFileDomainService->getByFileKey($fileKey); if (! $fileEntity) { ExceptionBuilder::throw(SuperAgentErrorCode::FILE_NOT_FOUND, 'file.file_not_found'); } // ValidateFilewhetherForDirectory if ($fileEntity->getIsDirectory()) { ExceptionBuilder::throw(SuperAgentErrorCode::FILE_PERMISSION_DENIED, 'file.cannot_version_directory'); } $projectEntity = $this->projectDomainService->getProjectNotUserId($fileEntity->getProjectId()); if (! $projectEntity) { ExceptionBuilder::throw(SuperAgentErrorCode::PROJECT_NOT_FOUND, 'project.project_not_found'); } // callDomain ServiceCreateVersion $versionEntity = $this->taskFileVersionDomainService->createFileVersion($projectEntity->getUserOrganizationCode(), $fileEntity, $editType); if (! $versionEntity) { ExceptionBuilder::throw(SuperAgentErrorCode::FILE_SAVE_FAILED, 'file.version_create_failed'); } $this->logger->info('File version created successfully', [ 'file_key' => $fileKey, 'file_id' => $fileEntity->getFileId(), 'version_id' => $versionEntity->getId(), 'version' => $versionEntity->getVersion(), 'edit_type' => $editType, ]); // ReturnResult return CreateFileVersionResponseDTO::createEmpty(); } /** * PaginationgetFileVersionlist. * * @param RequestContext $requestContext request context * @param GetFileVersionsRequestDTO $requestDTO RequestDTO * @return GetFileVersionsResponseDTO QueryResult*/ public function getFileVersions( RequestContext $requestContext, GetFileVersionsRequestDTO $requestDTO ): GetFileVersionsResponseDTO { // getuserauthorizationinformation $userAuthorization = $requestContext->getUserAuthorization(); $dataIsolation = $this->createDataIsolation($userAuthorization); $fileId = $requestDTO->getFileId(); $this->logger->info('Getting file versions with pagination', [ 'file_id' => $fileId, 'page' => $requestDTO->getPage(), 'page_size' => $requestDTO->getPageSize(), 'user_id' => $dataIsolation->getCurrentUserId(), 'organization_code' => $dataIsolation->getCurrentOrganizationCode(), ]); // ValidateFilewhether store in $fileEntity = $this->taskFileDomainService->getById($fileId); if (! $fileEntity) { ExceptionBuilder::throw(SuperAgentErrorCode::FILE_NOT_FOUND, 'file.file_not_found'); } // ValidateFilePermission - EnsureFileattributeinCurrentOrganization /*if ($fileEntity->getOrganizationCode() !== $dataIsolation->getCurrentOrganizationCode()) { ExceptionBuilder::throw(SuperAgentErrorCode::FILE_PERMISSION_DENIED, 'file.access_denied'); }*/ // ValidateProjectPermission if ($fileEntity->getProjectId() > 0) { $this->getAccessibleProject( $fileEntity->getProjectId(), $dataIsolation->getCurrentUserId(), $dataIsolation->getCurrentOrganizationCode() ); } // callDomain ServicegetPaginationData $result = $this->taskFileVersionDomainService->getFileVersionsWithPage( $fileId, $requestDTO->getPage(), $requestDTO->getPageSize() ); $this->logger->info('File versions retrieved successfully', [ 'file_id' => $fileId, 'total' => $result['total'], 'current_page_count' => count($result['list']), ]); // ReturnResult return GetFileVersionsResponseDTO::fromData($result['list'], $result['total'], $requestDTO->getPage()); } /** * FileRollback tospecifiedVersion. * * @param RequestContext $requestContext request context * @param RollbackFileToVersionRequestDTO $requestDTO RequestDTO * @return RollbackFileToVersionResponseDTO RollbackResult*/ public function rollbackFileToVersion( RequestContext $requestContext, RollbackFileToVersionRequestDTO $requestDTO ): RollbackFileToVersionResponseDTO { $userAuthorization = $requestContext->getUserAuthorization(); $dataIsolation = $this->createDataIsolation($userAuthorization); $fileId = $requestDTO->getFileId(); $targetVersion = $requestDTO->getVersion(); $this->logger->info('Rolling back file to version', [ 'file_id' => $fileId, 'target_version' => $targetVersion, 'user_id' => $dataIsolation->getCurrentUserId(), 'organization_code' => $dataIsolation->getCurrentOrganizationCode(), ]); // ValidateFilewhether store in $fileEntity = $this->taskFileDomainService->getById($fileId); if (! $fileEntity) { ExceptionBuilder::throw(SuperAgentErrorCode::FILE_NOT_FOUND, 'file.file_not_found'); } // ValidateProjectPermission $projectEntity = $this->getAccessibleProject( $fileEntity->getProjectId(), $dataIsolation->getCurrentUserId(), $dataIsolation->getCurrentOrganizationCode() ); // ValidateFilewhetherForDirectory if ($fileEntity->getIsDirectory()) { ExceptionBuilder::throw(SuperAgentErrorCode::FILE_PERMISSION_DENIED, 'file.cannot_rollback_directory'); } $newVersionEntity = $this->taskFileVersionDomainService->rollbackFileToVersion( $projectEntity->getUserOrganizationCode(), $fileEntity, $targetVersion ); if (! $newVersionEntity) { ExceptionBuilder::throw(SuperAgentErrorCode::FILE_SAVE_FAILED, 'file.rollback_failed'); } $this->logger->info('File rollback completed successfully', [ 'file_id' => $fileId, 'target_version' => $targetVersion, 'new_version_id' => $newVersionEntity->getId(), 'new_version' => $newVersionEntity->getVersion(), ]); return RollbackFileToVersionResponseDTO::createEmpty(); } } 