<?php declare(strict_types=1); /** * Copyright (c) Be Delightful , Distributed under the MIT software license */ namespace Delightful\BeDelightful\Application\SuperAgent\Service; use App\Application\File\Service\FileAppService; use App\Domain\Contact\Entity\ValueObject\DataIsolation; use App\Domain\File\Repository\Persistence\Facade\CloudFileRepositoryInterface; use App\ErrorCode\GenericErrorCode; use App\Infrastructure\Core\Exception\BusinessException; use App\Infrastructure\Core\Exception\ExceptionBuilder; use App\Infrastructure\Core\ValueObject\StorageBucketType; use App\Infrastructure\Util\Context\RequestContext; use App\Infrastructure\Util\IdGenerator\IdGenerator; use App\Infrastructure\Util\Locker\LockerInterface; use App\Interfaces\Authorization\Web\DelightfulUserAuthorization; use Delightful\BeDelightful\Application\SuperAgent\Event\Publish\FileBatchCopyPublisher; use Delightful\BeDelightful\Application\SuperAgent\Event\Publish\FileBatchMovePublisher; use Delightful\BeDelightful\Domain\Share\Constant\ResourceType; use Delightful\BeDelightful\Domain\Share\Service\ResourceShareDomainService; use Delightful\BeDelightful\Domain\SuperAgent\Entity\ValueObject\StorageType; use Delightful\BeDelightful\Domain\SuperAgent\Event\DirectoryDeletedEvent; use Delightful\BeDelightful\Domain\SuperAgent\Event\FileBatchCopyEvent; use Delightful\BeDelightful\Domain\SuperAgent\Event\FileBatchMoveEvent; use Delightful\BeDelightful\Domain\SuperAgent\Event\FileDeletedEvent; use Delightful\BeDelightful\Domain\SuperAgent\Event\FileMovedEvent; use Delightful\BeDelightful\Domain\SuperAgent\Event\FileRenamedEvent; use Delightful\BeDelightful\Domain\SuperAgent\Event\FileReplacedEvent; use Delightful\BeDelightful\Domain\SuperAgent\Event\FilesBatchDeletedEvent; use Delightful\BeDelightful\Domain\SuperAgent\Event\FileUploadedEvent; use Delightful\BeDelightful\Domain\SuperAgent\Service\ProjectDomainService; use Delightful\BeDelightful\Domain\SuperAgent\Service\TaskFileDomainService; use Delightful\BeDelightful\Domain\SuperAgent\Service\TaskFileVersionDomainService; use Delightful\BeDelightful\Domain\SuperAgent\Service\TopicDomainService; use Delightful\BeDelightful\ErrorCode\ShareErrorCode; use Delightful\BeDelightful\ErrorCode\SuperAgentErrorCode; use Delightful\BeDelightful\Infrastructure\Utils\AccessTokenUtil; use Delightful\BeDelightful\Infrastructure\Utils\FileBatchOperationStatusManager; use Delightful\BeDelightful\Infrastructure\Utils\WorkDirectoryUtil; use Delightful\BeDelightful\Interfaces\SuperAgent\DTO\Request\BatchCopyFileRequestDTO; use Delightful\BeDelightful\Interfaces\SuperAgent\DTO\Request\BatchDeleteFilesRequestDTO; use Delightful\BeDelightful\Interfaces\SuperAgent\DTO\Request\BatchMoveFileRequestDTO; use Delightful\BeDelightful\Interfaces\SuperAgent\DTO\Request\BatchSaveProjectFilesRequestDTO; use Delightful\BeDelightful\Interfaces\SuperAgent\DTO\Request\CheckBatchOperationStatusRequestDTO; use Delightful\BeDelightful\Interfaces\SuperAgent\DTO\Request\CreateFileRequestDTO; use Delightful\BeDelightful\Interfaces\SuperAgent\DTO\Request\DeleteDirectoryRequestDTO; use Delightful\BeDelightful\Interfaces\SuperAgent\DTO\Request\ProjectUploadTokenRequestDTO; use Delightful\BeDelightful\Interfaces\SuperAgent\DTO\Request\ReplaceFileRequestDTO; use Delightful\BeDelightful\Interfaces\SuperAgent\DTO\Request\SaveProjectFileRequestDTO; use Delightful\BeDelightful\Interfaces\SuperAgent\DTO\Request\TopicUploadTokenRequestDTO; use Delightful\BeDelightful\Interfaces\SuperAgent\DTO\Response\FileBatchOperationResponseDTO; use Delightful\BeDelightful\Interfaces\SuperAgent\DTO\Response\FileBatchOperationStatusResponseDTO; use Delightful\BeDelightful\Interfaces\SuperAgent\DTO\Response\TaskFileItemDTO; use Hyperf\Amqp\Producer; use Hyperf\DbConnection\Db; use Hyperf\Logger\LoggerFactory; use Psr\EventDispatcher\EventDispatcherInterface; use Psr\Log\LoggerInterface; use Throwable; use function Hyperf\Translation\trans; class FileManagementAppService extends AbstractAppService { private readonly LoggerInterface $logger; public function __construct( private readonly FileAppService $fileAppService, private readonly TopicDomainService $topicDomainService, private readonly TaskFileDomainService $taskFileDomainService, private readonly TaskFileVersionDomainService $taskFileVersionDomainService, private readonly CloudFileRepositoryInterface $cloudFileRepository, private readonly ResourceShareDomainService $resourceShareDomainService, private readonly FileBatchOperationStatusManager $batchOperationStatusManager, private readonly LockerInterface $locker, private readonly Producer $producer, private readonly EventDispatcherInterface $eventDispatcher, private readonly ProjectDomainService $projectDomainService, LoggerFactory $loggerFactory ) { $this->logger = $loggerFactory->get(get_class($this)); } /** * getProjectFileUploadSTS Token. * * @param ProjectUploadTokenRequestDTO $requestDTO Request DTO * @return array getResult*/ public function getProjectUploadToken(RequestContext $requestContext, ProjectUploadTokenRequestDTO $requestDTO): array { try { $projectId = $requestDTO->getProjectId(); $expires = $requestDTO->getExpires(); // getCurrentuserinformation $userAuthorization = $requestContext->getUserAuthorization(); // CreateDataIsolationObject $dataIsolation = $this->createDataIsolation($userAuthorization); $userId = $dataIsolation->getCurrentUserId(); $organizationCode = $dataIsolation->getCurrentOrganizationCode(); // Situation1:  have Project ID, getProjectwork_dir if (! empty($projectId)) { $projectEntity = $this->getAccessibleProject((int) $projectId, $userId, $userAuthorization->getOrganizationCode()); $workDir = $projectEntity->getWorkDir(); if (empty($workDir)) { ExceptionBuilder::throw(SuperAgentErrorCode::WORK_DIR_NOT_FOUND, trans('project.work_dir.not_found')); } $organizationCode = $projectEntity->getUserOrganizationCode(); } else { // Situation2: noProject ID, UseSnowflakeIDGenerateTemporaryProject ID $tempProjectId = IdGenerator::getSnowId(); $workDir = WorkDirectoryUtil::getWorkDir($userId, $tempProjectId); } // getSTS Token $userAuthorization = new DelightfulUserAuthorization(); $userAuthorization->setOrganizationCode($organizationCode); $storageType = StorageBucketType::SandBox->value; return $this->fileAppService->getStsTemporaryCredentialV2( $organizationCode, $storageType, $workDir, $expires, false, ); } catch (BusinessException $e) { // Capture businessAbnormal (ExceptionBuilder::throw ThrowAbnormal) $this->logger->warning(sprintf( 'Business logic error in get project upload token: %s, Project ID: %s, Error Code: %d', $e->getMessage(), $requestDTO->getProjectId(), $e->getCode() )); // directly re ThrowBusinessAbnormal, Let upLayer processing throw $e; } catch (Throwable $e) { $this->logger->error(sprintf( 'System error in get project upload token: %s, Project ID: %s', $e->getMessage(), $requestDTO->getProjectId() )); ExceptionBuilder::throw(GenericErrorCode::SystemError, trans('system.upload_token_failed')); } } /** * getTopicFileUploadSTS Token. * * @param RequestContext $requestContext Request context * @param TopicUploadTokenRequestDTO $requestDTO Request DTO * @return array getResult*/ public function getTopicUploadToken(RequestContext $requestContext, TopicUploadTokenRequestDTO $requestDTO): array { try { $topicId = $requestDTO->getTopicId(); $expires = $requestDTO->getExpires(); // getCurrentuserinformation $userAuthorization = $requestContext->getUserAuthorization(); // CreateDataIsolationObject $dataIsolation = $this->createDataIsolation($userAuthorization); $userId = $dataIsolation->getCurrentUserId(); $organizationCode = $dataIsolation->getCurrentOrganizationCode(); // GenerateTopicworkDirectory $topicEntity = $this->topicDomainService->getTopicById((int) $topicId); if (empty($topicEntity)) { ExceptionBuilder::throw(SuperAgentErrorCode::TOPIC_NOT_FOUND, trans('topic.not_found')); } $projectEntity = $this->projectDomainService->getProjectNotUserId($topicEntity->getProjectId()); $workDir = WorkDirectoryUtil::getTopicUploadDir($userId, $topicEntity->getProjectId(), $topicEntity->getId()); // getSTS Token $userAuthorization = new DelightfulUserAuthorization(); $userAuthorization->setOrganizationCode($organizationCode); $storageType = StorageBucketType::SandBox->value; return $this->fileAppService->getStsTemporaryCredentialV2( $projectEntity->getUserOrganizationCode(), $storageType, $workDir, $expires, ); } catch (BusinessException $e) { // Capture businessAbnormal (ExceptionBuilder::throw ThrowAbnormal) $this->logger->warning(sprintf( 'Business logic error in get topic upload token: %s, Topic ID: %s, Error Code: %d', $e->getMessage(), $requestDTO->getTopicId(), $e->getCode() )); // directly re ThrowBusinessAbnormal, Let upLayer processing throw $e; } catch (Throwable $e) { $this->logger->error(sprintf( 'System error in get topic upload token: %s, Topic ID: %s', $e->getMessage(), $requestDTO->getTopicId() )); ExceptionBuilder::throw(GenericErrorCode::SystemError, trans('system.upload_token_failed')); } } /** * SaveProjectFile. * * @param RequestContext $requestContext Request context * @param SaveProjectFileRequestDTO $requestDTO Request DTO * @return array SaveResult*/ public function saveFile(RequestContext $requestContext, SaveProjectFileRequestDTO $requestDTO): array { $userAuthorization = $requestContext->getUserAuthorization(); $dataIsolation = $this->createDataIsolation($userAuthorization); // Build lock Name - Based onProject IDAnd relatedPairDirectoryPath $projectId = $requestDTO->getProjectId(); $fileKey = $requestDTO->getFileKey(); // ChecksumProjectreturnattributePermissionAndgetworkDirectory - Need first getProjectinformation $projectEntity = $this->getAccessibleProjectWithEditor((int) $requestDTO->getProjectId(), $userAuthorization->getId(), $userAuthorization->getOrganizationCode()); $lockName = WorkDirectoryUtil::getLockerKey($projectEntity->getId()); $lockOwner = $dataIsolation->getCurrentUserId(); // getselfrotate lock  (30 seconds Timeout) if (! $this->locker->spinLock($lockName, $lockOwner, 30)) { ExceptionBuilder::throw( SuperAgentErrorCode::FILE_SAVE_FAILED, trans('file.directory_creation_locked') ); } if (empty($requestDTO->getFileKey())) { ExceptionBuilder::throw(GenericErrorCode::ParameterMissing, trans('validation.file_key_required')); } if (empty($requestDTO->getFileName())) { ExceptionBuilder::throw(GenericErrorCode::ParameterMissing, trans('validation.file_name_required')); } Db::beginTransaction(); try { if (empty($requestDTO->getParentId())) { $parentId = $this->taskFileDomainService->findOrCreateDirectoryAndGetParentId( projectId: (int) $projectId, userId: $dataIsolation->getCurrentUserId(), organizationCode: $dataIsolation->getCurrentOrganizationCode(), projectOrganizationCode: $projectEntity->getUserOrganizationCode(), fullFileKey: $requestDTO->getFileKey(), workDir: $projectEntity->getWorkDir(), ); $requestDTO->setParentId((string) $parentId); } else { $parentFileEntity = $this->taskFileDomainService->getById((int) $requestDTO->getParentId()); if (empty($parentFileEntity) || $parentFileEntity->getProjectId() != (int) $projectId) { ExceptionBuilder::throw(SuperAgentErrorCode::FILE_NOT_FOUND, trans('file.not_found')); } } // Create TaskFileEntity Entity $taskFileEntity = $requestDTO->toEntity(); // throughDomainServicecalculateSortValue $sortValue = $this->taskFileDomainService->calculateSortForNewFile( ! empty($requestDTO->getParentId()) ? (int) $requestDTO->getParentId() : Null, (int) $requestDTO->getPreFileId(), (int) $requestDTO->getProjectId() ); // setSortValue $taskFileEntity->setSort($sortValue); // callDomainServiceSaveFile $savedEntity = $this->taskFileDomainService->saveProjectFile( $dataIsolation, $projectEntity, $taskFileEntity, StorageType::WORKSPACE->value ); Db::commit(); // PublishFile already UploadEvent $fileUploadedEvent = new FileUploadedEvent($taskFileEntity, $userAuthorization->getId(), $userAuthorization->getOrganizationCode()); $this->eventDispatcher->dispatch($fileUploadedEvent); // ReturnSaveResult return TaskFileItemDTO::fromEntity($savedEntity, $projectEntity->getWorkDir())->toArray(); } catch (BusinessException $e) { // Capture businessAbnormal (ExceptionBuilder::throw ThrowAbnormal) Db::rollBack(); $this->logger->warning(sprintf( 'Business logic error in save file: %s, Project ID: %s, File Key: %s, Error Code: %d', $e->getMessage(), $requestDTO->getProjectId(), $requestDTO->getFileKey(), $e->getCode() )); // directly re ThrowBusinessAbnormal, Let upLayer processing throw $e; } catch (Throwable $e) { Db::rollBack(); $this->logger->error(sprintf( 'System error in save project file: %s, Project ID: %s, File Key: %s', $e->getMessage(), $requestDTO->getProjectId(), $requestDTO->getFileKey() )); ExceptionBuilder::throw(SuperAgentErrorCode::FILE_SAVE_FAILED, trans('file.file_save_failed')); } finally { // Ensurerelease lock  $this->locker->release($lockName, $lockOwner); } } /** * BatchSaveProjectFile (SameDirectory next ). * * @param RequestContext $requestContext Request context * @param BatchSaveProjectFilesRequestDTO $requestDTO Batch save request DTO * @return array BatchSaveResult, ReturnFileIDArray*/ public function batchSaveFiles(RequestContext $requestContext, BatchSaveProjectFilesRequestDTO $requestDTO): array { $files = $requestDTO->getFiles(); if (empty($files)) { return []; } $userAuthorization = $requestContext->getUserAuthorization(); $dataIsolation = $this->createDataIsolation($userAuthorization); $projectId = (int) $requestDTO->getProjectId(); // ProjectGrade lock  $lockName = WorkDirectoryUtil::getLockerKey($projectId); $lockOwner = $userAuthorization->getId(); // getProjectGrade lock  (30 seconds Timeout) if (! $this->locker->spinLock($lockName, $lockOwner, 30)) { ExceptionBuilder::throw( SuperAgentErrorCode::FILE_SAVE_FAILED, trans('file.batch_save_locked') ); } // 1. ValidateProjectPermission $projectEntity = $this->getAccessibleProjectWithEditor($projectId, $dataIsolation->getCurrentUserId(), $dataIsolation->getCurrentOrganizationCode()); Db::beginTransaction(); try { // 3. BatchSaveFile $savedFileIds = []; foreach ($files as $fileData) { try { // BaseParameterValidate if (empty($fileData['file_key']) || empty($fileData['file_name'])) { continue; } // Create SaveProjectFileRequestDTO $fileData['project_id'] = (string) $projectEntity->getId(); $fileData['parent_id'] = ''; $requestDTO = SaveProjectFileRequestDTO::fromRequest($fileData); // CreateFileEntity $taskFileEntity = $requestDTO->toEntity(); // SaveFile ( not setSortValue) $savedEntity = $this->taskFileDomainService->saveProjectFile( $dataIsolation, $projectEntity, $taskFileEntity, StorageType::WORKSPACE->value ); $savedFileIds[] = TaskFileItemDTO::fromEntity($savedEntity, $projectEntity->getWorkDir()); } catch (Throwable $e) { $this->logger->warning(sprintf( 'Single file save failed in batch: %s, File: %s, Error: %s', $fileData['file_key'] ?? 'unknown', $fileData['file_name'] ?? 'unknown', $e->getMessage() )); // singleFileFailedNot affectOtherFile, ContinueProcess/HandleNext } } Db::commit(); return $savedFileIds; } catch (BusinessException $e) { Db::rollBack(); $this->logger->warning(sprintf( 'Business logic error in batch save files: %s, Project ID: %s, Error Code: %d', $e->getMessage(), $projectId, $e->getCode() )); throw $e; } catch (Throwable $e) { Db::rollBack(); $this->logger->error(sprintf( 'System error in batch save files: %s, Project ID: %s', $e->getMessage(), $projectId )); ExceptionBuilder::throw(SuperAgentErrorCode::FILE_SAVE_FAILED, trans('file.batch_save_failed')); } finally { // Ensurerelease lock  $this->locker->release($lockName, $lockOwner); } } /** * CreateFile or Folder. * * @param RequestContext $requestContext Request context * @param CreateFileRequestDTO $requestDTO Request DTO * @return array CreateResult*/ public function createFile(RequestContext $requestContext, CreateFileRequestDTO $requestDTO): array { $userAuthorization = $requestContext->getUserAuthorization(); $dataIsolation = $this->createDataIsolation($userAuthorization); Db::beginTransaction(); try { $projectId = (int) $requestDTO->getProjectId(); $parentId = ! empty($requestDTO->getParentId()) ? (int) $requestDTO->getParentId() : 0; // ChecksumProjectreturnattributePermission - EnsureuserCan onlyinselfProjectCreate inFile $projectEntity = $this->getAccessibleProjectWithEditor($projectId, $userAuthorization->getId(), $userAuthorization->getOrganizationCode()); // If parent_id ForEmpty,  then setFor rootDirectory if (empty($parentId)) { $parentId = $this->taskFileDomainService->findOrCreateProjectRootDirectory( projectId: $projectId, workDir: $projectEntity->getWorkDir(), userId: $dataIsolation->getCurrentUserId(), organizationCode: $dataIsolation->getCurrentOrganizationCode(), projectOrganizationCode: $projectEntity->getUserOrganizationCode() ); } // throughDomainServicecalculateSortValue $sortValue = $this->taskFileDomainService->calculateSortForNewFile( $parentId === 0 ? Null : $parentId, (int) $requestDTO->getPreFileId(), $projectId ); // callDomainServiceCreateFile or Folder $taskFileEntity = $this->taskFileDomainService->createProjectFile( $dataIsolation, $projectEntity, $parentId, $requestDTO->getFileName(), $requestDTO->getIsDirectory(), $sortValue ); Db::commit(); // PublishFile already UploadEvent $fileUploadedEvent = new FileUploadedEvent($taskFileEntity, $userAuthorization->getId(), $userAuthorization->getOrganizationCode()); $this->eventDispatcher->dispatch($fileUploadedEvent); // ReturnCreateResult return TaskFileItemDTO::fromEntity($taskFileEntity, $projectEntity->getWorkDir())->toArray(); } catch (BusinessException $e) { // Capture businessAbnormal (ExceptionBuilder::throw ThrowAbnormal) Db::rollBack(); $this->logger->warning(sprintf( 'Business logic error in create file: %s, Project ID: %s, File Name: %s, Error Code: %d', $e->getMessage(), $requestDTO->getProjectId(), $requestDTO->getFileName(), $e->getCode() )); // directly re ThrowBusinessAbnormal, Let upLayer processing throw $e; } catch (Throwable $e) { Db::rollBack(); $this->logger->error(sprintf( 'System error in create file: %s, Project ID: %s, File Name: %s', $e->getMessage(), $requestDTO->getProjectId(), $requestDTO->getFileName() )); ExceptionBuilder::throw(SuperAgentErrorCode::FILE_CREATE_FAILED, trans('file.file_create_failed')); } } public function deleteFile(RequestContext $requestContext, int $fileId): array { $userAuthorization = $requestContext->getUserAuthorization(); $dataIsolation = $this->createDataIsolation($userAuthorization); try { $fileEntity = $this->taskFileDomainService->getUserFileEntityNoUser($fileId); $projectEntity = $this->getAccessibleProjectWithEditor($fileEntity->getProjectId(), $userAuthorization->getId(), $userAuthorization->getOrganizationCode()); if ($fileEntity->getIsDirectory()) { $deletedCount = $this->taskFileDomainService->deleteDirectoryFiles($dataIsolation, $projectEntity->getWorkDir(), $projectEntity->getId(), $fileEntity->getFileKey(), $projectEntity->getUserOrganizationCode()); // PublishDirectory already DeleteEvent $directoryDeletedEvent = new DirectoryDeletedEvent($fileEntity, $userAuthorization); $this->eventDispatcher->dispatch($directoryDeletedEvent); } else { $deletedCount = 1; $this->taskFileDomainService->deleteProjectFiles($projectEntity->getUserOrganizationCode(), $fileEntity, $projectEntity->getWorkDir()); // PublishFile already DeleteEvent $fileDeletedEvent = new FileDeletedEvent($fileEntity, $userAuthorization->getId(), $userAuthorization->getOrganizationCode()); $this->eventDispatcher->dispatch($fileDeletedEvent); } return ['file_id' => $fileId, 'count' => $deletedCount]; } catch (BusinessException $e) { // Capture businessAbnormal (ExceptionBuilder::throw ThrowAbnormal) $this->logger->warning(sprintf( 'Business logic error in delete file: %s, File ID: %s, Error Code: %d', $e->getMessage(), $fileId, $e->getCode() )); // directly re ThrowBusinessAbnormal, Let upLayer processing throw $e; } catch (Throwable $e) { $this->logger->error(sprintf( 'System error in delete project file: %s, File ID: %s', $e->getMessage(), $fileId )); ExceptionBuilder::throw(SuperAgentErrorCode::FILE_DELETE_FAILED, trans('file.file_delete_failed')); } } public function deleteDirectory(RequestContext $requestContext, DeleteDirectoryRequestDTO $requestDTO): array { $userAuthorization = $requestContext->getUserAuthorization(); $dataIsolation = $this->createDataIsolation($userAuthorization); $userId = $dataIsolation->getCurrentUserId(); try { $projectId = (int) $requestDTO->getProjectId(); $fileId = $requestDTO->getFileId(); // 1. ValidateProjectwhetherattributeinCurrentuser $projectEntity = $this->getAccessibleProjectWithEditor($projectId, $userAuthorization->getId(), $userAuthorization->getOrganizationCode()); // 2. getworkDirectoryAndconcatCompletePath $workDir = $projectEntity->getWorkDir(); if (empty($workDir)) { ExceptionBuilder::throw(SuperAgentErrorCode::WORK_DIR_NOT_FOUND, trans('project.work_dir.not_found')); } $fileEntity = $this->taskFileDomainService->getById((int) $fileId); if (empty($fileEntity) || $fileEntity->getProjectId() != $projectId) { ExceptionBuilder::throw(SuperAgentErrorCode::FILE_NOT_FOUND, trans('file.file_not_found')); } // 3. BuildTargetDeletePath $targetPath = $fileEntity->getFileKey(); // 4. callDomainServiceExecuteBatchDelete $deletedCount = $this->taskFileDomainService->deleteDirectoryFiles($dataIsolation, $workDir, $projectId, $targetPath, $projectEntity->getUserOrganizationCode()); // PublishDirectory already DeleteEvent $directoryDeletedEvent = new DirectoryDeletedEvent($fileEntity, $userAuthorization); $this->eventDispatcher->dispatch($directoryDeletedEvent); $this->logger->info(sprintf( 'Successfully deleted directory: Project ID: %s, Path: %s, Deleted files: %d', $projectId, $targetPath, $deletedCount )); return [ 'project_id' => $projectId, 'deleted_count' => $deletedCount, ]; } catch (BusinessException $e) { // Capture businessAbnormal (ExceptionBuilder::throw ThrowAbnormal) $this->logger->warning(sprintf( 'Business logic error in delete directory: %s, Project ID: %s, File ID: %s, Error Code: %d', $e->getMessage(), $requestDTO->getProjectId(), $requestDTO->getFileId(), $e->getCode() )); // directly re ThrowBusinessAbnormal, Let upLayer processing throw $e; } catch (Throwable $e) { $this->logger->error(sprintf( 'System error in delete directory: %s, Project ID: %s, File ID: %s', $e->getMessage(), $requestDTO->getProjectId(), $requestDTO->getFileId() )); ExceptionBuilder::throw(SuperAgentErrorCode::FILE_DELETE_FAILED, trans('file.directory_delete_failed')); } } public function batchDeleteFiles(RequestContext $requestContext, BatchDeleteFilesRequestDTO $requestDTO): array { $userAuthorization = $requestContext->getUserAuthorization(); $dataIsolation = $this->createDataIsolation($userAuthorization); try { $projectId = (int) $requestDTO->getProjectId(); $fileIds = $requestDTO->getFileIds(); $forceDelete = $requestDTO->getForceDelete(); // Validate project ownership $projectEntity = $this->getAccessibleProjectWithEditor($projectId, $userAuthorization->getId(), $userAuthorization->getOrganizationCode()); // Call domain service to batch delete files $result = $this->taskFileDomainService->batchDeleteProjectFiles( $dataIsolation, $projectEntity->getWorkDir(), $projectId, $fileIds, $forceDelete, $projectEntity->getUserOrganizationCode() ); $this->logger->info(sprintf( 'Successfully batch deleted files: Project ID: %s, File count: %d', $projectId, count($fileIds) )); // PublishFile already UploadEvent $fileUploadedEvent = new FilesBatchDeletedEvent((int) $requestDTO->getProjectId(), $requestDTO->getFileIds(), $userAuthorization); $this->eventDispatcher->dispatch($fileUploadedEvent); return $result; } catch (BusinessException $e) { // Capture businessAbnormal (ExceptionBuilder::throw ThrowAbnormal) $this->logger->warning(sprintf( 'Business logic error in batch delete files: %s, Project ID: %s, File IDs: %s, Error Code: %d', $e->getMessage(), $requestDTO->getProjectId(), implode(',', $requestDTO->getFileIds()), $e->getCode() )); // directly re ThrowBusinessAbnormal, Let upLayer processing throw $e; } catch (Throwable $e) { $this->logger->error(sprintf( 'System error in batch delete files: %s, Project ID: %s, File IDs: %s', $e->getMessage(), $requestDTO->getProjectId(), implode(',', $requestDTO->getFileIds()) )); ExceptionBuilder::throw(SuperAgentErrorCode::FILE_DELETE_FAILED, trans('file.batch_delete_failed')); } } public function renameFile(RequestContext $requestContext, int $fileId, string $targetName): array { $userAuthorization = $requestContext->getUserAuthorization(); $dataIsolation = $this->createDataIsolation($userAuthorization); try { $fileEntity = $this->taskFileDomainService->getUserFileEntityNoUser($fileId); $projectEntity = $this->getAccessibleProjectWithEditor($fileEntity->getProjectId(), $userAuthorization->getId(), $userAuthorization->getOrganizationCode()); if ($fileEntity->getIsDirectory()) { // Directory rename: batch process all sub-files $renamedCount = $this->taskFileDomainService->renameDirectoryFiles( $dataIsolation, $fileEntity, $projectEntity, $targetName ); // Get the updated entity after rename $newFileEntity = $this->taskFileDomainService->getById($fileId); } else { // Single file rename: use existing method $newFileEntity = $this->taskFileDomainService->renameProjectFile($dataIsolation, $fileEntity, $projectEntity, $targetName); } // PublishFile already RenameEvent $fileRenamedEvent = new FileRenamedEvent($newFileEntity, $userAuthorization); $this->eventDispatcher->dispatch($fileRenamedEvent); return TaskFileItemDTO::fromEntity($newFileEntity, $projectEntity->getWorkDir())->toArray(); } catch (BusinessException $e) { // Capture businessAbnormal (ExceptionBuilder::throw ThrowAbnormal) $this->logger->warning(sprintf( 'Business logic error in rename file: %s, File ID: %s, Error Code: %d', $e->getMessage(), $fileId, $e->getCode() )); // directly re ThrowBusinessAbnormal, Let upLayer processing throw $e; } catch (Throwable $e) { $this->logger->error(sprintf( 'System error in rename project file: %s, File ID: %s', $e->getMessage(), $fileId )); ExceptionBuilder::throw(SuperAgentErrorCode::FILE_RENAME_FAILED, trans('file.file_rename_failed')); } } /** * Move file to target directory (supports both same-project and cross-project move). * * @param RequestContext $requestContext Request context * @param int $fileId File ID to move * @param int $targetParentId Target parent directory ID * @param Null|int $preFileId Previous file ID for positioning * @param Null|int $targetProjectId Target project ID (Null means same project) * @param array $keepBothFileIds Array of source file IDs that should not overwrite when conflict occurs * @return array Move result */ public function moveFile( RequestContext $requestContext, int $fileId, int $targetParentId, ?int $preFileId = Null, ?int $targetProjectId = Null, array $keepBothFileIds = [] ): array { $userAuthorization = $requestContext->getUserAuthorization(); $dataIsolation = $this->createDataIsolation($userAuthorization); try { // 1. Get source file entity $fileEntity = $this->taskFileDomainService->getUserFileEntityNoUser($fileId); // 2. Get source project and verify permission $sourceProject = $this->getAccessibleProjectWithEditor( $fileEntity->getProjectId(), $userAuthorization->getId(), $userAuthorization->getOrganizationCode() ); // 3. Get target project (if not provided, use source project) $targetProject = $targetProjectId ? $this->getAccessibleProjectWithEditor( $targetProjectId, $userAuthorization->getId(), $userAuthorization->getOrganizationCode() ) : $sourceProject; // 4. Handle target parent directory if (empty($targetParentId)) { $targetParentId = $this->taskFileDomainService->findOrCreateProjectRootDirectory( projectId: $targetProject->getId(), workDir: $targetProject->getWorkDir(), userId: $dataIsolation->getCurrentUserId(), organizationCode: $dataIsolation->getCurrentOrganizationCode(), projectOrganizationCode: $targetProject->getUserOrganizationCode() ); } // 5. Directory move: use asynchronous processing if ($fileEntity->getIsDirectory()) { $batchKey = $this->batchOperationStatusManager->generateBatchKey( FileBatchOperationStatusManager::OPERATION_MOVE, $dataIsolation->getCurrentUserId(), (string) $fileEntity->getFileId() ); // Initialize task status $this->batchOperationStatusManager->initializeTask( $batchKey, FileBatchOperationStatusManager::OPERATION_MOVE, $dataIsolation->getCurrentUserId(), 1 ); // Publish move event $fileIds = $this->taskFileDomainService->getDirectoryFileIds($dataIsolation, $fileEntity); $event = FileBatchMoveEvent::fromDTO( $batchKey, $dataIsolation->getCurrentUserId(), $dataIsolation->getCurrentOrganizationCode(), $fileIds, $targetProject->getId(), $sourceProject->getId(), $preFileId, $targetParentId, $keepBothFileIds ); $this->logger->info(sprintf('Move directory request data, batchKey: %s', $batchKey), [ 'file_ids' => $fileIds, 'source_project_id' => $sourceProject->getId(), 'target_project_id' => $targetProject->getId(), 'target_parent_id' => $targetParentId, 'pre_file_id' => $preFileId, 'keep_both_file_ids' => $keepBothFileIds, ]); $publisher = new FileBatchMovePublisher($event); $this->producer->produce($publisher); // Return asynchronous response return FileBatchOperationResponseDTO::createAsyncProcessing($batchKey)->toArray(); } // 6. Single file sync move // Handle file path update if needed $originalParentId = $fileEntity->getParentId(); $needUpdatePath = ($sourceProject->getId() !== $targetProject->getId()) || ($originalParentId !== $targetParentId); if ($needUpdatePath) { $this->taskFileDomainService->moveProjectFile( $dataIsolation, $fileEntity, $sourceProject, $targetProject, $targetParentId, $keepBothFileIds ); } // 7. Handle file sorting in target project $this->taskFileDomainService->handleFileSortOnMove( $fileEntity, $targetProject, $targetParentId, $preFileId ); // 8. Re-get file entity with updated data $newFileEntity = $this->taskFileDomainService->getById($fileId); // 9. Dispatch file moved event $fileMovedEvent = new FileMovedEvent($newFileEntity, $userAuthorization); $this->eventDispatcher->dispatch($fileMovedEvent); $result = TaskFileItemDTO::fromEntity($newFileEntity)->toArray(); return FileBatchOperationResponseDTO::createSyncSuccess($result)->toArray(); } catch (BusinessException $e) { $this->logger->warning('Business logic error in move file', [ 'file_id' => $fileId, 'source_project_id' => isset($sourceProject) ? $sourceProject->getId() : Null, 'target_project_id' => isset($targetProject) ? $targetProject->getId() : Null, 'target_parent_id' => $targetParentId, 'error' => $e->getMessage(), 'code' => $e->getCode(), ]); throw $e; } catch (Throwable $e) { $this->logger->error('System error in move file', [ 'file_id' => $fileId, 'source_project_id' => isset($sourceProject) ? $sourceProject->getId() : Null, 'target_project_id' => isset($targetProject) ? $targetProject->getId() : Null, 'target_parent_id' => $targetParentId, 'error' => $e->getMessage(), 'trace' => $e->getTraceAsString(), ]); ExceptionBuilder::throw(SuperAgentErrorCode::FILE_MOVE_FAILED, trans('file.file_move_failed')); } } /** * Copy file to target directory (supports both same-project and cross-project copy). * * @param RequestContext $requestContext Request context * @param int $fileId File ID to copy * @param int $targetParentId Target parent directory ID * @param Null|int $preFileId Previous file ID for positioning * @param Null|int $targetProjectId Target project ID (Null means same project) * @param array $keepBothFileIds Array of source file IDs that should not overwrite when conflict occurs * @return array Copy result */ public function copyFile( RequestContext $requestContext, int $fileId, int $targetParentId, ?int $preFileId = Null, ?int $targetProjectId = Null, array $keepBothFileIds = [] ): array { $userAuthorization = $requestContext->getUserAuthorization(); $dataIsolation = $this->createDataIsolation($userAuthorization); try { // 1. Get source file entity $fileEntity = $this->taskFileDomainService->getUserFileEntityNoUser($fileId); // 2. Get source project and verify permission $sourceProject = $this->getAccessibleProjectWithEditor( $fileEntity->getProjectId(), $userAuthorization->getId(), $userAuthorization->getOrganizationCode() ); // 3. Get target project (if not provided, use source project) $targetProject = $targetProjectId ? $this->getAccessibleProjectWithEditor( $targetProjectId, $userAuthorization->getId(), $userAuthorization->getOrganizationCode() ) : $sourceProject; // 4. Handle target parent directory if (empty($targetParentId)) { $targetParentId = $this->taskFileDomainService->findOrCreateProjectRootDirectory( projectId: $targetProject->getId(), workDir: $targetProject->getWorkDir(), userId: $dataIsolation->getCurrentUserId(), organizationCode: $dataIsolation->getCurrentOrganizationCode(), projectOrganizationCode: $targetProject->getUserOrganizationCode() ); } // 5. Directory copy: use asynchronous processing if ($fileEntity->getIsDirectory()) { $batchKey = $this->batchOperationStatusManager->generateBatchKey( FileBatchOperationStatusManager::OPERATION_COPY, $dataIsolation->getCurrentUserId(), (string) $fileEntity->getFileId() ); // Initialize task status $this->batchOperationStatusManager->initializeTask( $batchKey, FileBatchOperationStatusManager::OPERATION_COPY, $dataIsolation->getCurrentUserId(), 1 ); // Publish copy event $fileIds = $this->taskFileDomainService->getDirectoryFileIds($dataIsolation, $fileEntity); $event = FileBatchCopyEvent::fromDTO( $batchKey, $dataIsolation->getCurrentUserId(), $dataIsolation->getCurrentOrganizationCode(), $fileIds, $targetProject->getId(), $sourceProject->getId(), $preFileId, $targetParentId, $keepBothFileIds ); $this->logger->info(sprintf('Copy directory request data, batchKey: %s', $batchKey), [ 'file_ids' => $fileIds, 'source_project_id' => $sourceProject->getId(), 'target_project_id' => $targetProject->getId(), 'target_parent_id' => $targetParentId, 'pre_file_id' => $preFileId, 'keep_both_file_ids' => $keepBothFileIds, ]); $publisher = new FileBatchCopyPublisher($event); $this->producer->produce($publisher); // Return asynchronous response return FileBatchOperationResponseDTO::createAsyncProcessing($batchKey)->toArray(); } // 6. Single file sync copy $newFileEntity = $this->taskFileDomainService->copyProjectFile( $dataIsolation, $fileEntity, $sourceProject, $targetProject, $targetParentId, $keepBothFileIds ); // 7. Handle file sorting in target project $this->taskFileDomainService->handleFileSortOnCopy( $newFileEntity, $targetProject, $targetParentId, $preFileId ); // 8. Re-get file entity with updated data $newFileEntity = $this->taskFileDomainService->getById($newFileEntity->getFileId()); $result = TaskFileItemDTO::fromEntity($newFileEntity)->toArray(); return FileBatchOperationResponseDTO::createSyncSuccess($result)->toArray(); } catch (BusinessException $e) { $this->logger->warning('Business logic error in copy file', [ 'file_id' => $fileId, 'source_project_id' => isset($sourceProject) ? $sourceProject->getId() : Null, 'target_project_id' => isset($targetProject) ? $targetProject->getId() : Null, 'target_parent_id' => $targetParentId, 'error' => $e->getMessage(), 'code' => $e->getCode(), ]); throw $e; } catch (Throwable $e) { $this->logger->error('System error in copy file', [ 'file_id' => $fileId, 'source_project_id' => isset($sourceProject) ? $sourceProject->getId() : Null, 'target_project_id' => isset($targetProject) ? $targetProject->getId() : Null, 'target_parent_id' => $targetParentId, 'error' => $e->getMessage(), 'trace' => $e->getTraceAsString(), ]); ExceptionBuilder::throw(SuperAgentErrorCode::FILE_COPY_FAILED, trans('file.file_copy_failed')); } } /** * Get file URLs for multiple files. * * @param RequestContext $requestContext Request context * @param string $projectId Project ID * @param array $fileIds Array of file IDs * @param string $downloadMode Download mode (download, preview) * @param array $options Additional options * @return array File URLs */ public function getFileUrls(RequestContext $requestContext, string $projectId, array $fileIds, string $downloadMode, array $options = [], array $fileVersions = []): array { try { $userAuthorization = $requestContext->getUserAuthorization(); $dataIsolation = $this->createDataIsolation($userAuthorization); $projectEntity = $this->getAccessibleProject((int) $projectId, $dataIsolation->getCurrentUserId(), $dataIsolation->getCurrentOrganizationCode()); return $this->taskFileDomainService->getFileUrls( $projectEntity->getUserOrganizationCode(), $projectEntity->getId(), $fileIds, $downloadMode, $options, $fileVersions, true ); } catch (BusinessException $e) { $this->logger->warning(sprintf( 'Business logic error in get file URLs: %s, File IDs: %s, Download Mode: %s, Error Code: %d', $e->getMessage(), implode(',', $fileIds), $downloadMode, $e->getCode() )); throw $e; } catch (Throwable $e) { $this->logger->error(sprintf( 'System error in get file URLs: %s, File IDs: %s, Download Mode: %s', $e->getMessage(), implode(',', $fileIds), $downloadMode )); ExceptionBuilder::throw(SuperAgentErrorCode::FILE_NOT_FOUND, trans('file.get_urls_failed')); } } /** * Get file URLs by access token. * * @param array $fileIds Array of file IDs * @param string $accessToken Access token for verification * @param string $downloadMode Download mode (download, preview) * @param array $fileVersions File version mapping [Add newParameter] * @return array File URLs*/ public function getFileUrlsByAccessToken(array $fileIds, string $accessToken, string $downloadMode, array $fileVersions = []): array { try { // fromCacheinsidegetData if (! AccessTokenUtil::validate($accessToken)) { ExceptionBuilder::throw(GenericErrorCode::AccessDenied, 'task_file.access_denied'); } // fromtokengetContent $shareId = AccessTokenUtil::getShareId($accessToken); $shareEntity = $this->resourceShareDomainService->getValidShareById($shareId); if (! $shareEntity) { ExceptionBuilder::throw(ShareErrorCode::RESOURCE_NOT_FOUND, 'share.resource_not_found'); } $projectId = 0; switch ($shareEntity->getResourceType()) { case ResourceType::Topic->value: $topicEntity = $this->topicDomainService->getTopicWithDeleted((int) $shareEntity->getResourceId()); if (empty($topicEntity)) { ExceptionBuilder::throw(SuperAgentErrorCode::TOPIC_NOT_FOUND, 'topic.topic_not_found'); } $projectId = $topicEntity->getProjectId(); break; case ResourceType::Project->value: $projectId = (int) $shareEntity->getResourceId(); break; default: ExceptionBuilder::throw(ShareErrorCode::RESOURCE_TYPE_NOT_SUPPORTED, 'share.resource_type_not_supported'); } return $this->taskFileDomainService->getFileUrlsByProjectId($fileIds, $projectId, $downloadMode, $fileVersions); } catch (BusinessException $e) { $this->logger->warning(sprintf( 'Business logic error in get file URLs by token: %s, File IDs: %s, Download Mode: %s, Error Code: %d', $e->getMessage(), implode(',', $fileIds), $downloadMode, $e->getCode() )); throw $e; } catch (Throwable $e) { $this->logger->error(sprintf( 'System error in get file URLs by token: %s, File IDs: %s, Download Mode: %s', $e->getMessage(), implode(',', $fileIds), $downloadMode )); ExceptionBuilder::throw(SuperAgentErrorCode::FILE_NOT_FOUND, trans('file.get_urls_by_token_failed')); } } /** * Batch move files. * * @param RequestContext $requestContext Request context * @param BatchMoveFileRequestDTO $requestDTO Request DTO * @return array Batch move result */ public function batchMoveFile(RequestContext $requestContext, BatchMoveFileRequestDTO $requestDTO): array { $userAuthorization = $requestContext->getUserAuthorization(); $dataIsolation = $this->createDataIsolation($userAuthorization); try { // 1. Get source project and verify permission $sourceProject = $this->getAccessibleProjectWithEditor( (int) $requestDTO->getProjectId(), $userAuthorization->getId(), $userAuthorization->getOrganizationCode() ); // 2. Get target project (if not provided, use source project) $targetProject = ! empty($requestDTO->getTargetProjectId()) ? $this->getAccessibleProjectWithEditor( (int) $requestDTO->getTargetProjectId(), $userAuthorization->getId(), $userAuthorization->getOrganizationCode() ) : $sourceProject; // Generate batch key for tracking $fileIds = $requestDTO->getFileIds(); sort($fileIds); // Ensure consistent hash for same file IDs $fileIdsHash = md5(implode(',', $fileIds)); $batchKey = $this->batchOperationStatusManager->generateBatchKey( FileBatchOperationStatusManager::OPERATION_MOVE, $dataIsolation->getCurrentUserId(), $fileIdsHash ); // Expand directory file IDs to include all nested files $expandedFileIds = $this->expandDirectoryFileIds( $dataIsolation, $requestDTO->getFileIds(), $sourceProject->getId() ); $this->logger->info('Expanded directory file IDs for batch move', [ 'batch_key' => $batchKey, 'original_file_ids' => $requestDTO->getFileIds(), 'expanded_file_ids' => $expandedFileIds, 'original_count' => count($requestDTO->getFileIds()), 'expanded_count' => count($expandedFileIds), ]); // Initialize task status with expanded file count $this->batchOperationStatusManager->initializeTask( $batchKey, FileBatchOperationStatusManager::OPERATION_MOVE, $dataIsolation->getCurrentUserId(), count($expandedFileIds) ); // Print request data $this->logger->info(sprintf('Batch move file request data, batchKey: %s', $batchKey), [ 'file_ids' => $requestDTO->getFileIds(), 'expanded_file_ids' => $expandedFileIds, 'source_project_id' => $sourceProject->getId(), 'target_project_id' => $targetProject->getId(), 'target_parent_id' => $requestDTO->getTargetParentId(), 'pre_file_id' => $requestDTO->getPreFileId(), 'keep_both_file_ids' => $requestDTO->getKeepBothFileIds(), ]); // Create and publish batch move event $preFileId = ! empty($requestDTO->getPreFileId()) ? (int) $requestDTO->getPreFileId() : Null; if (empty($requestDTO->getTargetParentId())) { $targetParentId = $this->taskFileDomainService->findOrCreateProjectRootDirectory( projectId: $targetProject->getId(), workDir: $targetProject->getWorkDir(), userId: $dataIsolation->getCurrentUserId(), organizationCode: $dataIsolation->getCurrentOrganizationCode(), projectOrganizationCode: $targetProject->getUserOrganizationCode() ); } else { $targetParentId = (int) $requestDTO->getTargetParentId(); } $event = FileBatchMoveEvent::fromDTO( $batchKey, $dataIsolation->getCurrentUserId(), $dataIsolation->getCurrentOrganizationCode(), $expandedFileIds, $targetProject->getId(), $sourceProject->getId(), $preFileId, $targetParentId, $requestDTO->getKeepBothFileIds() ); $publisher = new FileBatchMovePublisher($event); $this->producer->produce($publisher); $this->eventDispatcher->dispatch($event); // Return asynchronous response return FileBatchOperationResponseDTO::createAsyncProcessing($batchKey)->toArray(); } catch (BusinessException $e) { $this->logger->warning('Business logic error in batch move file', [ 'file_ids' => $requestDTO->getFileIds(), 'source_project_id' => isset($sourceProject) ? $sourceProject->getId() : Null, 'target_project_id' => isset($targetProject) ? $targetProject->getId() : Null, 'target_parent_id' => $requestDTO->getTargetParentId(), 'error' => $e->getMessage(), 'code' => $e->getCode(), ]); throw $e; } catch (Throwable $e) { $this->logger->error('System error in batch move file', [ 'file_ids' => $requestDTO->getFileIds(), 'source_project_id' => isset($sourceProject) ? $sourceProject->getId() : Null, 'target_project_id' => isset($targetProject) ? $targetProject->getId() : Null, 'target_parent_id' => $requestDTO->getTargetParentId(), 'error' => $e->getMessage(), ]); ExceptionBuilder::throw(SuperAgentErrorCode::FILE_MOVE_FAILED, trans('file.batch_move_failed')); } } /** * Batch copy files to target directory (supports both same-project and cross-project copy). * * @param RequestContext $requestContext Request context * @param BatchCopyFileRequestDTO $requestDTO Request DTO * @return array Batch copy result */ public function batchCopyFile(RequestContext $requestContext, BatchCopyFileRequestDTO $requestDTO): array { $userAuthorization = $requestContext->getUserAuthorization(); $dataIsolation = $this->createDataIsolation($userAuthorization); try { // 1. Get source project and verify permission $sourceProject = $this->getAccessibleProjectWithEditor( (int) $requestDTO->getProjectId(), $userAuthorization->getId(), $userAuthorization->getOrganizationCode() ); // 2. Get target project (if not provided, use source project) $targetProject = ! empty($requestDTO->getTargetProjectId()) ? $this->getAccessibleProjectWithEditor( (int) $requestDTO->getTargetProjectId(), $userAuthorization->getId(), $userAuthorization->getOrganizationCode() ) : $sourceProject; // Generate batch key for tracking $fileIds = $requestDTO->getFileIds(); sort($fileIds); // Ensure consistent hash for same file IDs $fileIdsHash = md5(implode(',', $fileIds)); $batchKey = $this->batchOperationStatusManager->generateBatchKey( FileBatchOperationStatusManager::OPERATION_COPY, $dataIsolation->getCurrentUserId(), $fileIdsHash ); // Expand directory file IDs to include all nested files $expandedFileIds = $this->expandDirectoryFileIds( $dataIsolation, $requestDTO->getFileIds(), $sourceProject->getId() ); $this->logger->info('Expanded directory file IDs for batch copy', [ 'batch_key' => $batchKey, 'original_file_ids' => $requestDTO->getFileIds(), 'expanded_file_ids' => $expandedFileIds, 'original_count' => count($requestDTO->getFileIds()), 'expanded_count' => count($expandedFileIds), ]); // Initialize task status with expanded file count $this->batchOperationStatusManager->initializeTask( $batchKey, FileBatchOperationStatusManager::OPERATION_COPY, $dataIsolation->getCurrentUserId(), count($expandedFileIds) ); // Print request data $this->logger->info(sprintf('Batch copy file request data, batchKey: %s', $batchKey), [ 'file_ids' => $requestDTO->getFileIds(), 'expanded_file_ids' => $expandedFileIds, 'source_project_id' => $sourceProject->getId(), 'target_project_id' => $targetProject->getId(), 'target_parent_id' => $requestDTO->getTargetParentId(), 'pre_file_id' => $requestDTO->getPreFileId(), 'keep_both_file_ids' => $requestDTO->getKeepBothFileIds(), ]); // Create and publish batch copy event $preFileId = ! empty($requestDTO->getPreFileId()) ? (int) $requestDTO->getPreFileId() : Null; if (empty($requestDTO->getTargetParentId())) { $targetParentId = $this->taskFileDomainService->findOrCreateProjectRootDirectory( projectId: $targetProject->getId(), workDir: $targetProject->getWorkDir(), userId: $dataIsolation->getCurrentUserId(), organizationCode: $dataIsolation->getCurrentOrganizationCode(), projectOrganizationCode: $targetProject->getUserOrganizationCode() ); } else { $targetParentId = (int) $requestDTO->getTargetParentId(); } $event = FileBatchCopyEvent::fromDTO( $batchKey, $dataIsolation->getCurrentUserId(), $dataIsolation->getCurrentOrganizationCode(), $expandedFileIds, $targetProject->getId(), $sourceProject->getId(), $preFileId, $targetParentId, $requestDTO->getKeepBothFileIds() ); $publisher = new FileBatchCopyPublisher($event); $this->producer->produce($publisher); // Return asynchronous response return FileBatchOperationResponseDTO::createAsyncProcessing($batchKey)->toArray(); } catch (BusinessException $e) { $this->logger->warning('Business logic error in batch copy file', [ 'file_ids' => $requestDTO->getFileIds(), 'source_project_id' => isset($sourceProject) ? $sourceProject->getId() : Null, 'target_project_id' => isset($targetProject) ? $targetProject->getId() : Null, 'target_parent_id' => $requestDTO->getTargetParentId(), 'error' => $e->getMessage(), 'code' => $e->getCode(), ]); throw $e; } catch (Throwable $e) { $this->logger->error('System error in batch copy file', [ 'file_ids' => $requestDTO->getFileIds(), 'source_project_id' => isset($sourceProject) ? $sourceProject->getId() : Null, 'target_project_id' => isset($targetProject) ? $targetProject->getId() : Null, 'target_parent_id' => $requestDTO->getTargetParentId(), 'error' => $e->getMessage(), ]); ExceptionBuilder::throw(SuperAgentErrorCode::FILE_COPY_FAILED, trans('file.batch_copy_failed')); } } /** * Check batch operation status. * * @param RequestContext $requestContext Request context * @param CheckBatchOperationStatusRequestDTO $requestDTO Request DTO * @return FileBatchOperationStatusResponseDTO Response DTO */ public function checkBatchOperationStatus( RequestContext $requestContext, CheckBatchOperationStatusRequestDTO $requestDTO ): FileBatchOperationStatusResponseDTO { try { $batchKey = $requestDTO->getBatchKey(); $userAuthorization = $requestContext->getUserAuthorization(); $dataIsolation = $this->createDataIsolation($userAuthorization); // Verify user permission for this batch operation if (! $this->batchOperationStatusManager->verifyUserPermission($batchKey, $dataIsolation->getCurrentUserId())) { $this->logger->warning('User permission denied for batch operation status check', [ 'batch_key' => $batchKey, 'user_id' => $dataIsolation->getCurrentUserId(), ]); return FileBatchOperationStatusResponseDTO::createNotFound(); } // Get task status from Redis $taskStatus = $this->batchOperationStatusManager->getTaskStatus($batchKey); if (! $taskStatus) { $this->logger->info('Batch operation not found', [ 'batch_key' => $batchKey, 'user_id' => $dataIsolation->getCurrentUserId(), ]); return FileBatchOperationStatusResponseDTO::createNotFound(); } // Log the status check $this->logger->debug('Batch operation status retrieved', [ 'batch_key' => $batchKey, 'status' => $taskStatus['status'] ?? 'unknown', 'operation' => $taskStatus['operation'] ?? 'unknown', 'user_id' => $dataIsolation->getCurrentUserId(), ]); // Create response DTO from task status return FileBatchOperationStatusResponseDTO::fromTaskStatus($taskStatus); } catch (BusinessException $e) { $this->logger->warning('Business logic error in checking batch operation status', [ 'batch_key' => $requestDTO->getBatchKey(), 'error' => $e->getMessage(), 'code' => $e->getCode(), ]); throw $e; } catch (Throwable $e) { $this->logger->error('System error in checking batch operation status', [ 'batch_key' => $requestDTO->getBatchKey(), 'error' => $e->getMessage(), 'trace' => $e->getTraceAsString(), ]); ExceptionBuilder::throw(SuperAgentErrorCode::FILE_NOT_FOUND, trans('file.check_batch_status_failed')); } } /** * Replace file with new file. * * @param RequestContext $requestContext Request context * @param int $fileId Target file ID to replace * @param ReplaceFileRequestDTO $requestDTO Request DTO * @return array Replaced file information */ public function replaceFile( RequestContext $requestContext, int $fileId, ReplaceFileRequestDTO $requestDTO ): array { $userAuthorization = $requestContext->getUserAuthorization(); $dataIsolation = $this->createDataIsolation($userAuthorization); try { // 1. PermissionValidateAndFile store inpropertyCheck $fileEntity = $this->taskFileDomainService->getById($fileId); if (empty($fileEntity)) { ExceptionBuilder::throw( SuperAgentErrorCode::FILE_NOT_FOUND, trans('file.file_not_found') ); } // CheckwhetherForDirectory (Boundary1:  not AllowReplaceDirectory) if ($fileEntity->getIsDirectory()) { ExceptionBuilder::throw( SuperAgentErrorCode::FILE_OPERATION_NOT_ALLOWED, trans('file.cannot_replace_directory') ); } // CheckProjectPermission $projectEntity = $this->getAccessibleProject( $fileEntity->getProjectId(), $userAuthorization->getId(), $userAuthorization->getOrganizationCode() ); // 2. CheckFileEditStatus (Boundary2: Filecorrectin be Edit) // TODO: ImplementationEditStatusCheckLogic // $editingUsers = $this->getFileEditingUsers($fileId); // if (!empty($editingUsers) && !$requestDTO->getForceReplace()) { // ExceptionBuilder::throw(...); // } // 3. Validate new FileincloudstoredExist inin (Boundary3: sourceFileDoes not existin) $newFileKey = $requestDTO->getFileKey(); $organizationCode = $projectEntity->getUserOrganizationCode(); $newFileInfo = $this->taskFileDomainService->getFileInfoFromCloudStorage( $newFileKey, $organizationCode ); if (empty($newFileInfo)) { ExceptionBuilder::throw( SuperAgentErrorCode::FILE_NOT_FOUND, trans('file.source_file_not_found_in_storage') ); } // 4. Build new FilenameAndTargetfile_key // Scenario1: Provided newFilename -> UseuserspecifiedFilename // Scenario2:  un ProvideFilename -> from new File file_key Extract fromFilename if (! empty($requestDTO->getFileName())) { $newFileName = $requestDTO->getFileName(); } else { // from new File pathExtract fromFilename $newFileName = basename($newFileKey); } // BuildTargetFile path: originalFileDirectory +  new Filename $targetFileKey = dirname($fileEntity->getFileKey()) . '/' . $newFileName; $newFileExtension = pathinfo($newFileName, PATHINFO_EXTENSION); $oldFileExtension = $fileEntity->getFileExtension(); // detectcrossTypeReplace (Boundary4: File typeChange) $isCrossTypeReplace = ($oldFileExtension !== $newFileExtension); // 5. FilenameConflictCheck (Boundary5: TargetPosition already  have OtherFile) if ($targetFileKey !== $fileEntity->getFileKey()) { $existingFile = $this->taskFileDomainService->getByFileKey($targetFileKey); if (! empty($existingFile)) { ExceptionBuilder::throw( SuperAgentErrorCode::FILE_EXIST, trans('file.target_file_already_exists') ); } } // 6. workDirectorysafeCheck (Boundary6: preventPathtravel) $fullPrefix = $this->taskFileDomainService->getFullPrefix($organizationCode); $fullWorkdir = WorkDirectoryUtil::getFullWorkdir($fullPrefix, $projectEntity->getWorkDir()); if (! WorkDirectoryUtil::checkEffectiveFileKey($fullWorkdir, $targetFileKey)) { ExceptionBuilder::throw( SuperAgentErrorCode::FILE_ILLEGAL_KEY, trans('file.illegal_file_key') ); } if (! WorkDirectoryUtil::checkEffectiveFileKey($fullWorkdir, $newFileKey)) { ExceptionBuilder::throw( SuperAgentErrorCode::FILE_ILLEGAL_KEY, trans('file.source_file_key_illegal') ); } Db::beginTransaction(); try { $prefix = WorkDirectoryUtil::getPrefix($projectEntity->getWorkDir()); $oldFileKey = $fileEntity->getFileKey(); // 7. CreateVersionsnapshot (inReplaceBefore) $versionEntity = $this->taskFileVersionDomainService->createFileVersion( $projectEntity->getUserOrganizationCode(), $fileEntity, $isCrossTypeReplace ? 2 : 1 // crossTypeReplaceUsespecialMark ); if (empty($versionEntity)) { $this->logger->warning('Failed to create version snapshot before replace', [ 'file_id' => $fileId, ]); } if ($oldFileKey !== $targetFileKey) { $this->cloudFileRepository->deleteObjectByCredential( $prefix, $organizationCode, $oldFileKey, StorageBucketType::SandBox ); $this->logger->info('Old file deleted after version backup', [ 'file_id' => $fileId, 'old_file_key' => $oldFileKey, 'version_id' => $versionEntity?->getId(), ]); // 8.2 Move new File to TargetPosition (If needed) $this->cloudFileRepository->renameObjectByCredential( $prefix, $organizationCode, $newFileKey, $targetFileKey, StorageBucketType::SandBox ); $this->logger->info('New file moved to target location', [ 'file_id' => $fileId, 'source_key' => $newFileKey, 'target_key' => $targetFileKey, ]); } // 9. UpdateData database Record $fileEntity->setFileKey($targetFileKey); $fileEntity->setFileName($newFileName); $fileEntity->setFileExtension($newFileExtension); $fileEntity->setFileSize($newFileInfo['size']); $fileEntity->setUpdatedAt(date('Y-m-d H:i:s')); $newFileEntity = $this->taskFileDomainService->updateById($fileEntity); Db::commit(); // 10. PublishEvent $fileReplacedEvent = new FileReplacedEvent( $newFileEntity, $versionEntity, $userAuthorization, $isCrossTypeReplace ); $this->eventDispatcher->dispatch($fileReplacedEvent); // 11. ReturnResult return TaskFileItemDTO::fromEntity($newFileEntity, $projectEntity->getWorkDir())->toArray(); } catch (Throwable $e) { Db::rollBack(); $this->logger->error('Failed to replace file, transaction rolled back', [ 'file_id' => $fileId, 'source_key' => $newFileKey, 'target_key' => $targetFileKey, 'error' => $e->getMessage(), ]); throw $e; } } catch (BusinessException $e) { $this->logger->warning(sprintf( 'Business logic error in replace file: %s, File ID: %s, Error Code: %d', $e->getMessage(), $fileId, $e->getCode() )); throw $e; } catch (Throwable $e) { $this->logger->error(sprintf( 'System error in replace file: %s, File ID: %s', $e->getMessage(), $fileId )); ExceptionBuilder::throw( SuperAgentErrorCode::FILE_REPLACE_FAILED, trans('file.file_replace_failed') ); } } /** * Expand directory file IDs to include all nested files. * * This method processes a list of file IDs and expands any directories * to include all their nested files. This ensures that when moving or * operating on directories, all contained files are included. * * @param DataIsolation $dataIsolation Data isolation context * @param array $fileIds Original file IDs (may contain directories) * @param int $projectId Project ID * @return array Expanded file IDs (includes all nested files from directories) */ private function expandDirectoryFileIds(DataIsolation $dataIsolation, array $fileIds, int $projectId): array { $allFileIds = []; // Get all file entities $fileEntities = $this->taskFileDomainService->getProjectFilesByIds($projectId, $fileIds); foreach ($fileEntities as $fileEntity) { // Always include the file/directory itself $allFileIds[] = $fileEntity->getFileId(); // If it's a directory, expand to get all nested files if ($fileEntity->getIsDirectory()) { $nestedFileIds = $this->taskFileDomainService->getDirectoryFileIds( $dataIsolation, $fileEntity ); // Merge nested file IDs if (! empty($nestedFileIds)) { $allFileIds = array_merge($allFileIds, $nestedFileIds); } } } // Remove duplicates and reindex return array_values(array_unique($allFileIds)); } } 