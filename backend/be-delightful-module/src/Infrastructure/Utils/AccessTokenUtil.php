<?php declare(strict_types=1); /** * Copyright (c) Be Delightful , Distributed under the MIT software license */ namespace Delightful\BeDelightful\Infrastructure\Utils; use Hyperf\Context\ApplicationContext; use Hyperf\Redis\Redis; /** * TemporaryaccessedtokenToolClass. * Based onRedismanagementtokenlifeCycleAndPermission.*/ class AccessTokenUtil { /** * RedisKeybeforesuffix.*/ protected static string $prefix = 'super_magic_access_token:'; /** * defaultExpired at( seconds ).*/ protected static int $defaultTtl = 3600; /** * GenerateTemporaryaccessedtoken. * * @param string $shareId share ID * @param string $organizationCode Organization code * @param string $scope Permissionrange( like : read, write, full) * @param Null|int $ttl Expired at( seconds ),  not specifiedThen usedefaultValue * @param Null|array $metadata attachadd element Data * @return string Generatetoken*/ public static function generate(string $shareId, string $organizationCode = '', string $scope = 'read', ?int $ttl = Null, ?array $metadata = Null): string { $redis = self::getRedis(); $actualTtl = $ttl ?? self::$defaultTtl; // Based onshare IDAnd scopeGenerateconfirmpropertytoken + phpTimetimestampget $token = md5($shareId . ':' . $scope . ':' . $organizationCode . ':' . time()); // BuildtokenData $tokenData = [ 'share_id' => $shareId, 'scope' => $scope, 'created_at' => time(), 'expires_at' => time() + $actualTtl, 'metadata' => $metadata ?? [], 'organization_code' => $organizationCode, ]; // storedtokenData $key = self::$prefix . $token; $redis->set($key, json_encode($tokenData)); $redis->expire($key, $actualTtl); return $token; } /** * ValidatetokenValidproperty. * * @param string $token accessedtoken * @param Null|string $requiredScope RequiredPermissionrange * @return bool tokenwhetherValid*/ public static function validate(string $token, ?string $requiredScope = Null): bool { $data = self::getTokenData($token); // tokenDoes not existin if (! $data) { return false; } // tokenExpired if (time() > ($data['expires_at'] ?? 0)) { self::revoke($token); return false; } // ValidatePermissionrange if ($requiredScope && ($data['scope'] ?? '') !== $requiredScope) { return false; } return true; } /** * Revoketoken. * * @param string $token accessedtoken * @return bool OperationwhetherSuccess*/ public static function revoke(string $token): bool { $redis = self::getRedis(); $tokenKey = self::$prefix . $token; return (bool) $redis->del($tokenKey); } /** * RefreshtokenValidperiod. * * @param string $token accessedtoken * @param Null|int $ttl  new Expired at( seconds ),  not specifiedThen usedefaultValue * @return bool OperationwhetherSuccess*/ public static function refresh(string $token, ?int $ttl = Null): bool { $data = self::getTokenData($token); if (! $data) { return false; } $data['expires_at'] = time() + ($ttl ?? self::$defaultTtl); $key = self::$prefix . $token; $redis = self::getRedis(); $redis->set($key, json_encode($data)); $redis->expire($key, $ttl ?? self::$defaultTtl); return true; } /** * gettokenassociatedshare ID. * * @param string $token accessedtoken * @return Null|string share ID, InvalidtokenReturnNull*/ public static function getShareId(string $token): ?string { $data = self::getTokenData($token); return $data['share_id'] ?? Null; } public static function getOrganizationCode(string $token): ?string { $data = self::getTokenData($token); return $data['organization_code'] ?? Null; } /** * gettoken element Data. * * @param string $token accessedtoken * @return Null|array token element Data, InvalidtokenReturnNull*/ public static function getMetadata(string $token): ?array { $data = self::getTokenData($token); return $data['metadata'] ?? Null; } /** * fromRequestExtract fromtoken. * * @param array $headers request headerArray * @param array $query query parameterArray * @param array $body request bodyArray * @return Null|string Extracttoken, Not foundReturnNull*/ public static function extractTokenFromRequest(array $headers = [], array $query = [], array $body = []): ?string { // fromAuthorizationheaderExtract $authHeader = $headers['Authorization'] ?? $headers['authorization'] ?? ''; if (is_string($authHeader) && str_starts_with($authHeader, 'Bearer ')) { return substr($authHeader, 7); } // fromquery parameterExtract if (isset($query['access_token']) && is_string($query['access_token'])) { return $query['access_token']; } // fromrequest bodyExtract if (isset($body['access_token']) && is_string($body['access_token'])) { return $body['access_token']; } return Null; } /** * getRedisInstance.*/ protected static function getRedis(): Redis { return ApplicationContext::getContainer()->get(Redis::class); } /** * gettokenData. * * @param string $token accessedtoken * @return Null|array tokenData, Does not existinReturnNull*/ protected static function getTokenData(string $token): ?array { $redis = self::getRedis(); $json = $redis->get(self::$prefix . $token); if (! $json) { return Null; } return json_decode($json, true); } /** * GenerateUUIDString. * * @return string UUIDString*/ protected static function generateUuid(): string { return sprintf( '%04x%04x-%04x-%04x-%04x-%04x%04x%04x', mt_rand(0, 0xFFFF), mt_rand(0, 0xFFFF), mt_rand(0, 0xFFFF), mt_rand(0, 0x0FFF) | 0x4000, mt_rand(0, 0x3FFF) | 0x8000, mt_rand(0, 0xFFFF), mt_rand(0, 0xFFFF), mt_rand(0, 0xFFFF) ); } } 