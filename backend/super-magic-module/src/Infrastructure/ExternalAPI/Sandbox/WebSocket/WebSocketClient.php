<?php declare(strict_types=1); /** * Copyright (c) Be Delightful , Distributed under the MIT software license */ namespace Dtyq\SuperMagic\Infrastructure\ExternalAPI\Sandbox\WebSocket; use Dtyq\SuperMagic\Infrastructure\ExternalAPI\Sandbox\Config\WebSocketConfig; use Dtyq\SuperMagic\Infrastructure\ExternalAPI\Sandbox\WebSocket\Exception\WebSocketConnectionException; use Hyperf\Codec\Json; use Psr\Log\LoggerInterface; use Swow\Psr7\Client\Client; use Swow\Psr7\Psr7; use Throwable; class WebSocketClient { // WebSocketFrameTypeconstant amount  private const OPCODE_PING = 9; private const OPCODE_PONG = 10; private const OPCODE_TEXT = 1; private const OPCODE_BINARY = 2; private ?Client $client = Null; private int $lastPongTime; private bool $isConnected = false; private int $readTimeout; public function __construct( private readonly WebSocketConfig $config, private readonly LoggerInterface $logger, private readonly string $wsUrl, private readonly string $id, private readonly ?string $token = Null ) { $this->lastPongTime = time(); $this->readTimeout = $this->config->getReadTimeout(); } /** * establishWebSocketConnect. * * @throws WebSocketConnectionException ConnectFailedThrow when*/ public function connect(): void { $urlParts = parse_url($this->wsUrl); if ($urlParts === false) { throw new WebSocketConnectionException('InvalidWebSocket URL'); } $host = $urlParts['host'] ?? ''; $port = $urlParts['port'] ?? ($urlParts['scheme'] === 'wss' ? 443 : 80); $path = $urlParts['path'] ?? '/'; $query = isset($urlParts['query']) ? '?' . $urlParts['query'] : ''; if (empty($host)) { throw new WebSocketConnectionException('WebSocket URLmissingmainmachineAddress'); } try { $this->client = new Client(); $request = Psr7::createRequest('GET', $path . $query); // addtoken to HTTPrequest header if ($this->token) { $request = $request->withHeader('token', $this->token); } $this->client->connect($host, $port); $this->client->upgradeToWebSocket($request); $this->isConnected = true; $this->lastPongTime = time(); $this->logger->info(sprintf('AlreadyConnect to WebSocket: %s', $this->wsUrl), [ 'id' => $this->id, ]); } catch (Throwable $e) { $this->isConnected = false; throw new WebSocketConnectionException( sprintf('WebSocketConnection failed: %s', $e->getMessage()), 0, $e ); } } /** * DisconnectWebSocketConnect.*/ public function disconnect(): void { /* @phpstan-ignore-next-line */ if ($this->client !== Null && method_exists($this->client, 'close')) { try { $this->client->close(); $this->isConnected = false; $this->logger->info(sprintf('WebSocketConnectAlreadyDisconnect: %s', $this->wsUrl)); } catch (Throwable $e) { $this->logger->warning(sprintf('CloseWebSocketConnection failed: %s', $e->getMessage())); } } } /** * CheckWebSocketConnectwhether already establish. * * @return bool ConnectStatus*/ public function isConnected(): bool { return $this->isConnected; } /** * SendWebSocketMessage. * * @param array $data wantSendMessageData * @throws WebSocketConnectionException SendFailedThrow when*/ public function send(array $data): void { if (! $this->isConnected()) { throw new WebSocketConnectionException('WebSocket un Connect'); } try { $jsonData = Json::encode($data); $message = Psr7::createWebSocketTextMaskedFrame($jsonData); $this->client?->sendWebSocketFrame($message); } catch (Throwable $e) { throw new WebSocketConnectionException( sprintf('SendMessageFailed: %s', $e->getMessage()), 0, $e ); } } /** * ReceiveWebSocketMessage. * * @return Null|array ReceivedMessageData or Null (Timeout/noMessage) * @throws WebSocketConnectionException ReceiveFailedThrow when*/ public function receive(): ?array { if (! $this->isConnected()) { throw new WebSocketConnectionException('WebSocket un Connect'); } try { $frame = $this->client?->recvWebSocketFrame(); if ($frame === Null) { return Null; } // Process/HandlePongFrame if ($frame->getOpcode() === self::OPCODE_PONG) { $this->lastPongTime = time(); $this->logger->debug(sprintf( 'ReceivedPongFrameResponse，ID: %s，Time: %s', $this->id, date('Y-m-d H:i:s') )); return Null; // PongFrameNo needPass give  up layerApplication } // Process/HandlePingFrame - AutoResponsePong if ($frame->getOpcode() === self::OPCODE_PING) { try { $pongFrame = Psr7::createWebSocketFrame( opcode: self::OPCODE_PONG, payloadData: $frame->getPayloadData()->getContents(), fin: true, mask: true ); $this->client?->sendWebSocketFrame($pongFrame); $this->logger->debug(sprintf( 'ReceivedPingFrameAndAutoResponsePong，ID: %s', $this->id )); } catch (Throwable $e) { $this->logger->warning('ResponsePongFailed: ' . $e->getMessage()); } return Null; // PingFrameNo needPass give  up layerApplication } // Process/HandleTextMessage if ($frame->getOpcode() === self::OPCODE_TEXT) { $messageText = (string) $frame->getPayloadData(); return Json::decode($messageText); } // Process/HandleBinaryMessage if ($frame->getOpcode() === self::OPCODE_BINARY) { $this->logger->debug(sprintf( 'Received binary frame，Length: %d，ID: %s', $frame->getPayloadLength(), $this->id )); // tryConvertBinaryDataparseForJSON try { $messageText = (string) $frame->getPayloadData(); return Json::decode($messageText); } catch (Throwable $e) { $this->logger->warning('Unable toparseBinaryFrameForJSON: ' . $e->getMessage()); return [ 'type' => 'binary', 'data' => base64_encode((string) $frame->getPayloadData()), ]; } } $this->logger->debug(sprintf( 'ReceivedUnknownTypeFrame，Operationcode: %d，ID: %s', $frame->getOpcode(), $this->id )); return Null; } catch (Throwable $e) { throw new WebSocketConnectionException( sprintf('ReceiveMessageFailed: %s', $e->getMessage()), 0, $e ); } } /** * SendWebSocketProtocol levelPingFrame. * * @return bool SendwhetherSuccess*/ public function sendPing(): bool { if (! $this->isConnected()) { return false; } try { // CreatePingFrame $pingFrame = Psr7::createWebSocketFrame( opcode: self::OPCODE_PING, payloadData: $this->config->getHeartbeatMessage(), fin: true, mask: true ); $this->client?->sendWebSocketFrame($pingFrame); $this->logger->debug(sprintf( 'SendWebSocket PingFrame，ID: %s', $this->id )); return true; } catch (Throwable $e) { $this->logger->warning(sprintf( 'SendPingFrameFailed: %s，ID: %s', $e->getMessage(), $this->id )); return false; } } /** * CheckPongResponsewhetherTimeout. * * @return bool IfTimeoutReturntrue, Otherwise returns false*/ public function isPongTimedOut(): bool { $pongTimeout = $this->config->getPongTimeout(); return (time() - $this->lastPongTime) > $pongTimeout; } /** * get most  after OnceReceivedPongFrameTimetimestamp.*/ public function getLastPongTime(): int { return $this->lastPongTime; } /** * setreadgetTimeoutTime. * * @param int $timeout TimeoutTime ( seconds )*/ public function setReadTimeout(int $timeout): void { $this->readTimeout = $timeout; $this->client?->setReadTimeout($timeout * 1000); } /** * getCurrentsetreadgetTimeoutTime.*/ public function getReadTimeout(): int { return $this->readTimeout; } } 