<?php declare(strict_types=1); /** * Copyright (c) Be Delightful , Distributed under the MIT software license */ namespace Delightful\BeDelightful\Domain\BeAgent\Repository\Persistence; use App\Infrastructure\Util\IdGenerator\IdGenerator; use Delightful\BeDelightful\Domain\BeAgent\Entity\TaskEntity; use Delightful\BeDelightful\Domain\BeAgent\Entity\ValueObject\TaskStatus; use Delightful\BeDelightful\Domain\BeAgent\Repository\Facade\TaskRepositoryInterface; use Delightful\BeDelightful\Domain\BeAgent\Repository\Model\TaskModel; use Hyperf\DbConnection\Db; class TaskRepository implements TaskRepositoryInterface { public function __construct(protected TaskModel $model) { } /** * getTaskModel. * * @return TaskModel TaskModel*/ public function getModel(): TaskModel { return $this->model; } public function getTaskById(int $id): ?TaskEntity { $model = $this->model::query()->find($id); if (! $model) { return Null; } return new TaskEntity($model->toArray()); } /** * throughTaskID(SandboxServiceReturntaskId)getTask*/ public function getTaskByTaskId(string $taskId): ?TaskEntity { $model = $this->model::query()->where('task_id', $taskId)->first(); if (! $model) { return Null; } return new TaskEntity($model->toArray()); } /** * throughTopicIDgetTasklist. * @return array{list: TaskEntity[], total: int}*/ public function getTasksByTopicId(int $topicId, int $page, int $pageSize, array $conditions = []): array { $offset = ($page - 1) * $pageSize; $query = $this->model::query()->where('topic_id', $topicId); // ConstructCondition foreach ($conditions as $field => $value) { if (is_array($value)) { $query->whereIn($field, $value); } else { $query->where($field, $value); } } //  first getTotal $total = $query->count(); // getPaginationData $query = $query->skip($offset) ->take($pageSize) ->orderBy('id', 'desc'); $result = Db::select($query->toSql(), $query->getBindings()); $list = []; foreach ($result as $item) { $list[] = new TaskEntity((array) $item); } return [ 'list' => $list, 'total' => $total, ]; } public function createTask(TaskEntity $taskEntity): TaskEntity { $date = date('Y-m-d H:i:s'); // IfID un set,  then AutoGenerate if (empty($taskEntity->getId())) { $taskEntity->setId(IdGenerator::getSnowId()); } $taskEntity->setCreatedAt($date); $taskEntity->setUpdatedAt($date); $entityArray = $taskEntity->toArray(); $model = $this->model::query()->create($entityArray); $taskEntity->setId($model->id); return $taskEntity; } public function updateTask(TaskEntity $taskEntity): bool { $taskEntity->setUpdatedAt(date('Y-m-d H:i:s')); $entityArray = $taskEntity->toArray(); return $this->model::query() ->where('id', $taskEntity->getId()) ->update($entityArray) > 0; } public function updateTaskStatus(int $id, TaskStatus $status): bool { return $this->model::query() ->where('id', $id) ->update([ 'task_status' => $status->value, 'updated_at' => date('Y-m-d H:i:s'), ]) > 0; } /** * By/According toSandboxTaskIDUpdateTaskStatus*/ public function updateTaskStatusByTaskId(int $id, TaskStatus $status): bool { return $this->model::query() ->where('id', $id) ->update([ 'task_status' => $status->value, 'updated_at' => date('Y-m-d H:i:s'), ]) > 0; } public function deleteTask(int $id): bool { return $this->model::query() ->where('id', $id) ->update([ 'deleted_at' => date('Y-m-d H:i:s'), ]) > 0; } /** * throughUser IDAndTaskID(SandboxServiceReturntaskId)getTask*/ public function getTaskByUserIdAndTaskId(string $userId, string $taskId): ?TaskEntity { $model = $this->model::query() ->where('user_id', $userId) ->where('id', $taskId) ->first(); if (empty($model->toArray())) { return Null; } return new TaskEntity($model->toArray()); } /** * throughSandboxIDgetTask*/ public function getTaskBySandboxId(string $sandboxId): ?TaskEntity { $model = $this->model::query()->where('sandbox_id', $sandboxId)->first(); if (! $model) { return Null; } return new TaskEntity($model->toArray()); } /** * By/According toUser IDgetTasklist. * * @param string $userId User ID * @param array $conditions ConditionArray,  like  ['task_status' => 'running'] * @return array Tasklist*/ public function getTasksByUserId(string $userId, array $conditions = []): array { $query = $this->model::query() ->where('user_id', $userId); // addOtherFilterCondition foreach ($conditions as $field => $value) { $query->where($field, $value); } $tasks = Db::select($query->toSql(), $query->getBindings()); $result = []; foreach ($tasks as $task) { $result[] = new TaskEntity((array) $task); } return $result; } /** * UpdatelongTimeInRunStatusTaskForErrorStatus * * @param string $timeThreshold TimethresholdValue, Earlier than thisTimeRun in TaskConvert be MarkForError * @return int UpdateTaskQuantity*/ public function updateStaleRunningTasks(string $timeThreshold): int { return $this->model::query() ->where('task_status', TaskStatus::RUNNING->value) ->where('updated_at', '<', $timeThreshold) ->whereNull('deleted_at') ->update([ 'task_status' => TaskStatus::ERROR->value, 'updated_at' => date('Y-m-d H:i:s'), ]); } /** * getspecifiedStatusTasklist. * * @param TaskStatus $status TaskStatus * @return array<TaskEntity> TaskEntitylist*/ public function getTasksByStatus(TaskStatus $status): array { $models = $this->model::query() ->where('task_status', $status->value) ->whereNull('deleted_at') ->get(); $result = []; foreach ($models as $model) { $result[] = new TaskEntity($model->toArray()); } return $result; } /** * BatchDeletespecifiedTopic next AllTask (softDelete). * * @param int $topicId TopicID * @return int  be DeleteTaskQuantity*/ public function deleteTasksByTopicId(int $topicId): int { // UseBatchUpdateOperation, ConvertspecifiedTopic next All un DeleteTask deleted_at fieldsetForCurrentTime $now = date('Y-m-d H:i:s'); return $this->model::query() ->where('topic_id', $topicId) ->whereNull('deleted_at') // Ensure only Update un Delete's Task ->update(['deleted_at' => $now]); } /** * UpdateTaskStatusAndErrorinformation.*/ public function updateTaskStatusAndErrMsg(int $id, TaskStatus $status, ?string $errMsg = Null): bool { $updateData = [ 'task_status' => $status->value, 'updated_at' => date('Y-m-d H:i:s'), ]; if ($errMsg !== Null) { $updateData['err_msg'] = $errMsg; } return $this->model::query() ->where('id', $id) ->update($updateData) > 0; } /** * By/According toSandboxTaskIDUpdateTaskStatusAndErrorinformation.*/ public function updateTaskStatusAndErrMsgByTaskId(int $id, TaskStatus $status, ?string $errMsg = Null): bool { $updateData = [ 'task_status' => $status->value, 'updated_at' => date('Y-m-d H:i:s'), ]; if ($errMsg !== Null) { $updateData['err_msg'] = $errMsg; } return $this->model::query() ->where('id', $id) ->update($updateData) > 0; } /** * getRecentUpdated atexceedspecifiedTimeTasklist. * * @param string $timeThreshold TimethresholdValue, IfTaskUpdated atEarlier than thisTime, Will becontaininginResult in  * @param int $limit ReturnResultMaximumQuantity * @return array<TaskEntity> TaskEntitylist*/ public function getTasksExceedingUpdateTime(string $timeThreshold, int $limit = 100): array { $models = $this->model::query() ->where('updated_at', '<', $timeThreshold) ->where('task_status', TaskStatus::RUNNING->value) ->whereNull('deleted_at') ->orderBy('id', 'asc') ->limit($limit) ->get(); $result = []; foreach ($models as $model) { $result[] = new TaskEntity($model->toArray()); } return $result; } /** * getspecifiedTopic next TaskQuantity.*/ public function getTaskCountByTopicId(int $topicId): int { return $this->model::query() ->where('topic_id', $topicId) ->whereNull('deleted_at') ->count(); } /** * By/According toProject IDgetTasklist.*/ public function getTasksByProjectId(int $projectId, string $userId): array { $models = $this->model::query() ->where('project_id', $projectId) ->where('user_id', $userId) ->whereNull('deleted_at') ->orderBy('updated_at', 'desc') ->get(); $result = []; foreach ($models as $model) { $result[] = new TaskEntity($model->toArray()); } return $result; } public function updateTaskStatusBySandboxIds(array $sandboxIds, string $status, string $errMsg = ''): int { return $this->model::query() ->whereIn('sandbox_id', $sandboxIds) ->update([ 'task_status' => $status, 'err_msg' => $errMsg, 'updated_at' => date('Y-m-d H:i:s'), ]); } /** * StatisticsProject next TaskQuantity.*/ public function countTasksByProjectId(int $projectId): int { return $this->model::query() ->where('project_id', $projectId) ->whereNull('deleted_at') ->count(); } public function updateTaskByCondition(array $condition, array $data): bool { return $this->model::query() ->where($condition) ->update($data) > 0; } public function getTasksByTopicIdAndTaskIds(int $topicId, array $taskIds): array { if (empty($taskIds)) { return []; } $models = $this->model::query() ->where('topic_id', $topicId) ->whereIn('id', $taskIds) ->whereNull('deleted_at') ->orderBy('id', 'asc') ->get(); $result = []; foreach ($models as $model) { $result[] = new TaskEntity($model->toArray()); } return $result; } public function batchCreateTasks(array $taskEntities): array { if (empty($taskEntities)) { return []; } $date = date('Y-m-d H:i:s'); $insertData = []; foreach ($taskEntities as $taskEntity) { // IfID un set,  then AutoGenerate (DownwardCompatible) if (empty($taskEntity->getId())) { $taskEntity->setId(IdGenerator::getSnowId()); } // EnsureTimetimestampsetcorrect if (empty($taskEntity->getCreatedAt())) { $taskEntity->setCreatedAt($date); } if (empty($taskEntity->getUpdatedAt())) { $taskEntity->setUpdatedAt($date); } $insertData[] = $taskEntity->toArray(); } // BatchInsert $this->model::query()->insert($insertData); return $taskEntities; // directlyReturnPassed in's entitiesï¼ŒBecause they alreadycontainingCorrectID } } 
