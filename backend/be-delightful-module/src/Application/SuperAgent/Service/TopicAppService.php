<?php declare(strict_types=1); /** * Copyright (c) Be Delightful , Distributed under the MIT software license */ namespace Delightful\SuperDelightful\Application\SuperAgent\Service; use App\Application\Chat\Service\DelightfulChatMessageAppService; use App\Application\File\Service\FileAppService; use App\Domain\Contact\Entity\ValueObject\DataIsolation; use App\ErrorCode\GenericErrorCode; use App\Infrastructure\Core\Exception\BusinessException; use App\Infrastructure\Core\Exception\ExceptionBuilder; use App\Infrastructure\Core\ValueObject\StorageBucketType; use App\Infrastructure\Util\Context\CoContext; use App\Infrastructure\Util\Context\RequestContext; use App\Infrastructure\Util\IdGenerator\IdGenerator; use App\Interfaces\Authorization\Web\DelightfulUserAuthorization; use Delightful\SuperDelightful\Application\Chat\Service\ChatAppService; use Delightful\SuperDelightful\Application\SuperAgent\Event\Publish\StopRunningTaskPublisher; use Delightful\SuperDelightful\Domain\Share\Constant\ResourceType; use Delightful\SuperDelightful\Domain\Share\Service\ResourceShareDomainService; use Delightful\SuperDelightful\Domain\SuperAgent\Constant\TopicDuplicateConstant; use Delightful\SuperDelightful\Domain\SuperAgent\Entity\TopicEntity; use Delightful\SuperDelightful\Domain\SuperAgent\Entity\ValueObject\DeleteDataType; use Delightful\SuperDelightful\Domain\SuperAgent\Event\StopRunningTaskEvent; use Delightful\SuperDelightful\Domain\SuperAgent\Event\TopicCreatedEvent; use Delightful\SuperDelightful\Domain\SuperAgent\Event\TopicDeletedEvent; use Delightful\SuperDelightful\Domain\SuperAgent\Event\TopicRenamedEvent; use Delightful\SuperDelightful\Domain\SuperAgent\Event\TopicUpdatedEvent; use Delightful\SuperDelightful\Domain\SuperAgent\Service\ProjectDomainService; use Delightful\SuperDelightful\Domain\SuperAgent\Service\TaskDomainService; use Delightful\SuperDelightful\Domain\SuperAgent\Service\TopicDomainService; use Delightful\SuperDelightful\Domain\SuperAgent\Service\WorkspaceDomainService; use Delightful\SuperDelightful\ErrorCode\ShareErrorCode; use Delightful\SuperDelightful\ErrorCode\SuperAgentErrorCode; use Delightful\SuperDelightful\Infrastructure\Utils\AccessTokenUtil; use Delightful\SuperDelightful\Infrastructure\Utils\FileTreeUtil; use Delightful\SuperDelightful\Interfaces\SuperAgent\DTO\Request\DeleteTopicRequestDTO; use Delightful\SuperDelightful\Interfaces\SuperAgent\DTO\Request\DuplicateTopicRequestDTO; use Delightful\SuperDelightful\Interfaces\SuperAgent\DTO\Request\GetTopicAttachmentsRequestDTO; use Delightful\SuperDelightful\Interfaces\SuperAgent\DTO\Request\SaveTopicRequestDTO; use Delightful\SuperDelightful\Interfaces\SuperAgent\DTO\Response\DeleteTopicResultDTO; use Delightful\SuperDelightful\Interfaces\SuperAgent\DTO\Response\MessageItemDTO; use Delightful\SuperDelightful\Interfaces\SuperAgent\DTO\Response\SaveTopicResultDTO; use Delightful\SuperDelightful\Interfaces\SuperAgent\DTO\Response\TaskFileItemDTO; use Delightful\SuperDelightful\Interfaces\SuperAgent\DTO\Response\TopicItemDTO; use Exception; use Hyperf\Amqp\Producer; use Hyperf\DbConnection\Db; use Hyperf\Logger\LoggerFactory; use Psr\EventDispatcher\EventDispatcherInterface; use Psr\Log\LoggerInterface; use Throwable; use function Hyperf\Coroutine\go; class TopicAppService extends AbstractAppService { protected LoggerInterface $logger; public function __construct( protected TaskDomainService $taskDomainService, protected WorkspaceDomainService $workspaceDomainService, protected ProjectDomainService $projectDomainService, protected TopicDomainService $topicDomainService, protected ResourceShareDomainService $resourceShareDomainService, protected DelightfulChatMessageAppService $magicChatMessageAppService, protected FileAppService $fileAppService, protected ChatAppService $chatAppService, protected Producer $producer, protected EventDispatcherInterface $eventDispatcher, protected TopicDuplicateStatusManager $topicDuplicateStatusManager, LoggerFactory $loggerFactory ) { $this->logger = $loggerFactory->get(get_class($this)); } public function getTopic(RequestContext $requestContext, int $id): TopicItemDTO { // getuserauthorizationinformation $userAuthorization = $requestContext->getUserAuthorization(); // CreateDataIsolationObject $dataIsolation = $this->createDataIsolation($userAuthorization); // getTopicContent $topicEntity = $this->topicDomainService->getTopicById($id); if (! $topicEntity) { ExceptionBuilder::throw(SuperAgentErrorCode::TOPIC_NOT_FOUND, 'topic.topic_not_found'); } // JudgeTopicwhether is this user  if ($topicEntity->getUserId() !== $userAuthorization->getId()) { ExceptionBuilder::throw(SuperAgentErrorCode::TOPIC_ACCESS_DENIED, 'topic.access_denied'); } return TopicItemDTO::fromEntity($topicEntity); } public function getTopicById(int $id): TopicItemDTO { // getTopicContent $topicEntity = $this->topicDomainService->getTopicById($id); if (! $topicEntity) { ExceptionBuilder::throw(SuperAgentErrorCode::TOPIC_NOT_FOUND, 'topic.topic_not_found'); } return TopicItemDTO::fromEntity($topicEntity); } public function createTopic(RequestContext $requestContext, SaveTopicRequestDTO $requestDTO): TopicItemDTO { // getuserauthorizationinformation $userAuthorization = $requestContext->getUserAuthorization(); // CreateDataIsolationObject $dataIsolation = $this->createDataIsolation($userAuthorization); $projectEntity = $this->getAccessibleProjectWithEditor((int) $requestDTO->getProjectId(), $userAuthorization->getId(), $userAuthorization->getOrganizationCode()); // Create new Topic, UseTransactionEnsureoriginalsubproperty Db::beginTransaction(); try { // 1. Initialize chat SessionAndTopic [$chatConversationId, $chatConversationTopicId] = $this->chatAppService->initDelightfulChatConversation($dataIsolation); // 2. CreateTopic $topicEntity = $this->topicDomainService->createTopic( $dataIsolation, $projectEntity->getWorkspaceId(), (int) $requestDTO->getProjectId(), $chatConversationId, $chatConversationTopicId, // Session's TopicID $requestDTO->getTopicName(), $projectEntity->getWorkDir(), $requestDTO->getTopicMode() ); // 3. IfPassed in ed  project_mode, UpdateProjectMode if (! empty($requestDTO->getProjectMode())) { $projectEntity->setProjectMode($requestDTO->getProjectMode()); $projectEntity->setUpdatedAt(date('Y-m-d H:i:s')); $this->projectDomainService->saveProjectEntity($projectEntity); } // SubmitTransaction Db::commit(); // PublishTopic already CreateEvent $topicCreatedEvent = new TopicCreatedEvent($topicEntity, $userAuthorization); $this->eventDispatcher->dispatch($topicCreatedEvent); // ReturnResult return TopicItemDTO::fromEntity($topicEntity); } catch (Throwable $e) { // RollbackTransaction Db::rollBack(); $this->logger->error(sprintf("Error creating new topic: %s\n%s", $e->getMessage(), $e->getTraceAsString())); ExceptionBuilder::throw(SuperAgentErrorCode::CREATE_TOPIC_FAILED, 'topic.create_topic_failed'); } } public function createTopicNotValidateAccessibleProject(RequestContext $requestContext, SaveTopicRequestDTO $requestDTO): ?TopicItemDTO { // getuserauthorizationinformation $userAuthorization = $requestContext->getUserAuthorization(); // CreateDataIsolationObject $dataIsolation = $this->createDataIsolation($userAuthorization); $projectEntity = $this->projectDomainService->getProjectNotUserId((int) $requestDTO->getProjectId()); // Create new Topic, UseTransactionEnsureoriginalsubproperty Db::beginTransaction(); try { // 1. Initialize chat SessionAndTopic [$chatConversationId, $chatConversationTopicId] = $this->chatAppService->initDelightfulChatConversation($dataIsolation); // 2. CreateTopic $topicEntity = $this->topicDomainService->createTopic( $dataIsolation, (int) $requestDTO->getWorkspaceId(), (int) $requestDTO->getProjectId(), $chatConversationId, $chatConversationTopicId, // Session's TopicID $requestDTO->getTopicName(), $projectEntity->getWorkDir(), $requestDTO->getTopicMode(), ); // 3. IfPassed in ed  project_mode, UpdateProjectMode if (! empty($requestDTO->getProjectMode())) { $projectEntity->setProjectMode($requestDTO->getProjectMode()); $projectEntity->setUpdatedAt(date('Y-m-d H:i:s')); $this->projectDomainService->saveProjectEntity($projectEntity); } // SubmitTransaction Db::commit(); // ReturnResult return TopicItemDTO::fromEntity($topicEntity); } catch (Throwable $e) { // RollbackTransaction Db::rollBack(); $this->logger->error(sprintf("Error creating new topic: %s\n%s", $e->getMessage(), $e->getTraceAsString())); ExceptionBuilder::throw(SuperAgentErrorCode::CREATE_TOPIC_FAILED, 'topic.create_topic_failed'); } } public function updateTopic(RequestContext $requestContext, SaveTopicRequestDTO $requestDTO): SaveTopicResultDTO { // getuserauthorizationinformation $userAuthorization = $requestContext->getUserAuthorization(); // CreateDataIsolationObject $dataIsolation = $this->createDataIsolation($userAuthorization); $this->topicDomainService->updateTopic($dataIsolation, (int) $requestDTO->getId(), $requestDTO->getTopicName()); // getUpdate after TopicEntityUsed forEventPublish $topicEntity = $this->topicDomainService->getTopicById((int) $requestDTO->getId()); // PublishTopic already UpdateEvent if ($topicEntity) { $topicUpdatedEvent = new TopicUpdatedEvent($topicEntity, $userAuthorization); $this->eventDispatcher->dispatch($topicUpdatedEvent); } return SaveTopicResultDTO::fromId((int) $requestDTO->getId()); } public function renameTopic(DelightfulUserAuthorization $authorization, int $topicId, string $userQuestion, string $language = 'zh_CN'): array { // getTopicContent $topicEntity = $this->workspaceDomainService->getTopicById($topicId); if (! $topicEntity) { ExceptionBuilder::throw(SuperAgentErrorCode::TOPIC_NOT_FOUND, 'topic.topic_not_found'); } // callDomainServiceExecuteRename ( this onestepandmagic-service enter RowBind) try { $text = $this->magicChatMessageAppService->summarizeText($authorization, $userQuestion, $language); // UpdateTopicName $dataIsolation = $this->createDataIsolation($authorization); $this->topicDomainService->updateTopicName($dataIsolation, $topicId, $text); // getUpdate after TopicEntityAndPublishRenameEvent $updatedTopicEntity = $this->topicDomainService->getTopicById($topicId); if ($updatedTopicEntity) { $topicRenamedEvent = new TopicRenamedEvent($updatedTopicEntity, $authorization); $this->eventDispatcher->dispatch($topicRenamedEvent); } } catch (Exception $e) { $this->logger->error('rename topic error: ' . $e->getMessage()); $text = $topicEntity->getTopicName(); } return ['topic_name' => $text]; } /** * DeleteTopic. * * @param RequestContext $requestContext request context * @param DeleteTopicRequestDTO $requestDTO RequestDTO * @return DeleteTopicResultDTO DeleteResult * @throws BusinessException|Exception IfuserNo permission、TopicDoes not existin or TaskcorrectinRun*/ public function deleteTopic(RequestContext $requestContext, DeleteTopicRequestDTO $requestDTO): DeleteTopicResultDTO { // getuserauthorizationinformation $userAuthorization = $requestContext->getUserAuthorization(); // CreateDataIsolationObject $dataIsolation = $this->createDataIsolation($userAuthorization); // getTopicID $topicId = $requestDTO->getId(); //  first getTopicEntityUsed forEventPublish $topicEntity = $this->topicDomainService->getTopicById((int) $topicId); // callDomainServiceExecuteDelete $result = $this->topicDomainService->deleteTopic($dataIsolation, (int) $topicId); // DeliverEvent, StopService if ($result) { // PublishTopic already DeleteEvent if ($topicEntity) { $topicDeletedEvent = new TopicDeletedEvent($topicEntity, $userAuthorization); $this->eventDispatcher->dispatch($topicDeletedEvent); } $event = new StopRunningTaskEvent( DeleteDataType::TOPIC, (int) $topicId, $dataIsolation->getCurrentUserId(), $dataIsolation->getCurrentOrganizationCode(), 'TopicAlready be Delete' ); $publisher = new StopRunningTaskPublisher($event); $this->producer->produce($publisher); } // IfDeleteFailed, ThrowAbnormal if (! $result) { ExceptionBuilder::throw(GenericErrorCode::SystemError, 'topic.delete_failed'); } // ReturnDeleteResult return DeleteTopicResultDTO::fromId((int) $topicId); } /** * getRecentUpdated atexceedspecifiedTimeTopiclist. * * @param string $timeThreshold TimethresholdValue, IfTopicUpdated atEarlier than thisTime, Will becontaininginResult in  * @param int $limit ReturnResultMaximumQuantity * @return array<TopicEntity> TopicEntitylist*/ public function getTopicsExceedingUpdateTime(string $timeThreshold, int $limit = 100): array { return $this->topicDomainService->getTopicsExceedingUpdateTime($timeThreshold, $limit); } public function getTopicByChatTopicId(DataIsolation $dataIsolation, string $chatTopicId): ?TopicEntity { return $this->topicDomainService->getTopicByChatTopicId($dataIsolation, $chatTopicId); } public function getTopicAttachmentsByAccessToken(GetTopicAttachmentsRequestDTO $requestDto): array { $token = $requestDto->getToken(); // fromCacheinsidegetData if (! AccessTokenUtil::validate($token)) { ExceptionBuilder::throw(GenericErrorCode::AccessDenied, 'task_file.access_denied'); } // fromtoken getContent $shareId = AccessTokenUtil::getShareId($token); $shareEntity = $this->resourceShareDomainService->getValidShareById($shareId); if (! $shareEntity) { ExceptionBuilder::throw(ShareErrorCode::RESOURCE_NOT_FOUND, 'share.resource_not_found'); } if ($shareEntity->getResourceType() != ResourceType::Topic->value) { ExceptionBuilder::throw(ShareErrorCode::RESOURCE_TYPE_NOT_SUPPORTED, 'share.resource_type_not_supported'); } $organizationCode = AccessTokenUtil::getOrganizationCode($token); $requestDto->setTopicId($shareEntity->getResourceId()); // CreateDataIsolation $dataIsolation = DataIsolation::simpleMake($organizationCode, ''); return $this->getTopicAttachmentList($dataIsolation, $requestDto); } public function getTopicAttachmentList(DataIsolation $dataIsolation, GetTopicAttachmentsRequestDTO $requestDto): array { // JudgeTopicwhether store in $topicEntity = $this->topicDomainService->getTopicById((int) $requestDto->getTopicId()); if (empty($topicEntity)) { return []; } $projectEntity = $this->projectDomainService->getProjectNotUserId($topicEntity->getProjectId()); $sandboxId = $topicEntity->getSandboxId(); $workDir = $topicEntity->getWorkDir(); // throughDomainServicegetTopicAttachmentlist $result = $this->taskDomainService->getTaskAttachmentsByTopicId( (int) $requestDto->getTopicId(), $dataIsolation, $requestDto->getPage(), $requestDto->getPageSize(), $requestDto->getFileType() ); // Process/HandleFile URL $list = []; $projectOrganizationCode = $projectEntity->getUserOrganizationCode(); // TraverseAttachmentlist, UseTaskFileItemDTOProcess/Handle foreach ($result['list'] as $entity) { // CreateDTO $dto = new TaskFileItemDTO(); $dto->fileId = (string) $entity->getFileId(); $dto->taskId = (string) $entity->getTaskId(); $dto->fileType = $entity->getFileType(); $dto->fileName = $entity->getFileName(); $dto->fileExtension = $entity->getFileExtension(); $dto->fileKey = $entity->getFileKey(); $dto->fileSize = $entity->getFileSize(); $dto->isHidden = $entity->getIsHidden(); $dto->topicId = (string) $entity->getTopicId(); // Calculate relative file path by removing workDir from fileKey $fileKey = $entity->getFileKey(); $workDirPos = strpos($fileKey, $workDir); if ($workDirPos !== false) { $dto->relativeFilePath = substr($fileKey, $workDirPos + strlen($workDir)); } else { $dto->relativeFilePath = $fileKey; // If workDir not found, use original fileKey } // add file_url field $fileKey = $entity->getFileKey(); if (! empty($fileKey)) { $fileLink = $this->fileAppService->getLink($projectOrganizationCode, $fileKey, StorageBucketType::SandBox); if ($fileLink) { $dto->fileUrl = $fileLink->getUrl(); } else { $dto->fileUrl = ''; } } else { $dto->fileUrl = ''; } $list[] = $dto->toArray(); } // Buildtree state structure $tree = FileTreeUtil::assembleFilesTree($list); return [ 'list' => $list, 'tree' => $tree, 'total' => $result['total'], ]; } /** * getTopicAttachmentlist.(managementBackgroundUse). * * @param DelightfulUserAuthorization $userAuthorization userauthorizationinformation * @param GetTopicAttachmentsRequestDTO $requestDto TopicAttachmentRequestDTO * @return array Attachmentlist*/ public function getTopicAttachments(DelightfulUserAuthorization $userAuthorization, GetTopicAttachmentsRequestDTO $requestDto): array { // getCurrentTopicCreator $topicEntity = $this->topicDomainService->getTopicById((int) $requestDto->getTopicId()); if ($topicEntity === Null) { ExceptionBuilder::throw(SuperAgentErrorCode::TOPIC_NOT_FOUND, 'topic.topic_not_found'); } // CreateDataIsolationObject $dataIsolation = $this->createDataIsolation($userAuthorization); return $this->getTopicAttachmentList($dataIsolation, $requestDto); } /** * getuserTopicMessagelist. * * @param DelightfulUserAuthorization $userAuthorization userauthorizationinformation * @param int $topicId TopicID * @param int $page Page number * @param int $pageSize Page size * @param string $sortDirection Sort direction * @return array MessagelistandTotal*/ public function getUserTopicMessage(DelightfulUserAuthorization $userAuthorization, int $topicId, int $page, int $pageSize, string $sortDirection): array { // getMessagelist $result = $this->taskDomainService->getMessagesByTopicId($topicId, $page, $pageSize, true, $sortDirection); // Convert toResponseformat $messages = []; foreach ($result['list'] as $message) { $messages[] = new MessageItemDTO($message->toArray()); } return [ 'list' => $messages, 'total' => $result['total'], ]; } /** * getuserTopicAttachment URL. (managementBackgroundUse). * * @param string $topicId Topic ID * @param DelightfulUserAuthorization $userAuthorization userauthorizationinformation * @param array $fileIds FileIDlist * @return array containingAttachment URL Array*/ public function getTopicAttachmentUrl(DelightfulUserAuthorization $userAuthorization, string $topicId, array $fileIds, string $downloadMode): array { $result = []; foreach ($fileIds as $fileId) { // getFileEntity $fileEntity = $this->taskDomainService->getTaskFile((int) $fileId); if (empty($fileEntity)) { // IfFileDoes not existin, Skip continue; } $downloadNames = []; if ($downloadMode == 'download') { $downloadNames[$fileEntity->getFileKey()] = $fileEntity->getFileName(); } $fileLink = $this->fileAppService->getLink($fileEntity->getOrganizationCode(), $fileEntity->getFileKey(), StorageBucketType::SandBox, $downloadNames); if (empty($fileLink)) { // IfgetlinkFailed, Skip continue; } $result[] = [ 'file_id' => (string) $fileEntity->getFileId(), 'url' => $fileLink->getUrl(), ]; } return $result; } /** * Duplicate topic (synchronous) - blocks until completion. * This method performs complete topic duplication synchronously without task management. * * @param RequestContext $requestContext Request context * @param string $sourceTopicId Source topic ID * @param DuplicateTopicRequestDTO $requestDTO Request DTO * @return array Complete result with topic info * @throws BusinessException If validation fails or operation fails */ public function duplicateTopic(RequestContext $requestContext, string $sourceTopicId, DuplicateTopicRequestDTO $requestDTO): array { $userAuthorization = $requestContext->getUserAuthorization(); $this->logger->info('Topic duplication sync started', [ 'user_id' => $userAuthorization->getId(), 'source_topic_id' => $sourceTopicId, 'target_message_id' => $requestDTO->getTargetMessageId(), 'new_topic_name' => $requestDTO->getNewTopicName(), ]); // Validate topic and permissions $sourceTopicEntity = $this->topicDomainService->getTopicById((int) $sourceTopicId); if (! $sourceTopicEntity) { ExceptionBuilder::throw(SuperAgentErrorCode::TOPIC_NOT_FOUND, 'topic.topic_not_found'); } if ($sourceTopicEntity->getUserId() !== $userAuthorization->getId()) { ExceptionBuilder::throw(SuperAgentErrorCode::TOPIC_ACCESS_DENIED, 'topic.access_denied'); } // Create data isolation $dataIsolation = $this->createDataIsolation($userAuthorization); // Execute complete duplication in transaction Db::beginTransaction(); try { // Call domain service - pure business logic $newTopicEntity = $this->topicDomainService->duplicateTopic( $dataIsolation, $sourceTopicEntity, $requestDTO->getNewTopicName(), (int) $requestDTO->getTargetMessageId() ); Db::commit(); $this->logger->info('Topic duplication sync completed', [ 'source_topic_id' => $sourceTopicId, 'new_topic_id' => $newTopicEntity->getId(), ]); // Return complete result return [ 'status' => 'completed', 'message' => 'Topic duplicated successfully', 'topic' => TopicItemDTO::fromEntity($newTopicEntity)->toArray(), ]; } catch (Throwable $e) { Db::rollBack(); $this->logger->error('Topic duplication sync failed', [ 'source_topic_id' => $sourceTopicId, 'error' => $e->getMessage(), 'trace' => $e->getTraceAsString(), ]); throw $e; } } /** * Duplicate topic (asynchronous) - returns immediately with task_id. * This method creates topic skeleton synchronously, then copies messages asynchronously. * * @param RequestContext $requestContext Request context * @param string $sourceTopicId Source topic ID * @param DuplicateTopicRequestDTO $requestDTO Request DTO * @return array Task info with task_id * @throws BusinessException If validation fails or operation fails */ public function duplicateChatAsync(RequestContext $requestContext, string $sourceTopicId, DuplicateTopicRequestDTO $requestDTO): array { // getuserauthorizationinformation $userAuthorization = $requestContext->getUserAuthorization(); $this->logger->info('Starting topic duplication async (skeleton sync + message copy async)', [ 'user_id' => $userAuthorization->getId(), 'source_topic_id' => $sourceTopicId, 'target_message_id' => $requestDTO->getTargetMessageId(), 'new_topic_name' => $requestDTO->getNewTopicName(), ]); // ValidateTopic store inAndPermission $sourceTopicEntity = $this->topicDomainService->getTopicById((int) $sourceTopicId); if (! $sourceTopicEntity) { ExceptionBuilder::throw(SuperAgentErrorCode::TOPIC_NOT_FOUND, 'topic.topic_not_found'); } // JudgeTopicwhether is this user  if ($sourceTopicEntity->getUserId() !== $userAuthorization->getId()) { ExceptionBuilder::throw(SuperAgentErrorCode::TOPIC_ACCESS_DENIED, 'topic.access_denied'); } // === SyncPart: CreateTopicskeleton === $dataIsolation = $this->createDataIsolation($userAuthorization); // inTransactionCreate inTopicskeleton Db::beginTransaction(); try { // call Domain layerCreateTopicskeleton (containing IM Session) $duplicateResult = $this->topicDomainService->duplicateTopicSkeleton( $dataIsolation, $sourceTopicEntity, $requestDTO->getNewTopicName() ); $newTopicEntity = $duplicateResult['topic_entity']; $imConversationResult = $duplicateResult['im_conversation']; // SubmitTransaction Db::commit(); $this->logger->info('Topic skeleton created successfully (sync)', [ 'source_topic_id' => $sourceTopicId, 'new_topic_id' => $newTopicEntity->getId(), ]); } catch (Throwable $e) { Db::rollBack(); $this->logger->error('Failed to create topic skeleton (sync)', [ 'source_topic_id' => $sourceTopicId, 'error' => $e->getMessage(), ]); throw $e; } // ConvertTopicEntityConvert to DTO $topicItemDTO = TopicItemDTO::fromEntity($newTopicEntity); // GenerateTaskKey $taskKey = TopicDuplicateConstant::generateTaskKey($sourceTopicId, $userAuthorization->getId()); // InitializeAsyncTask $taskData = [ 'source_topic_id' => $sourceTopicId, 'target_message_id' => $requestDTO->getTargetMessageId(), 'new_topic_name' => $requestDTO->getNewTopicName(), 'user_id' => $userAuthorization->getId(), 'new_topic_id' => $newTopicEntity->getId(), // Save new TopicID 'im_conversation' => $imConversationResult, // Save IM SessionInformation ]; $this->topicDuplicateStatusManager->initializeTask($taskKey, $userAuthorization->getId(), $taskData); // getCurrentRequestID $requestId = CoContext::getRequestId() ?: (string) IdGenerator::getSnowId(); // === AsyncPart: copiedMessage === go(function () use ($sourceTopicEntity, $newTopicEntity, $requestDTO, $imConversationResult, $taskKey, $requestId) { // copiedrequest context CoContext::setRequestId($requestId); try { // UpdateTaskStatus: StartcopiedMessage $this->topicDuplicateStatusManager->setTaskProgress($taskKey, 10, 'Starting to copy messages'); // StartData database Transaction Db::beginTransaction(); try { // ExecuteMessagecopiedLogic $this->topicDomainService->copyTopicMessageFromOthers( $sourceTopicEntity, $newTopicEntity, (int) $requestDTO->getTargetMessageId(), $imConversationResult, //  enter degreeCallbackFunction function (string $status, int $progress, string $message) use ($taskKey) { $this->topicDuplicateStatusManager->setTaskProgress($taskKey, $progress, $message); } ); // SubmitTransaction Db::commit(); // TaskComplete $this->topicDuplicateStatusManager->setTaskCompleted($taskKey, [ 'topic_id' => $newTopicEntity->getId(), 'topic_name' => $newTopicEntity->getTopicName(), 'project_id' => $newTopicEntity->getProjectId(), 'workspace_id' => $newTopicEntity->getWorkspaceId(), ]); $this->logger->info('Topic message copy completed successfully (async)', [ 'task_key' => $taskKey, 'source_topic_id' => $sourceTopicEntity->getId(), 'new_topic_id' => $newTopicEntity->getId(), ]); } catch (Throwable $e) { // RollbackTransaction Db::rollBack(); throw $e; //  re ThrowAbnormal， let outsidelayercatchProcess/Handle } } catch (Throwable $e) { // TaskFailed $this->topicDuplicateStatusManager->setTaskFailed($taskKey, $e->getMessage()); $this->logger->error('Async topic message copy failed', [ 'task_key' => $taskKey, 'source_topic_id' => $sourceTopicEntity->getId(), 'new_topic_id' => $newTopicEntity->getId(), 'error' => $e->getMessage(), 'file' => $e->getFile(), 'line' => $e->getLine(), 'trace' => $e->getTraceAsString(), ]); } }); // standinstantReturnTaskinformationAnd newCreateTopic return [ 'task_id' => $taskKey, 'status' => 'copying', 'message' => 'Topic created, copying messages in background', 'topic' => $topicItemDTO->toArray(), // Add new：standinstantReturnTopicInformation ]; } /** * CheckTopiccopiedStatus * * @param RequestContext $requestContext request context * @param string $taskKey TaskKey * @return array copiedStatusinformation * @throws BusinessException throws exception if parameters are invalid or operation fails*/ public function checkDuplicateChatStatus(RequestContext $requestContext, string $taskKey): array { // getuserauthorizationinformation $userAuthorization = $requestContext->getUserAuthorization(); $this->logger->info('Checking topic duplication status', [ 'user_id' => $userAuthorization->getId(), 'task_key' => $taskKey, ]); try { // ValidateuserPermission if (! $this->topicDuplicateStatusManager->verifyUserPermission($taskKey, $userAuthorization->getId())) { ExceptionBuilder::throw(SuperAgentErrorCode::TASK_ACCESS_DENIED, 'Task access denied'); } // getTaskStatus $taskStatus = $this->topicDuplicateStatusManager->getTaskStatus($taskKey); if (! $taskStatus) { ExceptionBuilder::throw(SuperAgentErrorCode::TASK_NOT_FOUND, 'Task not found or expired'); } // BuildReturnResult $result = [ 'task_id' => $taskKey, 'status' => $taskStatus['status'], // running, completed, failed 'message' => $taskStatus['message'] ?? 'Topic duplication in progress', ]; // add enter degreeinformation if (isset($taskStatus['progress'])) { $result['progress'] = [ 'percentage' => $taskStatus['progress']['percentage'], 'message' => $taskStatus['progress']['message'] ?? '', ]; } // IfTaskComplete, ReturnResultinformation if ($taskStatus['status'] === 'completed' && isset($taskStatus['result'])) { $topicEntity = $this->topicDomainService->getTopicById($taskStatus['result']['topic_id']); $result['result'] = TopicItemDTO::fromEntity($topicEntity)->toArray(); } // IfTaskFailed, ReturnErrorinformation if ($taskStatus['status'] === 'failed' && isset($taskStatus['error'])) { $result['error'] = $taskStatus['error']; } return $result; } catch (Throwable $e) { $this->logger->error('Failed to check topic duplication status', [ 'user_id' => $userAuthorization->getId(), 'task_key' => $taskKey, 'error' => $e->getMessage(), 'trace' => $e->getTraceAsString(), ]); throw $e; } } public function downloadChatHistory(RequestContext $requestContext, int $id): array { return []; } } 