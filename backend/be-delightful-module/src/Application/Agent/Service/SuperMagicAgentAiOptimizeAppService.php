<?php declare(strict_types=1); /** * Copyright (c) Be Delightful , Distributed under the MIT software license */ namespace Delightful\SuperDelightful\Application\Agent\Service; use DateTime; use Delightful\SuperDelightful\Domain\Agent\Entity\SuperDelightfulAgentEntity; use Delightful\SuperDelightful\Domain\Agent\Entity\ValueObject\SuperDelightfulAgentOptimizationType; use Delightful\SuperDelightful\Domain\Agent\Entity\ValueObject\SuperDelightfulAgentTool; use Hyperf\Odin\Api\Response\ChatCompletionResponse; use Hyperf\Odin\Message\AssistantMessage; use Qbhy\HyperfAuth\Authenticatable; class SuperDelightfulAgentAiOptimizeAppService extends AbstractSuperDelightfulAppService { public function optimizeAgent(Authenticatable $authorization, SuperDelightfulAgentOptimizationType $optimizationType, SuperDelightfulAgentEntity $agentEntity, array $availableTools): SuperDelightfulAgentEntity { $dataIsolation = $this->createSuperDelightfulDataIsolation($authorization); $agentEntity->setCreator($dataIsolation->getCurrentUserId()); $agentEntity->setCreatedAt(new DateTime()); $agentEntity->setModifier($dataIsolation->getCurrentUserId()); $agentEntity->setUpdatedAt(new DateTime()); $agentEntity->setOrganizationCode($dataIsolation->getCurrentOrganizationCode()); if ($optimizationType->isNone()) { $this->logger->info('No optimization type selected, returning original entity.'); return $agentEntity; } // CheckOptimizePrerequisiteCondition, Not satisfyCondition time directlyReturnoriginalEntity if ($this->checkOptimizationPreconditions($optimizationType, $agentEntity)) { $this->logger->info('Optimization preconditions not met, returning original entity.'); return $agentEntity; } // 1. getOptimize Agent (specifiedFile path) $agentFilePath = SUPER_DELIGHTFUL_MODULE_PATH . '/src/Application/Agent/MicroAgent/AgentOptimizer.agent.yaml'; // @phpstan-ignore-line $optimizerAgent = $this->microAgentFactory->getAgent('SuperDelightfulAgentOptimizer', $agentFilePath); // 2. setOptimizeTool $optimizerAgent->setTools($this->getAgentOptimizerTools()); // 3. BuilduserTipword $userPrompt = $this->buildUserPrompt($optimizationType, $agentEntity, $availableTools); // 4. call AI  enter RowOptimize $response = $optimizerAgent->easyCall( organizationCode: $dataIsolation->getCurrentOrganizationCode(), userPrompt: $userPrompt, businessParams: [ 'organization_id' => $dataIsolation->getCurrentOrganizationCode(), 'user_id' => $dataIsolation->getCurrentUserId(), 'source_id' => 'super_magic_agent_optimizer', ] ); // 5. ExtractToolcallResultAndUpdateEntity return $this->extractToolCallResult($response, $agentEntity, $availableTools); } private function getAgentOptimizerTools(): array { return [ // 1. OptimizeNameAndDescriptionTool [ 'type' => 'function', 'function' => [ 'name' => SuperDelightfulAgentOptimizationType::OptimizeNameDescription->value, 'description' => 'By/According toContentForAgentOptimizeNaming andDescription', 'parameters' => [ 'type' => 'object', 'properties' => [ 'name' => [ 'type' => 'string', 'description' => 'AgentName（Must is 2-10charactersconciseName， like ：smallred bookbigmaster、Copy expert）', ], 'description' => [ 'type' => 'string', 'description' => 'AgentDescription（20-100charactersFunctionDescription）', ], ], 'required' => ['name', 'description'], ], ], ], // 2. OptimizeContentTool [ 'type' => 'function', 'function' => [ 'name' => SuperDelightfulAgentOptimizationType::OptimizeContent->value, 'description' => 'By/According toNameAndDescriptionForAgentOptimizeContent', 'parameters' => [ 'type' => 'object', 'properties' => [ 'prompt' => [ 'type' => 'string', 'description' => 'SystemTipwordContent', ], 'tools' => [ 'type' => 'array', 'items' => [ 'type' => 'string', ], 'description' => 'RecommendToolCodeList， only ReturnToolcodeField', ], ], 'required' => ['prompt'], ], ], ], // 3. OptimizeNameTool [ 'type' => 'function', 'function' => [ 'name' => SuperDelightfulAgentOptimizationType::OptimizeName->value, 'description' => 'By/According toAlreadyFill inAllInformationOptimizeAgentName', 'parameters' => [ 'type' => 'object', 'properties' => [ 'name' => [ 'type' => 'string', 'description' => 'Optimize after AgentName（Must is 2-10charactersconciseName，Cannot is Completesentencesub）', ], ], 'required' => ['name'], ], ], ], // 4. OptimizeDescriptionTool [ 'type' => 'function', 'function' => [ 'name' => SuperDelightfulAgentOptimizationType::OptimizeDescription->value, 'description' => 'By/According toAlreadyFill inAllInformationOptimizeAgentDescription', 'parameters' => [ 'type' => 'object', 'properties' => [ 'description' => [ 'type' => 'string', 'description' => 'Optimize after AgentDescription', ], ], 'required' => ['description'], ], ], ], ]; } private function buildUserPrompt(SuperDelightfulAgentOptimizationType $optimizationType, SuperDelightfulAgentEntity $agentEntity, array $availableTools): string { $agentData = [ 'name' => $agentEntity->getName(), 'description' => $agentEntity->getDescription(), 'prompt' => $agentEntity->getPromptString(), 'tools' => $agentEntity->getTools(), ]; // languagelanguageTip: ifcontainingChineseCharacter,  then TipChinese, OtherwiseAuto $combined = (string) ($agentData['name'] . $agentData['description'] . $agentData['prompt']); $languageHint = preg_match('/\p{Han}/u', $combined) ? 'zh' : 'auto'; $requestData = [ 'ot' => $optimizationType->value, 'data' => $agentData, 'rules' => [ 'tool' => 'single_call_match_type', 'name' => '2-10_chars_no_punct_no_sentence', 'desc' => '20-100_chars_value_focus', 'content' => 'preserve_depth_format_supplement_sections', 'ignore' => 'basic_tools_ignored', 'diverse' => 'must_diff_prev', 'no_copy' => 'forbidden_output_same_as_input', 'lang' => 'match_input_and_headers', ], 'meta' => [ 'ts' => time(), 'lang_hint' => $languageHint, 'src' => 'super_magic_agent_optimizer', ], ]; // If is OptimizeContentAnd haveAvailableTool, add to RequestData in  if ($optimizationType === SuperDelightfulAgentOptimizationType::OptimizeContent && ! empty($availableTools)) { $requestData['available_tools'] = array_values($availableTools); } $jsonString = json_encode($requestData, JSON_UNESCAPED_UNICODE); $instruction = ' by  rules  enter RowOnceOptimize，onlycalland ot Pair should singleoneTool。Input(JSON)：'; return $instruction . $jsonString; } private function extractToolCallResult(ChatCompletionResponse $response, SuperDelightfulAgentEntity $agentEntity, array $availableTools): SuperDelightfulAgentEntity { // parse response  in Toolcall // IfNo/NoneToolcallOr parseFailed, ReturnOriginalEntity $assistantMessage = $response->getFirstChoice()?->getMessage(); if (! $assistantMessage instanceof AssistantMessage) { return $agentEntity; } if (! $assistantMessage->hasToolCalls()) { $this->logger->info('No assistant message selected, returning original entity.'); return $agentEntity; } foreach ($assistantMessage->getToolCalls() as $toolCall) { $this->logger->info('tool_call', $toolCall->toArray()); $toolName = $toolCall->getName(); $arguments = $toolCall->getArguments(); switch ($toolName) { case SuperDelightfulAgentOptimizationType::OptimizeNameDescription->value: if (isset($arguments['name'])) { $agentEntity->setName($arguments['name']); } if (isset($arguments['description'])) { $agentEntity->setDescription($arguments['description']); } break; case SuperDelightfulAgentOptimizationType::OptimizeContent->value: if (isset($arguments['prompt'])) { // Process/HandleconvertmeaningCharacter, Convert \\n、\\t、\\r waitConvert toActualexchangeRowsymbolAndmakeTablesymbol $processedPrompt = stripcslashes($arguments['prompt']); $promptData = [ 'version' => '1.0.0', 'structure' => [ 'string' => $processedPrompt, ], ]; $agentEntity->setPrompt($promptData); } // Process/HandleToolRecommend:  only add new Tool,  not Modify or DeleteOriginalTool if (isset($arguments['tools']) && is_array($arguments['tools'])) { foreach ($arguments['tools'] as $toolCode) { $tool = $this->createToolFromAvailableTools($toolCode, $availableTools); if ($tool) { $agentEntity->addTool($tool); } } } break; case SuperDelightfulAgentOptimizationType::OptimizeName->value: if (isset($arguments['name'])) { $agentEntity->setName($arguments['name']); } break; case SuperDelightfulAgentOptimizationType::OptimizeDescription->value: if (isset($arguments['description'])) { $agentEntity->setDescription($arguments['description']); } break; } } return $agentEntity; } /** * CheckOptimizePrerequisiteCondition.*/ private function checkOptimizationPreconditions(SuperDelightfulAgentOptimizationType $optimizationType, SuperDelightfulAgentEntity $agentEntity): bool { // IfAllContentForEmpty, Then not enterRowOptimize if (empty($agentEntity->getName()) && empty($agentEntity->getDescription()) && empty($agentEntity->getPromptString())) { return true; } return false; } /** * fromAvailableToollistCreate in SuperDelightfulAgentTool Object*/ private function createToolFromAvailableTools(string $toolCode, array $availableTools): ?SuperDelightfulAgentTool { // thOnceFind: through code fieldMatch if (isset($availableTools[$toolCode])) { $toolInfo = $availableTools[$toolCode]; return new SuperDelightfulAgentTool([ 'code' => $toolInfo['code'], 'name' => $toolInfo['name'] ?? '', 'description' => $toolInfo['description'] ?? '', 'type' => $toolInfo['type'] === 'builtin' ? 1 : 3, ]); } // thtwo times Find: through name fieldMatch (fault tolerantmachinemake) foreach ($availableTools as $tool) { if (($tool['name'] ?? '') === $toolCode) { return new SuperDelightfulAgentTool([ 'code' => $tool['code'], 'name' => $tool['name'] ?? '', 'description' => $tool['description'] ?? '', 'type' => $tool['type'] === 'builtin' ? 1 : 3, ]); } } // IfTwiceFindallNo/NoneFound, Return Null return Null; } } 