<?php declare(strict_types=1); /** * Copyright (c) Be Delightful , Distributed under the software license */ namespace Dtyq\SuperMagic\Domain\SuperAgent\Repository\Facade; use Dtyq\SuperMagic\Domain\SuperAgent\Entity\TaskMessageEntity; use Dtyq\SuperMagic\Domain\SuperAgent\Repository\Model\TaskMessageModel; interface TaskMessageRepositoryInterface { /** * throughIDgetMessage.*/ public function getById(int $id): ?TaskMessageEntity; /** * SaveMessage.*/ public function save(TaskMessageEntity $message): void; /** * BatchSaveMessage. * @param TaskMessageEntity[] $messages*/ public function batchSave(array $messages): void; /** * By/According toTaskIDgetMessagelist. * @return TaskMessageEntity[]*/ public function findByTaskId(string $taskId): array; /** * By/According toTopicIDAndTaskIDgetuserMessagelist (OptimizeIndex+FilteruserMessage). * @return TaskMessageEntity[]*/ public function findUserMessagesByTopicIdAndTaskId(int $topicId, string $taskId): array; /** * By/According toTopicIDgetMessagelist, SupportPagination. * @param int $topicId TopicID * @param int $page Page number * @param int $pageSize Page size * @param bool $shouldPage whetherNeedPagination * @param string $sortDirection Sort direction, SupportascAnddesc * @param bool $showInUi whether only displayedUIVisibleMessage * @return array ReturncontainingMessagelistAndTotalArray ['list' => TaskMessageEntity[], 'total' => int]*/ public function findByTopicId(int $topicId, int $page = 1, int $pageSize = 20, bool $shouldPage = true, string $sortDirection = 'asc', bool $showInUi = true): array; public function getUserFirstMessageByTopicId(int $topicId, string $userId): ?TaskMessageEntity; /** * By/According totopic_idAndProcess/HandleStatusQueryMessagelist,  by seq_idAscendinglineColumn. * @param int $topicId TopicID * @param string $processingStatus Process/HandleStatus * @param string $senderType SenderType * @param int $limit Limit quantity * @return TaskMessageEntity[]*/ public function findPendingMessagesByTopicId(int $topicId, string $processingStatus, string $senderType = 'assistant', int $limit = 50): array; /** * UpdateMessageProcess/HandleStatus. * @param int $id MessageID * @param string $processingStatus Process/HandleStatus * @param Null|string $errorMessage Errorinformation * @param int $retryCount Retry times  count */ public function updateProcessingStatus(int $id, string $processingStatus, ?string $errorMessage = Null, int $retryCount = 0): void; /** * BatchUpdateMessageProcess/HandleStatus. * @param array $ids MessageIDArray * @param string $processingStatus Process/HandleStatus*/ public function batchUpdateProcessingStatus(array $ids, string $processingStatus): void; /** * getNextseq_id.*/ public function getNextSeqId(int $topicId, int $taskId): int; /** * SaveOriginalMessageDataAndGenerateseq_id. * @param array $rawData OriginalMessageData * @param TaskMessageEntity $message MessageEntity * @param string $processStatus Process/HandleStatus*/ public function saveWithRawData(array $rawData, TaskMessageEntity $message, string $processStatus = TaskMessageModel::PROCESSING_STATUS_PENDING): void; /** * By/According toseq_idAndtopic_idQueryMessage. * @param int $seqId SequenceID * @param int $taskId TaskID * @param int $topicId TopicID * @return Null|TaskMessageEntity MessageEntity or Null*/ public function findBySeqIdAndTopicId(int $seqId, int $taskId, int $topicId): ?TaskMessageEntity; /** * By/According totopic_idAndmessage_idQueryMessage. * @param int $topicId TopicID * @param string $messageId MessageID * @return Null|TaskMessageEntity MessageEntity or Null*/ public function findByTopicIdAndMessageId(int $topicId, string $messageId): ?TaskMessageEntity; /** * UpdateExistingMessageBusinessfield. * @param TaskMessageEntity $message MessageEntity*/ public function updateExistingMessage(TaskMessageEntity $message): void; /** * getpendingProcess/HandleMessagelist (Used forSequentialBatchProcess/Handle). * * QueryCondition: * - pending: All processing * - processing: exceedspecifiedNumber of minutes (recognizeFor alreadyTimeout) * - failed: Retry times  count  not exceedMaximumValue * * @param int $topicId TopicID * @param string $senderType SenderType * @param int $timeoutMinutes Process/HandleTimeoutTime (Minute) * @param int $maxRetries MaximumRetry times  count  * @param int $limit Limit quantity * @return TaskMessageEntity[]  by seq_idAscendinglineColumnMessagelist*/ public function findProcessableMessages( int $topicId, int $taskId, string $senderType = 'assistant', int $timeoutMinutes = 30, int $maxRetries = 3, int $limit = 50 ): array; /** * By/According toTopicIDAndMessageIDgetNeedcopiedMessagelist. * * @param int $topicId TopicID * @param int $messageId MessageID (getsmallinwaitinthisIDMessage) * @return TaskMessageEntity[] MessageEntityArray,  by idAscendinglineColumn*/ public function findMessagesToCopyByTopicIdAndMessageId(int $topicId, int $messageId): array; /** * BatchCreateMessage. * * @param TaskMessageEntity[] $messageEntities MessageEntityArray * @return TaskMessageEntity[] Created successfullyMessageEntityArray (containingGenerateID)*/ public function batchCreateMessages(array $messageEntities): array; /** * UpdateMessageIMSequenceID. * * @param int $id MessageID * @param Null|int $imSeqId IMSequenceID, ForEmpty time  not Update*/ public function updateMessageSeqId(int $id, ?int $imSeqId): void; } 