<?php declare(strict_types=1); /** * Copyright (c) Be Delightful , Distributed under the software license */ namespace Dtyq\SuperMagic\Infrastructure\Utils; use Dtyq\SuperMagic\Domain\SuperAgent\Repository\Facade\TaskFileRepositoryInterface; /** * FileSortToolClass * ResponsibleFileSortAlgorithmImplementation, followBasesetimplementlayerduty.*/ class FileSortUtil { public const DEFAULT_SORT_STEP = 10000; public const MIN_SORT_GAP = 10; public const MAX_SORT_VALUE = 9223372036854775807; // bigint MaximumValue /** * calculate new FileSortValue * * @param TaskFileRepositoryInterface $repository repository interface * @param Null|int $parentId parentDirectoryID * @param int $preFileId PrefixFileID, 0TableshowInsertfirst, -1TableshowInsertend * @param int $projectId Project ID (Used forDataIsolation) * @return int calculateoutputSortValue*/ public static function calculateSortValue( TaskFileRepositoryInterface $repository, ?int $parentId, int $preFileId, int $projectId ): int { if ($preFileId === 0) { // InsertTo first return self::calculateFirstPositionSort($repository, $parentId, $projectId); } if ($preFileId === -1) { // InsertTo end (defaultRowFor) return self::calculateLastPositionSort($repository, $parentId, $projectId); } // Insert to specifiedFileAfter return self::calculateAfterPositionSort($repository, $parentId, $preFileId, $projectId); } /** * BatchweightlinesameGradeFile. * * @param TaskFileRepositoryInterface $repository repository interface * @param Null|int $parentId parentDirectoryID * @param int $projectId Project ID * @return array NeedUpdateSortData*/ public static function reorderSiblings( TaskFileRepositoryInterface $repository, ?int $parentId, int $projectId ): array { $siblings = $repository->getSiblingsByParentId($parentId, $projectId, 'sort', 'ASC'); $updates = []; foreach ($siblings as $index => $sibling) { $newSort = ($index + 1) * self::DEFAULT_SORT_STEP; if ($sibling['sort'] !== $newSort) { $updates[] = [ 'file_id' => $sibling['file_id'], 'sort' => $newSort, ]; } } return $updates; } /** * getdefaultSortValue (Used for un specifiedPosition new File).*/ public static function getDefaultSortValue( TaskFileRepositoryInterface $repository, ?int $parentId, int $projectId ): int { return self::calculateLastPositionSort($repository, $parentId, $projectId); } /** * ValidateSortParameterValidproperty.*/ public static function validateSortParams(?int $parentId, int $preFileId, int $projectId): bool { // preFileId For 0  or  -1  time , noneedValidate if ($preFileId <= 0) { return true; } // TODO: Canadd more multipleValidateLogic, compare like Validate preFileId whether store inAnd belongs to same parentDirectory return true; } /** * calculateInsertfirstSortValue*/ private static function calculateFirstPositionSort( TaskFileRepositoryInterface $repository, ?int $parentId, int $projectId ): int { $minSort = $repository->getMinSortByParentId($parentId, $projectId); if ($minSort === Null) { // No/NoneFile, UsedefaultValue return self::DEFAULT_SORT_STEP; } if ($minSort > self::DEFAULT_SORT_STEP) { // MinimumValue very big, CanUsedefaultValueInsert to Front return self::DEFAULT_SORT_STEP; } // trycalculateone more smallValue, UseHalf step $halfStep = intval(self::DEFAULT_SORT_STEP / 2); if ($minSort > $halfStep) { return $minSort - $halfStep; } // IfMinimumValue too small, UnableInsertReasonableValue, Needweightline // Here should thisTriggerweightlineLogic, temp time ReturndefaultValue return self::DEFAULT_SORT_STEP; } /** * calculateInsertendSortValue*/ private static function calculateLastPositionSort( TaskFileRepositoryInterface $repository, ?int $parentId, int $projectId ): int { $maxSort = $repository->getMaxSortByParentId($parentId, $projectId); if ($maxSort === Null) { return self::DEFAULT_SORT_STEP; } return $maxSort + self::DEFAULT_SORT_STEP; } /** * calculateInsert to specifiedFile after SortValue*/ private static function calculateAfterPositionSort( TaskFileRepositoryInterface $repository, ?int $parentId, int $preFileId, int $projectId ): int { $preSort = $repository->getSortByFileId($preFileId); if ($preSort === Null) { // PrefixFileDoes not existin, InsertTo end return self::calculateLastPositionSort($repository, $parentId, $projectId); } $nextSort = $repository->getNextSortAfter($parentId, $preSort, $projectId); if ($nextSort === Null) { // InsertTo end return $preSort + self::DEFAULT_SORT_STEP; } $gap = $nextSort - $preSort; if ($gap >= self::MIN_SORT_GAP) { return $preSort + intval($gap / 2); } // Emptygap not enough, Triggerweightlinethen re calculate $updates = self::reorderSiblings($repository, $parentId, $projectId); if (! empty($updates)) { $repository->batchUpdateSort($updates); // weightline after  re getPositioninformation $preSort = $repository->getSortByFileId($preFileId); $nextSort = $repository->getNextSortAfter($parentId, $preSort, $projectId); if ($nextSort === Null) { return $preSort + self::DEFAULT_SORT_STEP; } $newGap = $nextSort - $preSort; return $preSort + intval($newGap / 2); } // IfweightlineFailed, Revert to endInsert return self::calculateLastPositionSort($repository, $parentId, $projectId); } } 