<?php declare(strict_types=1); /** * Copyright (c) Be Delightful , Distributed under the MIT software license */ namespace Delightful\BeDelightful\Command; use App\Infrastructure\Core\ValueObject\StorageBucketType; use Delightful\BeDelightful\Domain\SuperAgent\Entity\ProjectEntity; use Delightful\BeDelightful\Domain\SuperAgent\Entity\ValueObject\StorageType; use Delightful\BeDelightful\Domain\SuperAgent\Repository\Facade\ProjectRepositoryInterface; use Delightful\BeDelightful\Domain\SuperAgent\Repository\Facade\TopicRepositoryInterface; use Delightful\BeDelightful\Domain\SuperAgent\Repository\Model\TaskFileModel; use Delightful\BeDelightful\Domain\SuperAgent\Repository\Model\TaskModel; use Delightful\BeDelightful\Domain\SuperAgent\Service\TaskFileDomainService; use Hyperf\Command\Annotation\Command; use Hyperf\Command\Command as HyperfCommand; use Hyperf\Logger\LoggerFactory; use Psr\Log\LoggerInterface; use Symfony\Component\Console\Input\InputArgument; use Throwable; #[Command] class BackfillFileParentIdCommand extends HyperfCommand { protected ?string $name = 'be-delightful:backfill-file-parent-id'; protected LoggerInterface $logger; public function __construct( protected ProjectRepositoryInterface $projectRepository, protected TopicRepositoryInterface $topicRepository, protected TaskFileDomainService $taskFileDomainService, LoggerFactory $loggerFactory ) { $this->logger = $loggerFactory->get('backfill-file-parent-id'); parent::__construct(); } public function configure() { parent::configure(); $this->setDescription('Backfill parent_id for existing files in delightful_super_agent_task_files table'); $this->addArgument('project_id', InputArgument::OPTIONAL, 'Optional project ID to process only one project'); $this->addArgument('organization_code', InputArgument::OPTIONAL, 'Optional Organization code to process projects by organization'); } public function handle() { $this->line('ðŸš€ Starting backfill process for file parent_id...'); $this->logger->info('Starting backfill process for file parent_id.'); $projectId = $this->input->getArgument('project_id'); $organizationCode = $this->input->getArgument('organization_code'); // Initialize result tracking $startTime = date('Y-m-d H:i:s'); $resultLog = [ 'start_time' => $startTime, 'success_projects' => [], 'failed_projects' => [], 'skipped_projects' => [], 'total_processed_files' => 0, 'total_errors' => 0, ]; try { // Get projects based on input parameter $projects = $this->getProjectsToProcess($projectId, $organizationCode); if (empty($projects)) { $this->error('âŒ No projects found to process.'); $this->writeResultsToFile($resultLog, 'No projects found'); return; } $this->line(sprintf('ðŸ“Š Found %d project(s) to process.', count($projects))); // Process each project foreach ($projects as $project) { $projectResult = $this->processProject($project); // Record result if ($projectResult['status'] === 'success') { $resultLog['success_projects'][] = $projectResult; $resultLog['total_processed_files'] += $projectResult['processed_files']; $resultLog['total_errors'] += $projectResult['errors']; } elseif ($projectResult['status'] === 'failed') { $resultLog['failed_projects'][] = $projectResult; } else { $resultLog['skipped_projects'][] = $projectResult; } } $resultLog['end_time'] = date('Y-m-d H:i:s'); $this->writeResultsToFile($resultLog, 'Completed successfully'); $this->line('âœ… Backfill process completed successfully!'); $this->logger->info('Backfill process completed successfully.'); } catch (Throwable $e) { $resultLog['end_time'] = date('Y-m-d H:i:s'); $resultLog['error'] = $e->getMessage(); $this->writeResultsToFile($resultLog, 'Process failed'); $this->error(sprintf('âŒ Backfill process failed: %s', $e->getMessage())); $this->logger->error(sprintf('Backfill process failed: %s', $e->getMessage()), [ 'exception' => $e, 'project_id' => $projectId, 'organization_code' => $organizationCode, ]); } } /** * By/According tostoredTypeProcess/HandleFile path, ConvertoldformatPathConvert to new format * simplifyversion: directlyuseNew prefixReplaceOld prefix, thenaddeach other should Pathsegment. * * @param string $type storedType (workspace  or Other) * @param string $fileKey OriginalFile path * @param string $prefix New prefix,  like : DT001/588417216353927169 * @param string $oldPrefix Old prefix,  like : DT001/588417216353927169/2c17c6393771ee3048ae34d6b380c5ec/SUPER_DELIGHTFUL/usi_xxx * @param bool $isDirectory whetherForDirectory * @return string Convert after File path*/ public function handleFileKeyByType($type, $fileKey, $prefix, $oldPrefix, bool $isDirectory = false): string { $storageTypeValue = $type instanceof StorageType ? $type->value : $type; // CheckwhethercontainingOld prefix, If not containing then ReturnOriginal path if (strpos($fileKey, $oldPrefix . '/') !== 0) { return $fileKey; } // removeOld prefix, geteach otherPairPathPart $relativePath = substr($fileKey, strlen($oldPrefix . '/')); // First normalize relatedPairPath, removedoubleslash $relativePath = preg_replace('#/+#', '/', $relativePath); $relativePath = trim($relativePath, '/'); if ($storageTypeValue == 'workspace') { // workspace Type: add /workspace // source: DT001/588417216353927169/2c17c6393771ee3048ae34d6b380c5ec/SUPER_DELIGHTFUL/usi_xxx/project_804590875311198209/Create newFile.php //  or : DT001/588417216353927169/2c17c6393771ee3048ae34d6b380c5ec/SUPER_DELIGHTFUL/usi_xxx/topic_804590875311198209/Create newFile.php // Target: DT001/588417216353927169/project_804590875311198209/workspace/Create newFile.php // Found project_  or  topic_ startPart $pathParts = explode('/', $relativePath); for ($i = 0; $i < count($pathParts); ++$i) { if (strpos($pathParts[$i], 'project_') === 0 || strpos($pathParts[$i], 'topic_') === 0) { $entityName = $pathParts[$i]; // If is  topic_, NeedConvert to project_ format if (strpos($entityName, 'topic_') === 0) { $entityName = str_replace('topic_', 'project_', $entityName); } // Checkwhether already throughcontaining workspace if ($i + 1 < count($pathParts) && $pathParts[$i + 1] === 'workspace') { //  already through have  workspace, Reserve workspace Path after $remainingParts = array_slice($pathParts, $i + 2); $finalPath = empty($remainingParts) ? '' : implode('/', $remainingParts); return $this->normalizePath($prefix . '/' . $entityName . '/workspace/' . $finalPath, $isDirectory); } // Needadd workspace $remainingParts = array_slice($pathParts, $i + 1); $finalPath = empty($remainingParts) ? '' : implode('/', $remainingParts); return $this->normalizePath($prefix . '/' . $entityName . '/workspace/' . $finalPath, $isDirectory); } } } else { // Non workspace Type: add /runtime/message // source: DT001/588417216353927169/2c17c6393771ee3048ae34d6b380c5ec/SUPER_DELIGHTFUL/usi_xxx/project_808853145743884288/task_xxx/.chat/file.md //  or : DT001/588417216353927169/2c17c6393771ee3048ae34d6b380c5ec/SUPER_DELIGHTFUL/usi_xxx/topic_808853145743884288/task_xxx/.chat/file.md // Target: DT001/588417216353927169/project_808853145743884288/runtime/message/task_xxx/.chat/file.md // Found project_  or  topic_ startPart $pathParts = explode('/', $relativePath); for ($i = 0; $i < count($pathParts); ++$i) { if (strpos($pathParts[$i], 'project_') === 0 || strpos($pathParts[$i], 'topic_') === 0) { $entityName = $pathParts[$i]; // If is  topic_, NeedConvert to project_ format if (strpos($entityName, 'topic_') === 0) { $entityName = str_replace('topic_', 'project_', $entityName); } $remainingParts = array_slice($pathParts, $i + 1); $finalPath = empty($remainingParts) ? '' : implode('/', $remainingParts); // Process/HandleEmptyPath, avoiddoubleslash return $this->normalizePath($prefix . '/' . $entityName . '/runtime/message/' . $finalPath, $isDirectory); } } } // IfNot found project_ Part, ReturnOriginal path return $fileKey; } /** * Get projects to process based on input parameter. * * @param Null|string $projectId Optional project ID * @param Null|string $organizationCode Optional Organization code * @return ProjectEntity[] Array of project entities */ private function getProjectsToProcess(?string $projectId, ?string $organizationCode): array { // Check if project_id is provided and not empty if ($projectId !== Null && trim($projectId) !== '' && $projectId !== '-') { // Process single project $this->line(sprintf('ðŸŽ¯ Processing single project with ID: %s', $projectId)); $project = $this->projectRepository->findById((int) $projectId); if ($project === Null) { $this->error(sprintf('âŒ Project with ID %s not found.', $projectId)); return []; } return [$project]; } // Prepare conditions for project filtering $conditions = []; if ($organizationCode !== Null) { $conditions['user_organization_code'] = $organizationCode; $this->line(sprintf('ðŸ¢ Processing projects for organization: %s', $organizationCode)); } else { $this->line('ðŸŒ Processing all projects...'); } // Process projects using pagination to avoid memory issues $allProjects = []; $page = 1; $pageSize = 100; do { $result = $this->projectRepository->getProjectsByConditions( conditions: $conditions, page: $page, pageSize: $pageSize, orderBy: 'id', orderDirection: 'asc' ); if (empty($result['list'])) { break; } $projects = $result['list'] ?? []; $allProjects = array_merge($allProjects, $projects); $this->line(sprintf('ðŸ“„ Loaded page %d with %d projects', $page, count($projects))); ++$page; } while (count($projects) === $pageSize); return $allProjects; } /** * Process a single project. * * @param ProjectEntity $project ProjectEntity * @return array Process/HandleResult*/ private function processProject(ProjectEntity $project): array { $this->line(sprintf('ðŸ”„ Processing project ID: %d, Name: %s', $project->getId(), $project->getProjectName())); $this->logger->info(sprintf('Processing project ID: %d, Name: %s', $project->getId(), $project->getProjectName())); $projectResult = [ 'project_id' => $project->getId(), 'project_name' => $project->getProjectName(), 'status' => 'success', 'processed_files' => 0, 'errors' => 0, 'cache_hits' => 0, 'message' => '', 'start_time' => date('Y-m-d H:i:s'), ]; if (empty($project->getWorkDir())) { $this->warn(sprintf('âš ï¸ Project ID %d has empty work_dir, skipping...', $project->getId())); $this->logger->warning(sprintf('Project ID %d has empty work_dir, skipping', $project->getId())); $projectResult['status'] = 'skipped'; $projectResult['message'] = 'Empty work_dir'; $projectResult['end_time'] = date('Y-m-d H:i:s'); return $projectResult; } // ðŸŽ¯ thonestep: Update work_dir (mustinProcess/HandleFileBefore, Because subsequentProcess/HandleDependency new  work_dir) $updatedProject = $this->updateWorkDirectories($project); if ($updatedProject === Null) { $this->error(sprintf('âŒ Failed to update work_dir for project %d, skipping...', $project->getId())); $projectResult['status'] = 'failed'; $projectResult['message'] = 'Failed to update work_dir'; $projectResult['end_time'] = date('Y-m-d H:i:s'); return $projectResult; } $processedCount = 0; $errorCount = 0; $cacheHitCount = 0; // coreOptimize: maintainDirectoryPathand parent_id CacheMapping $directoryPathCache = []; $md5Key = md5(StorageBucketType::Private->value); $prefix = $this->taskFileDomainService->getFullPrefix($updatedProject->getUserOrganizationCode()); $oldPrefix = $prefix . $md5Key . '/SUPER_DELIGHTFUL/' . $updatedProject->getUserId(); // Process files in chunks to avoid memory issues // ðŸ”„ SupportrepeatExecute:  only Process/HandleNeedProcess/HandleFile TaskFileModel::query() ->where('project_id', $updatedProject->getId()) // ->where('is_directory', false) ->where(function ($query) use ($oldPrefix) { //  only Process/HandleNeedConvertFile: containingOld prefixFile  or  parent_id ForEmptyFile $query->where('file_key', 'like', $oldPrefix . '/%') ->orWhereNull('parent_id'); }) ->chunkById(100, function ($files) use ($updatedProject, $prefix, $oldPrefix, &$processedCount, &$errorCount, &$cacheHitCount, &$directoryPathCache) { foreach ($files as $file) { try { // By/According toTypeProcess/HandlePath, ConvertoldformatConvert to new format $storageTypeValue = $file['storage_type'] instanceof StorageType ? $file['storage_type']->value : $file['storage_type']; $isDirectory = $file['is_directory'] == 1; $newFileKey = $this->handleFileKeyByType($storageTypeValue, $file['file_key'], $prefix, $oldPrefix, $isDirectory); $this->logger->info(sprintf('Processing file ID: %d, File key: %s', $file->file_id, $newFileKey)); // IfPathhappen ed Change, Update file_key if ($newFileKey !== $file['file_key']) { $this->logger->info(sprintf('File key converted: %s -> %s', $file['file_key'], $newFileKey)); $file->file_key = $newFileKey; } $parentId = 0; // Initialize parentId if ($file['storage_type'] == StorageType::WORKSPACE && $file['is_directory'] == 0) { $parentId = $this->getFileParentIdWithCache($file, $updatedProject, $directoryPathCache, $cacheHitCount); if ($parentId > 0) { $file->parent_id = $parentId; } } $file->updated_at = date('Y-m-d H:i:s'); $file->save(); $this->logger->info(sprintf('Updated file ID: %d with parent_id: %d', $file->file_id, $parentId)); ++$processedCount; if ($processedCount % 50 === 0) { $this->line(sprintf(' ðŸ“ˆ Processed %d files... (Cache hits: %d)', $processedCount, $cacheHitCount)); } } catch (Throwable $e) { ++$errorCount; $this->warn(sprintf(' âš ï¸ Failed to process file ID: %d, Error: %s', $file->file_id, $e->getMessage())); $this->logger->error(sprintf('Failed to process file ID: %d, Error: %s', $file->file_id, $e->getMessage()), [ 'file_id' => $file->file_id, 'file_key' => $file->file_key, 'project_id' => $updatedProject->getId(), 'exception' => $e, ]); } } }); $this->line(sprintf( 'âœ… Project %d completed. Processed: %d files, Errors: %d, Cache hits: %d (%.1f%%)', $updatedProject->getId(), $processedCount, $errorCount, $cacheHitCount, $processedCount > 0 ? ($cacheHitCount / $processedCount * 100) : 0 )); $this->logger->info(sprintf( 'Project %d completed. Processed: %d files, Errors: %d, Cache hits: %d', $updatedProject->getId(), $processedCount, $errorCount, $cacheHitCount )); // Update and return result $projectResult['processed_files'] = $processedCount; $projectResult['errors'] = $errorCount; $projectResult['cache_hits'] = $cacheHitCount; $projectResult['end_time'] = date('Y-m-d H:i:s'); if ($errorCount > 0) { $projectResult['status'] = 'success_with_errors'; $projectResult['message'] = sprintf('Completed with %d errors', $errorCount); } else { $projectResult['message'] = sprintf('Successfully processed %d files', $processedCount); } return $projectResult; } /** * getFile parent_id, Use preferentiallyCache, Cache un Hit time callDomainService * * @param mixed $file FileModel * @param ProjectEntity $project ProjectEntity * @param array $directoryPathCache DirectoryPathCache [dirPath => parentId] * @param int $cacheHitCount CacheHitCount (ReferencePass) * @return int parent_id*/ private function getFileParentIdWithCache($file, ProjectEntity $project, array &$directoryPathCache, int &$cacheHitCount): int { $this->logger->info(sprintf('Processing file ID: %d, File Key: %s', $file->file_id, $file->file_key)); // ExtractFileDirectoryPath (RemoveFilename) $directoryPath = dirname($file->file_key); // normalizePath, avoid "." AndEmptyPathissue if ($directoryPath === '.' || $directoryPath === '' || $directoryPath === '/') { $directoryPath = '/'; // rootDirectoryunifieduse '/' } // CreateCacheKey: Project ID + DirectoryPath $cacheKey = $project->getId() . ':' . $directoryPath; // PriorityCheckCache if (isset($directoryPathCache[$cacheKey])) { $parentId = $directoryPathCache[$cacheKey]; ++$cacheHitCount; $this->logger->info(sprintf( 'Cache hit for directory "%s" -> parent_id: %d (file: %d)', $directoryPath, $parentId, $file->file_id )); return $parentId; } // Cache un Hit, callDomainServiceget parent_id $this->logger->info(sprintf( 'Cache miss for directory "%s", calling domain service (file: %d)', $directoryPath, $file->file_id )); $parentId = $this->taskFileDomainService->findOrCreateDirectoryAndGetParentId( projectId: $project->getId(), userId: $file->user_id, organizationCode: $file->organization_code, projectOrganizationCode: $project->getUserOrganizationCode(), fullFileKey: $file->file_key, workDir: $project->getWorkDir(), ); // ConvertResult store inputCache if ($parentId > 0) { $directoryPathCache[$cacheKey] = $parentId; $this->logger->info(sprintf( 'Cached directory "%s" -> parent_id: %d (file: %d)', $directoryPath, $parentId, $file->file_id )); } return $parentId; } /** * normalizePath, removeRedundant slash. * * @param string $path OriginalPath * @param bool $isDirectory whetherForDirectory (DirectoryNeedReserveendslash) * @return string normalize after Path*/ private function normalizePath(string $path, bool $isDirectory = false): string { // removeMultiple consecutive slashes, butReservePathstartslash $normalized = preg_replace('#/+#', '/', $path); // PairinDirectory, Reserveendslash; PairinFile, removeendslash (divideNon is rootDirectory) if (! $isDirectory && strlen($normalized) > 1) { $normalized = rtrim($normalized, '/'); } elseif ($isDirectory && ! str_ends_with($normalized, '/') && $normalized !== '/') { // EnsureDirectoryEnding with slash $normalized .= '/'; } return $normalized; } /** * Convert work_dir Pathformat (simplifyversion) * Convert /SUPER_DELIGHTFUL/usi_xxx/project_xxx/workspace Convert to /project_xxx/workspace. * * @param string $workDir Original work_dir Path * @param string $oldPrefix Old prefix,  like : SUPER_DELIGHTFUL/usi_xxx * @return string Convert after Path*/ private function convertWorkDir(string $workDir, string $oldPrefix): string { // standardizePath, Ensureby / start $workDir = '/' . ltrim($workDir, '/'); $searchPrefix = '/' . trim($oldPrefix, '/') . '/'; // CheckwhethercontainingOld prefix if (strpos($workDir, $searchPrefix) !== false) { // removeoldPrefix part $convertedPath = str_replace($searchPrefix, '/', $workDir); // ðŸ”„ Convert topic_ startPathReplaceFor project_ $convertedPath = preg_replace('#/topic_(\d+)#', '/project_$1', $convertedPath); // CheckwhetherNeedsupplement workspace if (! str_ends_with($convertedPath, '/workspace')) { $convertedPath = rtrim($convertedPath, '/') . '/workspace'; } return $convertedPath; } //  not MatchConvertMode, CheckwhetherNeedsupplement workspace if (! str_ends_with($workDir, '/workspace')) { $workDir = rtrim($workDir, '/') . '/workspace'; } return $workDir; } /** * ConvertExecuteResultWriteFile. * * @param array $resultLog ExecuteResultLog * @param string $status ExecuteStatus*/ private function writeResultsToFile(array $resultLog, string $status): void { try { $timestamp = date('Y-m-d_H-i-s'); $filename = "backfill_results_{$timestamp}.json"; $filepath = BASE_PATH . "/storage/logs/{$filename}"; // Ensure logs directory exists $logDir = dirname($filepath); if (! is_dir($logDir)) { mkdir($logDir, 0755, true); } // Prepare summary $summary = [ 'status' => $status, 'execution_time' => $resultLog['start_time'] . ' - ' . ($resultLog['end_time'] ?? 'In Progress'), 'summary' => [ 'total_projects' => count($resultLog['success_projects']) + count($resultLog['failed_projects']) + count($resultLog['skipped_projects']), 'successful_projects' => count($resultLog['success_projects']), 'failed_projects' => count($resultLog['failed_projects']), 'skipped_projects' => count($resultLog['skipped_projects']), 'total_processed_files' => $resultLog['total_processed_files'], 'total_errors' => $resultLog['total_errors'], ], 'details' => $resultLog, ]; // Write to file file_put_contents($filepath, json_encode($summary, JSON_PRETTY_PRINT | JSON_UNESCAPED_UNICODE)); $this->line(sprintf('ðŸ“ Results written to: %s', $filepath)); $this->logger->info(sprintf('Results written to file: %s', $filepath)); } catch (Throwable $e) { $this->warn(sprintf('âš ï¸ Failed to write results to file: %s', $e->getMessage())); $this->logger->warning(sprintf('Failed to write results to file: %s', $e->getMessage())); } } /** * UpdateProjectã€FileTableã€TopicTableã€TaskTable work_dir. * * @param ProjectEntity $project ProjectEntity * @return Null|ProjectEntity Update after ProjectEntity, Failed time Return Null*/ private function updateWorkDirectories(ProjectEntity $project): ?ProjectEntity { $this->line(sprintf('ðŸ”„ Updating work_dir for project %d...', $project->getId())); $this->logger->info(sprintf('Starting work_dir update for project %d', $project->getId())); try { $originalWorkDir = $project->getWorkDir(); $oldWorkDirPrefix = 'SUPER_DELIGHTFUL/' . $project->getUserId(); $convertedWorkDir = $this->convertWorkDir($originalWorkDir, $oldWorkDirPrefix); // RecordConvertResult if ($originalWorkDir !== $convertedWorkDir) { $this->line(sprintf(' ðŸ“ work_dir converted: %s -> %s', $originalWorkDir, $convertedWorkDir)); $this->logger->info(sprintf('work_dir converted: %s -> %s', $originalWorkDir, $convertedWorkDir)); // 1. UpdateProjectTable work_dir $this->projectRepository->updateProjectByCondition( ['id' => $project->getId()], ['work_dir' => $convertedWorkDir, 'updated_at' => date('Y-m-d H:i:s')] ); // 2. UpdateTopicTable work_dir $this->topicRepository->updateTopicByCondition( ['project_id' => $project->getId()], ['work_dir' => $convertedWorkDir, 'updated_at' => date('Y-m-d H:i:s')] ); // 3. UpdateTaskTable work_dir TaskModel::query() ->where('project_id', $project->getId()) ->update([ 'work_dir' => $convertedWorkDir, 'updated_at' => date('Y-m-d H:i:s'), ]); $this->line(sprintf(' âœ… Updated work_dir in project, topics, and tasks tables')); $this->logger->info(sprintf('Updated work_dir for project %d and its topics and tasks', $project->getId())); // CreateUpdate after ProjectEntity $updatedProject = clone $project; $updatedProject->setWorkDir($convertedWorkDir); return $updatedProject; } $this->line(sprintf(' âœ… work_dir already in correct format: %s', $originalWorkDir)); $this->logger->info(sprintf('work_dir already in correct format for project %d: %s', $project->getId(), $originalWorkDir)); return $project; // noneedUpdateï¼ŒReturnoriginalProject } catch (Throwable $e) { $this->warn(sprintf(' âš ï¸ Failed to update work_dir for project %d: %s', $project->getId(), $e->getMessage())); $this->logger->error(sprintf('Failed to update work_dir for project %d: %s', $project->getId(), $e->getMessage()), [ 'project_id' => $project->getId(), 'exception' => $e, ]); return Null; // UpdateFailedï¼ŒReturn Null } } } 