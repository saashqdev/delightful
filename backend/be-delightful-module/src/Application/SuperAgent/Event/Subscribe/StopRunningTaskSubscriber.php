<?php declare(strict_types=1); /** * Copyright (c) Be Delightful , Distributed under the MIT software license */ namespace Delightful\BeDelightful\Application\SuperAgent\Event\Subscribe; use App\Domain\Contact\Entity\ValueObject\DataIsolation; use App\Infrastructure\Core\Exception\BusinessException; use App\Infrastructure\Util\IdGenerator\IdGenerator; use App\Infrastructure\Util\Locker\LockerInterface; use Delightful\BeDelightful\Application\SuperAgent\Service\AgentAppService; use Delightful\BeDelightful\Domain\SuperAgent\Entity\TopicEntity; use Delightful\BeDelightful\Domain\SuperAgent\Entity\ValueObject\DeleteDataType; use Delightful\BeDelightful\Domain\SuperAgent\Entity\ValueObject\TaskStatus; use Delightful\BeDelightful\Domain\SuperAgent\Event\StopRunningTaskEvent; use Delightful\BeDelightful\Domain\SuperAgent\Repository\Facade\TaskRepositoryInterface; use Delightful\BeDelightful\Domain\SuperAgent\Repository\Model\TopicModel; use Delightful\BeDelightful\Infrastructure\ExternalAPI\SandboxOS\Exception\SandboxOperationException; use Hyperf\Amqp\Annotation\Consumer; use Hyperf\Amqp\Message\ConsumerMessage; use Hyperf\Amqp\Result; use Hyperf\Contract\StdoutLoggerInterface; use PhpAmqpLib\Message\AMQPMessage; use PhpAmqpLib\Wire\AMQPTable; use Throwable; /** * StopRun in TaskMessagesubscribe person .*/ #[Consumer( exchange: 'super_delightful_stop_task', routingKey: 'super_delightful_stop_task', queue: 'super_delightful_stop_task', nums: 1 )] class StopRunningTaskSubscriber extends ConsumerMessage { /** * @var AMQPTable|array QueueParameter, Used forsetPrioritywait*/ protected AMQPTable|array $queueArguments = []; /** * @var Null|array QoS configuration, Used forControl prefetchQuantitywait*/ protected ?array $qos = [ 'prefetch_count' => 1, // every times  only Prefetch1conditionMessage 'prefetch_size' => 0, 'global' => false, ]; /** * ConstructFunction.*/ public function __construct( private readonly TaskRepositoryInterface $taskRepository, private readonly AgentAppService $agentAppService, protected LockerInterface $locker, private readonly StdoutLoggerInterface $logger ) { // setQueuePriorityParameter $this->queueArguments['x-max-priority'] = ['I', 10]; // Set most highPriorityFor10 } /** * consumeMessage. * * @param mixed $data MessageData * @param AMQPMessage $message OriginalMessageObject * @return Result Process/HandleResult*/ public function consumeMessage($data, AMQPMessage $message): Result { try { // RecordReceivedMessageContent $this->logger->info(sprintf( 'ReceivedStopTaskMessage: %s', json_encode($data, JSON_UNESCAPED_UNICODE | JSON_UNESCAPED_SLASHES) )); // getMessageProperty/AttributeAndCheck seconds levelTimetimestamp $messageProperties = $message->get_properties(); $applicationHeaders = $messageProperties['application_headers'] ?? new AMQPTable([]); $originalTimestampFromHeader = $applicationHeaders->getNativeData()['x-original-timestamp'] ?? Null; $currentTimeForLog = time(); $actualOriginalTimestamp = Null; if ($originalTimestampFromHeader !== Null) { $actualOriginalTimestamp = (int) $originalTimestampFromHeader; $this->logger->info(sprintf( 'MessageAlready store inOriginal seconds levelTimetimestamp: %d (%s), event_id: %s', $actualOriginalTimestamp, date('Y-m-d H:i:s', $actualOriginalTimestamp), $data['event_id'] ?? 'N/A' )); } else { $actualOriginalTimestamp = $currentTimeForLog; $this->logger->warning(sprintf( 'MessageNot found x-original-timestamp headerpart，ConvertUseCurrentTimeAsthis times Process/HandleOriginalTimeTimestamp reference: %d (%s). Event ID: %s', $actualOriginalTimestamp, date('Y-m-d H:i:s', $actualOriginalTimestamp), $data['event_id'] ?? 'N/A' )); } // ValidateMessageformat $this->validateMessageFormat($data); // CreateEventObject $event = StopRunningTaskEvent::fromArray($data); // directlyProcess/HandleStopTask,  lock graindegreeinTopicGradeProcess/Handle $this->stopRunningTasks($event); return Result::ACK; } catch (BusinessException $e) { $this->logger->error(sprintf( 'Process/HandleStopTaskMessageFailed，BusinessAbnormal: %s, MessageContent: %s', $e->getMessage(), json_encode($data, JSON_UNESCAPED_UNICODE | JSON_UNESCAPED_SLASHES) )); return Result::ACK; } catch (Throwable $e) { $this->logger->error(sprintf( 'Process/HandleStopTaskMessageFailed，SystemAbnormal: %s, MessageContent: %s', $e->getMessage(), json_encode($data, JSON_UNESCAPED_UNICODE | JSON_UNESCAPED_SLASHES) )); return Result::ACK; } } public function acquireLock(string $lockKey, string $lockOwner, int $lockExpireSeconds): bool { return $this->locker->mutexLock($lockKey, $lockOwner, $lockExpireSeconds); } /** * ValidateMessageformat. * * @param mixed $data MessageData * @throws BusinessException IfMessageformatIncorrectThen throwAbnormal*/ private function validateMessageFormat($data): void { $requiredFields = [ 'event_id', 'data_type', 'data_id', 'user_id', 'organization_code', ]; foreach ($requiredFields as $field) { if (! isset($data[$field]) || (is_string($data[$field]) && empty($data[$field]))) { $this->logger->warning(sprintf( 'StopTaskMessageIncorrect format，missingmustwantField: %s, MessageContent: %s', $field, json_encode($data, JSON_UNESCAPED_UNICODE | JSON_UNESCAPED_SLASHES) )); throw new BusinessException("Invalid message format: missing field {$field}"); } } } private function releaseLock(string $lockKey, string $lockOwner): bool { return $this->locker->release($lockKey, $lockOwner); } /** * StopRun in Task. * * @param StopRunningTaskEvent $event StopTaskEvent * @throws BusinessException|SandboxOperationException*/ private function stopRunningTasks(StopRunningTaskEvent $event): void { $this->logger->info(sprintf( 'StartProcess/HandleStopTaskPleaserequire，Type: %s, ID: %d, User: %s, Organization: %s', $event->getDataType()->value, $event->getDataId(), $event->getUserId(), $event->getOrganizationCode() )); try { // By/According toDataTypeQueryRelatedRun in Task $runningTasks = $this->queryRunningTasksByDataType($event); if (empty($runningTasks)) { $this->logger->info(sprintf( 'Not foundNeedStopRun in Task，Type: %s, ID: %d', $event->getDataType()->value, $event->getDataId() )); return; } $this->logger->info(sprintf( 'Found %d  each NeedStopRun in Task，Type: %s, ID: %d', count($runningTasks), $event->getDataType()->value, $event->getDataId() )); //  by TopicIDGroupTask $tasksByTopic = []; foreach ($runningTasks as $task) { $topicId = $task->getTopicId(); if (! isset($tasksByTopic[$topicId])) { $tasksByTopic[$topicId] = []; } $tasksByTopic[$topicId][] = $task; } // CreateDataIsolationObject $dataIsolation = new DataIsolation(); $dataIsolation->setCurrentUserId($event->getUserId()); $dataIsolation->setCurrentOrganizationCode($event->getOrganizationCode()); //  by TopicProcess/HandleTask, For eachTopicadd lock  $totalSuccessCount = 0; $totalFailureCount = 0; $skippedTopicCount = 0; foreach ($tasksByTopic as $topicId => $tasks) { // ForCurrentTopicget lock  $lockKey = 'stop_running_tasks_topic_lock:' . $topicId; $lockOwner = IdGenerator::getUniqueId32(); $lockExpireSeconds = 30; // TopicGrade lock ，Set30 seconds Timeout $lockAcquired = $this->acquireLock($lockKey, $lockOwner, $lockExpireSeconds); if (! $lockAcquired) { $this->logger->info(sprintf( 'Unable toGetTopic %d StopTask lock ，SkipThisTopic %d  each TaskProcess/Handle，event_id: %s', $topicId, count($tasks), $event->getEventId() )); ++$skippedTopicCount; continue; } $this->logger->info(sprintf( 'AlreadyGetTopic %d StopTask lock ，StartProcess/Handle %d  each Task，event_id: %s', $topicId, count($tasks), $event->getEventId() )); try { $successCount = 0; $failureCount = 0; foreach ($tasks as $task) { try { $this->agentAppService->sendInterruptMessage( $dataIsolation, $task->getSandboxId(), $task->getTaskId(), $event->getReason() ); $this->logger->info(sprintf( 'SuccessSend interruptMessage，TopicID: %d, TaskID: %s, SandboxID: %s', $topicId, $task->getTaskId(), $task->getSandboxId() )); ++$successCount; } catch (SandboxOperationException $e) { $this->logger->error(sprintf( 'Send interruptMessageFailed，TopicID: %d, TaskID: %s, SandboxID: %s, Error: %s', $topicId, $task->getTaskId(), $task->getSandboxId(), $e->getMessage() )); ++$failureCount; } catch (Throwable $e) { $this->logger->error(sprintf( 'Send interruptMessage time happenUnknownError，TopicID: %d, TaskID: %s, SandboxID: %s, Error: %s', $topicId, $task->getTaskId(), $task->getSandboxId(), $e->getMessage() )); ++$failureCount; } } $totalSuccessCount += $successCount; $totalFailureCount += $failureCount; $this->logger->info(sprintf( 'Topic %d TaskProcess/HandleComplete，Success: %d, Failed: %d', $topicId, $successCount, $failureCount )); } finally { if ($this->releaseLock($lockKey, $lockOwner)) { $this->logger->debug(sprintf( 'AlreadyreleaseTopic %d StopTask lock ', $topicId )); } else { $this->logger->error(sprintf( 'releaseTopic %d StopTask lock Failed，May/PossibleNeedManual intervention', $topicId )); } } } $this->logger->info(sprintf( 'StopTaskProcess/HandleComplete，Type: %s, ID: %d, totalSuccess: %d, totalFailed: %d, SkipTopic count : %d', $event->getDataType()->value, $event->getDataId(), $totalSuccessCount, $totalFailureCount, $skippedTopicCount )); } catch (Throwable $e) { $this->logger->error(sprintf( 'StopTaskProcessing failed，Type: %s, ID: %d, Error: %s', $event->getDataType()->value, $event->getDataId(), $e->getMessage() )); throw $e; } } /** * By/According toDataTypeQueryRelatedRun in Task. * * @param StopRunningTaskEvent $event StopTaskEvent * @return array Run in Tasklist*/ private function queryRunningTasksByDataType(StopRunningTaskEvent $event): array { $runningTasks = []; switch ($event->getDataType()) { case DeleteDataType::WORKSPACE: // QueryWorkspace next AllRun in Topic (include already DeleteTopic) $topicConditions = [ 'workspace_id' => $event->getDataId(), 'current_task_status' => TaskStatus::RUNNING->value, ]; $topicsResult = $this->queryTopicsIncludeDeleted($topicConditions); $topics = $topicsResult['list'] ?? []; // Query this  some Topic next Run in Task foreach ($topics as $topic) { $tasks = $this->getRunningTasksByTopicId($topic->getId()); $runningTasks = array_merge($runningTasks, $tasks); } break; case DeleteDataType::PROJECT: // QueryProject next AllRun in Topic (include already DeleteTopic) $topicConditions = [ 'project_id' => $event->getDataId(), 'current_task_status' => TaskStatus::RUNNING->value, ]; $topicsResult = $this->queryTopicsIncludeDeleted($topicConditions); $topics = $topicsResult['list'] ?? []; // Query this  some Topic next Run in Task foreach ($topics as $topic) { $tasks = $this->getRunningTasksByTopicId($topic->getId()); $runningTasks = array_merge($runningTasks, $tasks); } break; case DeleteDataType::TOPIC: // directlyQueryTopic next Run in Task $runningTasks = $this->getRunningTasksByTopicId($event->getDataId()); break; default: $this->logger->warning(sprintf( 'UnknownDataType: %s', $event->getDataType()->value )); break; } return $runningTasks; } /** * QueryTopic, include already DeleteTopic. *  this  each methodUsed forStopTaskScenario, NeedQueryTo alreadyDeleteTopic next Run in Task. * * @param array $conditions QueryCondition * @return array Topiclist*/ private function queryTopicsIncludeDeleted(array $conditions): array { // byinstandard getTopicsByConditions willFilterDrop alreadyDeleteTopic, // We/UsNeedUse withTrashed() methodcomegetinclude already DeleteTopic /** @phpstan-ignore-next-line - TopicModel uses SoftDeletes trait which provides withTrashed() */ $query = TopicModel::query()->withTrashed(); // ApplicationConditionFilter foreach ($conditions as $field => $value) { if (is_array($value)) { $query->whereIn($field, $value); } else { $query->where($field, $value); } } // getAllTopic, include already Delete $topics = $query->get(); $this->logger->info(sprintf( 'QueryTopic（includeAlreadyDelete）：Found %d  each Topic，QueryCondition：%s', $topics->count(), json_encode($conditions, JSON_UNESCAPED_UNICODE | JSON_UNESCAPED_SLASHES) )); // Convert toEntityObject $list = []; foreach ($topics as $topic) { $list[] = new TopicEntity($topic->toArray()); } return [ 'list' => $list, 'total' => count($list), ]; } /** * By/According toTopicIDgetRun in Task. * * @param int $topicId TopicID * @return array Run in Tasklist*/ private function getRunningTasksByTopicId(int $topicId): array { $taskConditions = [ 'task_status' => [TaskStatus::RUNNING->value], ]; $tasksResult = $this->taskRepository->getTasksByTopicId($topicId, 1, 1000, $taskConditions); return $tasksResult['list'] ?? []; } } 