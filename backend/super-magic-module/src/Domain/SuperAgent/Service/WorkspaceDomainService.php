<?php declare(strict_types=1); /** * Copyright (c) Be Delightful , Distributed under the MIT software license */ namespace Delightful\SuperMagic\Domain\SuperAgent\Service; use App\Domain\Contact\Entity\ValueObject\DataIsolation; use App\ErrorCode\GenericErrorCode; use App\Infrastructure\Core\Exception\ExceptionBuilder; use App\Infrastructure\Util\Context\RequestContext; use Dtyq\SuperMagic\Domain\SuperAgent\Constant\AgentConstant; use Dtyq\SuperMagic\Domain\SuperAgent\Entity\TaskEntity; use Dtyq\SuperMagic\Domain\SuperAgent\Entity\TopicEntity; use Dtyq\SuperMagic\Domain\SuperAgent\Entity\ValueObject\TaskStatus; use Dtyq\SuperMagic\Domain\SuperAgent\Entity\ValueObject\WorkspaceArchiveStatus; use Dtyq\SuperMagic\Domain\SuperAgent\Entity\ValueObject\WorkspaceCreationParams; use Dtyq\SuperMagic\Domain\SuperAgent\Entity\ValueObject\WorkspaceStatus; use Dtyq\SuperMagic\Domain\SuperAgent\Entity\WorkspaceEntity; use Dtyq\SuperMagic\Domain\SuperAgent\Entity\WorkspaceVersionEntity; use Dtyq\SuperMagic\Domain\SuperAgent\Repository\Facade\TaskFileRepositoryInterface; use Dtyq\SuperMagic\Domain\SuperAgent\Repository\Facade\TaskRepositoryInterface; use Dtyq\SuperMagic\Domain\SuperAgent\Repository\Facade\TopicRepositoryInterface; use Dtyq\SuperMagic\Domain\SuperAgent\Repository\Facade\WorkspaceRepositoryInterface; use Dtyq\SuperMagic\Domain\SuperAgent\Repository\Facade\WorkspaceVersionRepositoryInterface; use Dtyq\SuperMagic\ErrorCode\SuperAgentErrorCode; use Dtyq\SuperMagic\Infrastructure\ExternalAPI\SandboxOS\Gateway\SandboxGatewayInterface; use Dtyq\SuperMagic\Infrastructure\Utils\WorkDirectoryUtil; use Exception; use Psr\Log\LoggerInterface; use RuntimeException; use Throwable; class WorkspaceDomainService { public function __construct( protected WorkspaceRepositoryInterface $workspaceRepository, protected TopicRepositoryInterface $topicRepository, protected TaskFileRepositoryInterface $taskFileRepository, protected TaskRepositoryInterface $taskRepository, protected TaskDomainService $taskDomainService, protected WorkspaceVersionRepositoryInterface $workspaceVersionRepository, protected SandboxGatewayInterface $gateway, protected LoggerInterface $logger, ) { } /** * Create workspace only (without topic creation). * * @param DataIsolation $dataIsolation Data isolation object * @param string $chatConversationId Chat conversation ID * @param string $workspaceName Workspace name * @return WorkspaceEntity Created workspace entity */ public function createWorkspace(DataIsolation $dataIsolation, string $chatConversationId, string $workspaceName): WorkspaceEntity { // Get current user info from DataIsolation $currentUserId = $dataIsolation->getCurrentUserId(); $organizationCode = $dataIsolation->getCurrentOrganizationCode(); // Create workspace entity $currentTime = date('Y-m-d H:i:s'); $workspaceEntity = new WorkspaceEntity(); $workspaceEntity->setUserId($currentUserId); $workspaceEntity->setUserOrganizationCode($organizationCode); $workspaceEntity->setChatConversationId($chatConversationId); $workspaceEntity->setName($workspaceName); $workspaceEntity->setArchiveStatus(WorkspaceArchiveStatus::NotArchived); $workspaceEntity->setWorkspaceStatus(WorkspaceStatus::Normal); $workspaceEntity->setCreatedUid($currentUserId); $workspaceEntity->setUpdatedUid($currentUserId); $workspaceEntity->setCreatedAt($currentTime); $workspaceEntity->setUpdatedAt($currentTime); // Save workspace using repository return $this->workspaceRepository->createWorkspace($workspaceEntity); } /** * CreateWorkspace. defaultwillInitializeATopic (DEPRECATED - use createWorkspace + TopicDomainService::createTopic) * followDDDstyle format , DomainServiceResponsibleProcess/Handlebusiness logic. * @return array containingWorkspaceEntityAndTopicEntityArray ['workspace' => WorkspaceEntity, 'topic' => TopicEntity|Null] * @deprecated Use createWorkspace() and TopicDomainService::createTopic() separately*/ public function createWorkspaceWithTopic(DataIsolation $dataIsolation, WorkspaceCreationParams $creationParams): array { // fromDataIsolationgetCurrent user IDAsCreatorID $currentUserId = $dataIsolation->getCurrentUserId(); $organizationCode = $dataIsolation->getCurrentOrganizationCode(); // CreateWorkspaceEntity $currentTime = date('Y-m-d H:i:s'); $workspaceEntity = new WorkspaceEntity(); $workspaceEntity->setUserId($currentUserId); // UseCurrentUserID $workspaceEntity->setUserOrganizationCode($dataIsolation->getCurrentOrganizationCode()); $workspaceEntity->setChatConversationId($creationParams->getChatConversationId()); $workspaceEntity->setName($creationParams->getWorkspaceName()); $workspaceEntity->setArchiveStatus(WorkspaceArchiveStatus::NotArchived); // Default un Archive $workspaceEntity->setWorkspaceStatus(WorkspaceStatus::Normal); // DefaultStatus：Normal $workspaceEntity->setCreatedUid($currentUserId); // fromDataIsolationGet $workspaceEntity->setUpdatedUid($currentUserId); // Create time Update person andCreatorSame $workspaceEntity->setCreatedAt($currentTime); $workspaceEntity->setUpdatedAt($currentTime); // UseTransaction guarantees workspace andTopicMeanwhileCreated successfully $topicEntity = Null; // callRepository layerSaveWorkspace $savedWorkspaceEntity = $this->workspaceRepository->createWorkspace($workspaceEntity); // CreateTopic if ($savedWorkspaceEntity->getId() && ! empty($creationParams->getChatConversationTopicId())) { // CreateTopicEntity $topicEntity = new TopicEntity(); $topicEntity->setUserId($currentUserId); $topicEntity->setUserOrganizationCode($organizationCode); $topicEntity->setWorkspaceId($savedWorkspaceEntity->getId()); $topicEntity->setChatTopicId($creationParams->getChatConversationTopicId()); $topicEntity->setChatConversationId($creationParams->getChatConversationId()); $topicEntity->setSandboxId(''); // InitiallyEmpty $topicEntity->setWorkDir(''); // InitiallyEmpty $topicEntity->setCurrentTaskId(0); $topicEntity->setTopicName($creationParams->getTopicName()); $topicEntity->setCurrentTaskStatus(TaskStatus::WAITING); // DefaultStatus：Wait in  $topicEntity->setCreatedUid($currentUserId); // SetCreatorUserID $topicEntity->setUpdatedUid($currentUserId); // SetUpdate person UserID // Use topicRepository SaveTopic $savedTopicEntity = $this->topicRepository->createTopic($topicEntity); if ($savedTopicEntity->getId()) { // setWorkspaceCurrentTopicIDFor newCreateTopicID $savedWorkspaceEntity->setCurrentTopicId($savedTopicEntity->getId()); // UpdateWorkspace $this->workspaceRepository->save($savedWorkspaceEntity); // UpdateworkDirectory $topicEntity->setWorkDir($this->generateWorkDir($currentUserId, $savedTopicEntity->getId())); $this->topicRepository->updateTopic($topicEntity); } $topicEntity = $savedTopicEntity; } $result = $savedWorkspaceEntity; return [ 'workspace' => $result, 'topic' => $topicEntity, ]; } /** * UpdateWorkspace. * followDDDstyle format , DomainServiceResponsibleProcess/Handlebusiness logic. * @param DataIsolation $dataIsolation DataIsolationObject * @param int $workspaceId Workspace ID * @param string $workspaceName WorkspaceName * @return bool whetherUpdated successfully*/ public function updateWorkspace(DataIsolation $dataIsolation, int $workspaceId, string $workspaceName = ''): bool { // getWorkspaceEntity $workspaceEntity = $this->workspaceRepository->getWorkspaceById($workspaceId); if (! $workspaceEntity) { throw new RuntimeException('Workspace not found'); } if ($workspaceEntity->getUserId() !== $dataIsolation->getCurrentUserId()) { throw new RuntimeException('You are not allowed to update this workspace'); } // If have Passed inWorkspaceName,  then UpdateName if (! empty($workspaceName)) { $workspaceEntity->setName($workspaceName); $workspaceEntity->setUpdatedAt(date('Y-m-d H:i:s')); $workspaceEntity->setUpdatedUid($dataIsolation->getCurrentUserId()); // SetUpdate person UserID } // UseGeneral save methodSave $this->workspaceRepository->save($workspaceEntity); return true; } /** * getWorkspaceDetails.*/ public function getWorkspaceDetail(int $workspaceId): ?WorkspaceEntity { return $this->workspaceRepository->getWorkspaceById($workspaceId); } /** * Archive/solvedivideArchiveWorkspace.*/ public function archiveWorkspace(RequestContext $requestContext, int $workspaceId, bool $isArchived): bool { $archiveStatus = $isArchived ? WorkspaceArchiveStatus::Archived : WorkspaceArchiveStatus::NotArchived; return $this->workspaceRepository->updateWorkspaceArchivedStatus($workspaceId, $archiveStatus->value); } /** * DeleteWorkspace (LogicDelete). * * @param DataIsolation $dataIsolation DataIsolationObject * @param int $workspaceId Workspace ID * @return bool whetherDeleted successfully * @throws RuntimeException IfWorkspaceDoes not existinThen throwAbnormal*/ public function deleteWorkspace(DataIsolation $dataIsolation, int $workspaceId): bool { // getWorkspaceEntity $workspaceEntity = $this->workspaceRepository->getWorkspaceById($workspaceId); if (! $workspaceEntity) { // UseExceptionBuilderThrow"Not found"TypeError ExceptionBuilder::throw(SuperAgentErrorCode::WORKSPACE_NOT_FOUND, 'workspace.workspace_not_found'); } // IfNot own workspace, CannotDelete if ($workspaceEntity->getUserId() !== $dataIsolation->getCurrentUserId()) { ExceptionBuilder::throw(SuperAgentErrorCode::WORKSPACE_ACCESS_DENIED, 'workspace.access_denied'); } // setDeleted at $workspaceEntity->setDeletedAt(date('Y-m-d H:i:s')); $workspaceEntity->setUpdatedUid($dataIsolation->getCurrentUserId()); $workspaceEntity->setUpdatedAt(date('Y-m-d H:i:s')); // SaveUpdate $this->workspaceRepository->save($workspaceEntity); return true; } /** * setCurrentTopic.*/ public function setCurrentTopic(RequestContext $requestContext, int $workspaceId, string $topicId): bool { return $this->workspaceRepository->updateWorkspaceCurrentTopic($workspaceId, $topicId); } /** * By/According toConditiongetWorkspacelist.*/ public function getWorkspacesByConditions( array $conditions, int $page, int $pageSize, string $orderBy, string $orderDirection, DataIsolation $dataIsolation ): array { // ApplicationDataIsolation $conditions = $this->applyDataIsolation($conditions, $dataIsolation); // callRepository layergetData return $this->workspaceRepository->getWorkspacesByConditions( $conditions, $page, $pageSize, $orderBy, $orderDirection ); } /** * getWorkspace next Topiclist. * @param array $workspaceIds Workspace IDArray * @param DataIsolation $dataIsolation DataIsolationObject * @param bool $needPagination whetherNeedPagination * @param int $pageSize Per pageQuantity * @param int $page Page number * @param string $orderBy Sort field * @param string $orderDirection Sort direction * @return array Topiclist*/ public function getWorkspaceTopics( array $workspaceIds, DataIsolation $dataIsolation, bool $needPagination = true, int $pageSize = 20, int $page = 1, string $orderBy = 'id', string $orderDirection = 'desc' ): array { $conditions = [ 'workspace_id' => $workspaceIds, 'user_id' => $dataIsolation->getCurrentUserId(), ]; return $this->topicRepository->getTopicsByConditions( $conditions, $needPagination, $pageSize, $page, $orderBy, $orderDirection ); } /** * getTaskAttachmentlist. * * @param int $taskId TaskID * @param DataIsolation $dataIsolation DataIsolationObject * @param int $page Page number * @param int $pageSize Per pageQuantity * @return array AttachmentlistAndTotal*/ public function getTaskAttachments(int $taskId, DataIsolation $dataIsolation, int $page = 1, int $pageSize = 20): array { // callTaskFileRepositorygetFilelist return $this->taskFileRepository->getByTaskId($taskId, $page, $pageSize); // directlyReturnEntityObjectlist,  let ApplicationLayer processingURLget } /** * CreateTopic. * * @param DataIsolation $dataIsolation DataIsolationObject * @param int $workspaceId Workspace ID * @param string $chatTopicId SessionTopicID, storedintopic_idfield in  * @param string $topicName TopicName * @return TopicEntity CreateTopicEntity * @throws Exception IfCreateFailed*/ public function createTopic(DataIsolation $dataIsolation, int $workspaceId, string $chatTopicId, string $topicName): TopicEntity { // getCurrent user ID $userId = $dataIsolation->getCurrentUserId(); $organizationCode = $dataIsolation->getCurrentOrganizationCode(); // getWorkspaceDetails, CheckWorkspacewhether store in $workspaceEntity = $this->workspaceRepository->getWorkspaceById($workspaceId); if (! $workspaceEntity) { ExceptionBuilder::throw(GenericErrorCode::IllegalOperation, 'workspace.not_found'); } // CheckWorkspacewhether already Archive if ($workspaceEntity->getArchiveStatus() === WorkspaceArchiveStatus::Archived) { ExceptionBuilder::throw(GenericErrorCode::IllegalOperation, 'workspace.archived'); } // getSessionID $chatConversationId = $workspaceEntity->getChatConversationId(); if (empty($chatConversationId)) { ExceptionBuilder::throw(GenericErrorCode::SystemError, 'workspace.conversation_id_not_found'); } // IfTopicIDForEmpty, ThrowAbnormal if (empty($chatTopicId)) { ExceptionBuilder::throw(GenericErrorCode::ParameterMissing, 'topic.id_required'); } // CreateTopicEntity $topicEntity = new TopicEntity(); $topicEntity->setUserId($userId); $topicEntity->setUserOrganizationCode($organizationCode); $topicEntity->setWorkspaceId($workspaceId); $topicEntity->setChatTopicId($chatTopicId); $topicEntity->setChatConversationId($chatConversationId); $topicEntity->setTopicName($topicName); $topicEntity->setSandboxId(''); // InitiallyEmpty $topicEntity->setWorkDir(''); // InitiallyEmpty $topicEntity->setCurrentTaskId(0); $topicEntity->setCurrentTaskStatus(TaskStatus::WAITING); // DefaultStatus：Wait in  $topicEntity->setCreatedUid($userId); // SetCreatorUserID $topicEntity->setUpdatedUid($userId); // SetUpdate person UserID // SaveTopic $topicEntity = $this->topicRepository->createTopic($topicEntity); // UpdateWorkspace if ($topicEntity->getId()) { $topicEntity->setWorkDir($this->generateWorkDir($userId, $topicEntity->getId())); $this->topicRepository->updateTopic($topicEntity); } return $topicEntity; } /** * throughIDgetTopicEntity. * * @param int $id TopicID(Primary key) * @return Null|TopicEntity TopicEntity*/ public function getTopicById(int $id): ?TopicEntity { return $this->topicRepository->getTopicById($id); } /** * BatchgetTopic. * @return TopicEntity[]*/ public function getTopicsByIds(array $topicIds): array { if (empty($topicIds)) { return []; } return $this->topicRepository->getTopicsByIds($topicIds); } /** * Update topic project association. * * @param int $topicId Topic ID * @param int $projectId Project ID * @return bool Whether the update was successful * @throws Exception If the update fails */ public function updateTopicProject(int $topicId, int $projectId): bool { // Get topic entity by ID $topicEntity = $this->topicRepository->getTopicById($topicId); if (! $topicEntity) { ExceptionBuilder::throw(GenericErrorCode::IllegalOperation, 'topic.not_found'); } // Update project association $topicEntity->setProjectId($projectId); // Save update return $this->topicRepository->updateTopic($topicEntity); } public function getTopicBySandboxId(string $sandboxId): ?TopicEntity { $topics = $this->topicRepository->getTopicsByConditions(['sandbox_id' => $sandboxId], true, 1, 1); if (! isset($topics['list']) || empty($topics['list'])) { return Null; } return $topics['list'][0]; } /** * SaveWorkspaceEntity * directlySaveWorkspaceEntity, No need to repeatQuery. * @param WorkspaceEntity $workspaceEntity WorkspaceEntity * @return WorkspaceEntity Save after WorkspaceEntity*/ public function saveWorkspaceEntity(WorkspaceEntity $workspaceEntity): WorkspaceEntity { return $this->workspaceRepository->save($workspaceEntity); } /** * getWorkspaceTopiclist. * * @param array|int $workspaceIds Workspace ID or IDArray * @param string $userId User ID * @return array Topiclist, byWorkspace IDForKey*/ public function getWorkspaceTopicsByWorkspaceIds(array|int $workspaceIds, string $userId): array { if (! is_array($workspaceIds)) { $workspaceIds = [$workspaceIds]; } // IfNo/NoneWorkspace ID, directlyReturnEmptyArray if (empty($workspaceIds)) { return []; } // defineQueryCondition $conditions = [ 'workspace_id' => $workspaceIds, 'user_id' => $userId, ]; // getAllmatchConditionTopic $result = $this->topicRepository->getTopicsByConditions( $conditions, false, //  not Pagination，GetAll 100, 1, 'id', 'asc' ); //  re  by Workspace ID Group $topics = []; foreach ($result['list'] as $topic) { $workspaceId = $topic->getWorkspaceId(); if (! isset($topics[$workspaceId])) { $topics[$workspaceId] = []; } $topics[$workspaceId][] = $topic; } return $topics; } public function getUserTopics(string $userId): array { // considerwhetherNeedOrganization code $topics = $this->topicRepository->getTopicsByConditions( ['user_id' => $userId], false, //  not Pagination，GetAll 100, 1, 'id', 'asc' ); if (empty($topics['list'])) { return []; } return $topics['list']; } public function getTopicList(int $page, int $pageSize): array { // considerwhetherNeedOrganization code //  not Pagination, getAll $topics = $this->topicRepository->getTopicsByConditions([], true, $pageSize, $page); if (empty($topics['list'])) { return []; } return $topics['list']; } /** * By/According toTaskStatusgetWorkspaceTopiclist. * * @param array|int $workspaceIds Workspace ID or IDArray * @param string $userId User ID * @param Null|TaskStatus $taskStatus TaskStatus, IfForNull then ReturnAllStatus * @return array Topiclist, byWorkspace IDForKey*/ public function getWorkspaceTopicsByTaskStatus(array|int $workspaceIds, string $userId, ?TaskStatus $taskStatus = Null): array { // getAllTopic $allTopics = $this->getWorkspaceTopicsByWorkspaceIds($workspaceIds, $userId); // IfNo need to filterTaskStatus, directlyReturnAllTopic if ($taskStatus === Null) { return $allTopics; } // By/According toTaskStatusFilterTopic $filteredTopics = []; foreach ($allTopics as $workspaceId => $topics) { $filteredTopicList = []; foreach ($topics as $topic) { // IfTopicCurrentTaskStatusandspecifiedStatusMatch, OrTopicNo/NoneTaskStatusandspecified is WaitStatus if (($topic->getCurrentTaskStatus() === $taskStatus) || ($topic->getCurrentTaskStatus() === Null && $taskStatus === TaskStatus::WAITING)) { $filteredTopicList[] = $topic; } } if (! empty($filteredTopicList)) { $filteredTopics[$workspaceId] = $filteredTopicList; } } return $filteredTopics; } /** * DeleteTopic (LogicDelete). * * @param DataIsolation $dataIsolation DataIsolationObject * @param int $id TopicID(Primary key) * @return bool whetherDeleted successfully * @throws Exception IfDeleteFailed or TaskStatusForRun in */ public function deleteTopic(DataIsolation $dataIsolation, int $id): bool { // getCurrent user ID $userId = $dataIsolation->getCurrentUserId(); // throughPrimary keyIDgetTopic $topicEntity = $this->topicRepository->getTopicById($id); if (! $topicEntity) { ExceptionBuilder::throw(GenericErrorCode::IllegalOperation, 'topic.not_found'); } // CheckuserPermission (CheckTopicwhetherattributeinCurrentuser) if ($topicEntity->getUserId() !== $userId) { ExceptionBuilder::throw(GenericErrorCode::AccessDenied, 'topic.access_denied'); } // CheckTaskStatus, If is RunThen not allowed inDelete if ($topicEntity->getCurrentTaskStatus() === TaskStatus::RUNNING) { // to agent SendStopCommand $taskEntity = $this->taskRepository->getTaskById($topicEntity->getCurrentTaskId()); if (! empty($taskEntity)) { $this->taskDomainService->handleInterruptInstruction($dataIsolation, $taskEntity); } } // getWorkspaceDetails, CheckWorkspacewhether store in $workspaceEntity = $this->workspaceRepository->getWorkspaceById($topicEntity->getWorkspaceId()); if (! $workspaceEntity) { ExceptionBuilder::throw(GenericErrorCode::IllegalOperation, 'workspace.not_found'); } // CheckWorkspacewhether already Archive if ($workspaceEntity->getArchiveStatus() === WorkspaceArchiveStatus::Archived) { ExceptionBuilder::throw(GenericErrorCode::IllegalOperation, 'workspace.archived'); } // DeletethisTopic next AllTask (callRepository layerBatchDeletemethod) $this->taskRepository->deleteTasksByTopicId($id); // setDeleted at $topicEntity->setDeletedAt(date('Y-m-d H:i:s')); // setUpdate person User ID $topicEntity->setUpdatedUid($userId); // SaveUpdate return $this->topicRepository->updateTopic($topicEntity); } /** * getTaskDetails. * * @param int $taskId TaskID * @return Null|TaskEntity TaskEntity*/ public function getTaskById(int $taskId): ?TaskEntity { return $this->taskRepository->getTaskById($taskId); } /** * getTopicassociatedTasklist. * * @param int $topicId TopicID * @param int $page Page number * @param int $pageSize Per pageQuantity * @param Null|DataIsolation $dataIsolation DataIsolationObject * @return array{list: TaskEntity[], total: int} TasklistAndTotal*/ public function getTasksByTopicId(int $topicId, int $page = 1, int $pageSize = 10, ?DataIsolation $dataIsolation = Null): array { return $this->taskRepository->getTasksByTopicId($topicId, $page, $pageSize); } /** * throughTopicIDCollectiongetWorkspaceinformation. * * @param array $topicIds TopicIDCollection * @return array byTopicIDForKey, WorkspaceinformationForValueassociatedArray*/ public function getWorkspaceInfoByTopicIds(array $topicIds): array { if (empty($topicIds)) { return []; } return $this->topicRepository->getWorkspaceInfoByTopicIds($topicIds); } public function updateTopicSandboxConfig(DataIsolation $dataIsolation, int $topicId, array $sandboxConfig): bool { $topicEntity = $this->topicRepository->getTopicById($topicId); if (! $topicEntity) { ExceptionBuilder::throw(GenericErrorCode::IllegalOperation, 'topic.not_found'); } $topicEntity->setSandboxConfig(json_encode($sandboxConfig)); return $this->topicRepository->updateTopic($topicEntity); } /** * getAllWorkspaceUniqueOrganization codelist. * * @return array UniqueOrganization codelist*/ public function getUniqueOrganizationCodes(): array { return $this->workspaceRepository->getUniqueOrganizationCodes(); } /** * Create a new workspace version record. */ public function createWorkspaceVersion(WorkspaceVersionEntity $versionEntity): void { $this->workspaceVersionRepository->create($versionEntity); } /** * Get workspace version by commit hash, topic ID and folder. * * @param string $commitHash The commit hash * @param int $projectId The project ID * @param string $folder The folder path * @return Null|WorkspaceVersionEntity The workspace version entity or Null if not found */ public function getWorkspaceVersionByCommitAndProjectId(string $commitHash, int $projectId, string $folder = ''): ?WorkspaceVersionEntity { // Get all versions for the topic return $this->workspaceVersionRepository->findByCommitHashAndProjectId($commitHash, $projectId, $folder); } /** * Get workspace version by commit hash, topic ID and folder. * * @param int $projectId The project ID * @param string $folder The folder path * @return Null|WorkspaceVersionEntity The workspace version entity or Null if not found */ public function getWorkspaceVersionByProjectId(int $projectId, string $folder = ''): ?WorkspaceVersionEntity { // Get all versions for the topic return $this->workspaceVersionRepository->findByProjectId($projectId, $folder); } public function getLatestVersionByProjectId(int $projectId): ?WorkspaceVersionEntity { return $this->workspaceVersionRepository->getLatestVersionByProjectId($projectId); } /** * By/According tocommit_hash Andproject_id gettag number .*/ public function getTagByCommitHashAndProjectId(string $commitHash, int $projectId): int { return $this->workspaceVersionRepository->getTagByCommitHashAndProjectId($commitHash, $projectId); } /** * BatchgetWorkspaceNameMapping. * * @param array $workspaceIds Workspace IDArray * @return array ['workspace_id' => 'workspace_name'] KeyValuePair*/ public function getWorkspaceNamesBatch(array $workspaceIds): array { if (empty($workspaceIds)) { return []; } return $this->workspaceRepository->getWorkspaceNamesBatch($workspaceIds); } /** * throughcommit hash AndTopicid getVersion after , By/According todir Filelist, Filterresult.*/ public function filterResultByGitVersion(array $result, int $projectId, string $organizationCode, string $workDir = ''): array { $dir = '.workspace'; $workspaceVersion = $this->getWorkspaceVersionByProjectId($projectId, $dir); if (empty($workspaceVersion)) { return $result; } if (empty($workspaceVersion->getDir())) { return $result; } # Traverseresult's updatedAt ，IfupdatedAt smallinworkspaceVersion 's updated_at ，Then keepinA temporaryArray $fileResult = []; foreach ($result['list'] as $item) { if ($item['updated_at'] >= $workspaceVersion->getUpdatedAt()) { $fileResult[] = $item; } } $dir = json_decode($workspaceVersion->getDir(), true); # dir Is aTwo-dimensionalArray，Traverse$dir, JudgeWhetherIs aFile，IfNo/NoneFileSuffixDescriptionIs aDirectory，FilterdropDirectory # dir =["generated_images","generated_images\/cute-cartoon-cat.jpg","generated_images\/handdrawn-cute-cat.jpg","generated_images\/abstract-modern-generic.jpg","generated_images\/minimalist-cat-icon.jpg","generated_images\/realistic-elegant-cat.jpg","generated_images\/oilpainting-elegant-cat.jpg","generated_images\/anime-cute-cat.jpg","generated_images\/cute-cartoon-dog.jpg","generated_images\/universal-minimal-logo-3.jpg","generated_images\/universal-minimal-logo.jpg","generated_images\/universal-minimal-logo-2.jpg","generated_images\/realistic-cat-photo.jpg","generated_images\/minimal-tech-logo.jpg","logs","logs\/agentlang.log"] $dir = array_filter($dir, function ($item) { if (strpos($item, '.') === false) { return false; } return true; }); $gitVersionResult = []; foreach ($result['list'] as $item) { foreach ($dir as $dirItem) { $fileKey = WorkDirectoryUtil::getRelativeFilePath($item['file_key'], $workDir); // unifiedPathDelimiter, ConvertAllPathDelimiterstandardConvert toSystemdefaultDelimiter $fileKey = str_replace(['/', '\\'], DIRECTORY_SEPARATOR, $fileKey); $dirItem = str_replace(['/', '\\'], DIRECTORY_SEPARATOR, $dirItem); $dirItem = '/' . $dirItem; // AdjustFor completeMatch if ($dirItem == $fileKey) { $gitVersionResult[] = $item; } } } $newResult = array_merge($fileResult, $gitVersionResult); # PairtempResult enter RowDistinct $result['list'] = array_unique($newResult, SORT_REGULAR); $result['total'] = count($result['list']); return $result; } public function diffFileListAndVersionFile(array $result, int $projectId, string $taskId, string $sandboxId, string $organizationCode = ''): bool { $dir = '.workspace'; $workspaceVersion = $this->getWorkspaceVersionByProjectId($projectId, $dir); if (empty($workspaceVersion)) { return false; } if (empty($workspaceVersion->getDir())) { return false; } $dir = json_decode($workspaceVersion->getDir(), true); # dir Is aTwo-dimensionalArray，Traverse$dir, JudgeWhetherIs aFile，IfNo/NoneFileSuffixDescriptionIs aDirectory，FilterdropDirectory # dir =["generated_images","generated_images\/cute-cartoon-cat.jpg","generated_images\/handdrawn-cute-cat.jpg","generated_images\/abstract-modern-generic.jpg","generated_images\/minimalist-cat-icon.jpg","generated_images\/realistic-elegant-cat.jpg","generated_images\/oilpainting-elegant-cat.jpg","generated_images\/anime-cute-cat.jpg","generated_images\/cute-cartoon-dog.jpg","generated_images\/universal-minimal-logo-3.jpg","generated_images\/universal-minimal-logo.jpg","generated_images\/universal-minimal-logo-2.jpg","generated_images\/realistic-cat-photo.jpg","generated_images\/minimal-tech-logo.jpg","logs","logs\/agentlang.log"] $dir = array_filter($dir, function ($item) { if (strpos($item, '.') === false) { return false; } return true; }); # Traverse$result ，If$result 's file_key in$dir  in ， dir in Save's  is file_key Part of，NeedUseStringMatch，If store inThen keepinA temporaryArray $gitVersionNotExistResult = []; $fileKeys = []; foreach ($result['list'] as $item) { # Find the project_id pattern in the file_key and extract everything after it $projectPattern = 'project_' . $projectId; $pos = strpos($item['file_key'], $projectPattern); if ($pos !== false) { # Get the position after the project_id and the following slash $startPos = $pos + strlen($projectPattern) + 1; // +1 for the slash $fileKeys[] = substr($item['file_key'], $startPos); } else { # Fallback: if project_id pattern not found, keep original logic $fileKeys[] = substr($item['file_key'], strlen((string) $projectId) + 1); } } foreach ($dir as $dirItem) { if (! in_array($dirItem, $fileKeys)) { $gitVersionNotExistResult[] = $dirItem; } } if (empty($gitVersionNotExistResult)) { return false; } # PairgitVersionNotExistResult  enter RowDistinct $gitVersionNotExistResult = array_unique($gitVersionNotExistResult); #  re Sort $gitVersionNotExistResult = array_values($gitVersionNotExistResult); # gitVersionNotExistResult Not beEmpty，Description have FileUpdate，butNo/NoneTriggersuer-magic's FileUpload，Needagaincallsuer-magic's  api  enter RowOnceFileUpload if (! empty($gitVersionNotExistResult)) { try { # ViewSandboxWhether store alive $sandboxStatus = $this->gateway->getSandboxStatus($sandboxId); if ($sandboxStatus->isRunning()) { $gatewayResult = $this->gateway->uploadFile($sandboxId, $gitVersionNotExistResult, (string) $projectId, $organizationCode, $taskId); if ($gatewayResult->isSuccess()) { return true; } } else { return false; } } catch (Throwable $e) { $this->logger->error('[Sandbox][Domain] uploadFile failed', ['error' => $e->getMessage()]); } } return false; } /** * ApplicationDataIsolation to QueryCondition.*/ private function applyDataIsolation(array $conditions, DataIsolation $dataIsolation): array { // userid And Organization code $conditions['user_id'] = $dataIsolation->getCurrentUserId(); $conditions['user_organization_code'] = $dataIsolation->getCurrentOrganizationCode(); return $conditions; } /** * GenerateworkDirectory.*/ private function generateWorkDir(string $userId, int $topicId): string { return sprintf('/%s/%s/topic_%d', AgentConstant::SUPER_MAGIC_CODE, $userId, $topicId); } } 