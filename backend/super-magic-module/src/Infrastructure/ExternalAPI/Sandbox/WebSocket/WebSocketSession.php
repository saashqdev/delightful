<?php declare(strict_types=1); /** * Copyright (c) Be Delightful , Distributed under the MIT software license */ namespace Dtyq\SuperMagic\Infrastructure\ExternalAPI\Sandbox\WebSocket; use Dtyq\SuperMagic\Infrastructure\ExternalAPI\Sandbox\Config\WebSocketConfig; use Dtyq\SuperMagic\Infrastructure\ExternalAPI\Sandbox\WebSocket\Exception\WebSocketConnectionException; use Dtyq\SuperMagic\Infrastructure\ExternalAPI\Sandbox\WebSocket\Exception\WebSocketTimeoutException; use Psr\Log\LoggerInterface; use Throwable; class WebSocketSession { private WebSocketClient $client; private int $lastMessageTime; public function __construct( private readonly WebSocketConfig $config, private readonly LoggerInterface $logger, private readonly string $wsUrl, private readonly string $taskId, private readonly ?string $token = Null ) { $this->client = new WebSocketClient($config, $logger, $wsUrl, $taskId, $token); $this->lastMessageTime = time(); } /** * establishWebSocketConnect. * * @throws WebSocketConnectionException ConnectFailedThrow when*/ public function connect(): void { try { $this->client->connect(); $this->logger->info(sprintf( 'WebSocketConnectSuccess，TaskID: %s，URL: %s', $this->taskId, $this->wsUrl )); } catch (Throwable $e) { $this->logger->error(sprintf( 'WebSocketConnection failed: %s，TaskID: %s', $e->getMessage(), $this->taskId )); throw $e; } } /** * DisconnectWebSocketConnect.*/ public function disconnect(): void { try { $this->client->disconnect(); $this->logger->info(sprintf( 'WebSocketDisconnectConnect，TaskID: %s', $this->taskId )); } catch (Throwable $e) { $this->logger->warning(sprintf( 'WebSocketDisconnectConnection failed，TaskID: %s，Error: %s', $this->taskId, $e->getMessage() )); } } /** * SendWebSocketMessage. * * @param array $data wantSendMessageData * @throws WebSocketConnectionException SendFailedThrow when*/ public function send(array $data): void { try { $this->client->send($data); $this->lastMessageTime = time(); } catch (Throwable $e) { $this->logger->error(sprintf( 'SendMessageFailed: %s，TaskID: %s', $e->getMessage(), $this->taskId )); throw $e; } } /** * ReceiveWebSocketMessage, SupportTimeoutAndAutoReconnect. * * @param int $timeout ReceiveTimeoutTime ( seconds ), 0TableshowUseconfigurationdefaultValue * @param int $maxRetries MaximumRetry times  count  (0TableshowUseconfigurationdefaultValue) * @return Null|array ReceivedOriginalMessage or Null * @throws WebSocketConnectionException ConnectErrorandRetryFailedThrow when * @throws WebSocketTimeoutException OperationTimeoutThrow when*/ public function receive( int $timeout = 0, int $maxRetries = 0 ): ?array { // confirmActualUseTimeoutTime $actualTimeout = $timeout > 0 ? $timeout : $this->config->getReadTimeout(); $startTime = time(); $endTime = $startTime + $actualTimeout; // confirmRetryParameter $retryCount = 0; $maxRetries = $maxRetries > 0 ? $maxRetries : $this->config->getMaxRetries(); $baseDelay = $this->config->getRetryDelay(); // Main loop: tryReceiveMessagedirect to Timeout while (time() < $endTime) { try { // CheckConnectStatus if (! $this->client->isConnected()) { $this->logger->warning('WebSocket un Connect，try re Connect', [ 'task_id' => $this->taskId, ]); $this->connect(); } // setCurrentReceiveOperationTimeoutTime $remainingTime = $endTime - time(); if ($remainingTime <= 0) { // OverallOperationTimeout return Null; } // setshorterreadgetTimeout, For regularCheckStatus $readTimeout = min($remainingTime, 180); $this->client->setReadTimeout($readTimeout); // ReceiveMessage $rawMessage = $this->client->receive(); if ($rawMessage === Null) { continue; // this times readgetTimeout，Continuetry } // Update most  after MessageTime $this->lastMessageTime = time(); // directlyReturnOriginalMessage return $rawMessage; } catch (WebSocketConnectionException $e) { ++$retryCount; if ($retryCount > $maxRetries) { $this->logger->error(sprintf( 'WebSocketConnection failedAndexceedMaximumRetry times  count : %s，TaskID: %s，Retry times  count : %d', $e->getMessage(), $this->taskId, $retryCount )); throw $e; // exceedMaximumRetry times  count ，ThrowAbnormal } // calculateExponential backoffDelay $delay = min($baseDelay * pow(2, $retryCount - 1), $this->config->getMaxRetryDelay()); $this->logger->warning(sprintf( 'WebSocketConnection failed，th%d times Retry，Wait%d seconds ，TaskID: %s，Error: %s', $retryCount, $delay, $this->taskId, $e->getMessage() )); sleep($delay); } } // OperationTimeout $this->logger->warning(sprintf( 'WebSocketReceiveMessageTimeout，TaskID: %s，TimeoutTime: %d seconds ', $this->taskId, $actualTimeout )); throw new WebSocketTimeoutException(sprintf( 'WebSocketReceiveMessageTimeout，TaskID: %s，TimeoutTime: %d seconds ', $this->taskId, $actualTimeout )); } /** * CheckWebSocketConnectStatus * * @return bool ConnectwhetherInActiveStatus*/ public function isConnected(): bool { return $this->client->isConnected(); } /** * CheckSessionwhetherExpire (longTime un activity). * * @return bool SessionwhetherExpire*/ public function isExpired(): bool { return time() - $this->lastMessageTime > $this->config->getMaxIdleTime(); } /** * getCurrentSessionTaskID. * * @return string TaskID*/ public function getTaskId(): string { return $this->taskId; } /** * getCurrentSessiontoken. * * @return Null|string tokenValue or Null*/ public function getToken(): ?string { return $this->token; } } 